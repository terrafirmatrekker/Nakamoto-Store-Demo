"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitcoinBaseChain = void 0;
const bech32_1 = __importDefault(require("bech32"));
const interfaces_1 = require("@renproject/interfaces");
const utils_1 = require("@renproject/utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bitcore_lib_1 = require("bitcore-lib");
const bs58_1 = __importDefault(require("bs58"));
const API_1 = require("./APIs/API");
const blockchair_1 = require("./APIs/blockchair");
const blockstream_1 = require("./APIs/blockstream");
const sochain_1 = require("./APIs/sochain");
const script_1 = require("./script");
const transactionToDeposit = (transaction) => ({
    transaction,
    amount: transaction.amount.toString(),
});
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
class BitcoinBaseChain {
    constructor(network) {
        this.chain = BitcoinBaseChain.chain;
        this.name = BitcoinBaseChain.chain;
        this.legacyName = "Btc";
        this.asset = "BTC";
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(blockstream_1.Blockstream())
                        .withAPI(blockchair_1.Blockchair())
                        .withAPI(sochain_1.SoChain(), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(blockstream_1.Blockstream({ testnet: true }))
                        .withAPI(blockchair_1.Blockchair(blockchair_1.BlockchairNetwork.BITCOIN_TESTNET))
                        .withAPI(sochain_1.SoChain(sochain_1.SoChainNetwork.BTCTEST), { priority: 15 });
                case "regtest":
                    // Will be supported when Electrum is added as an API.
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.api = API_1.CombinedAPI();
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.api.withAPI(api, { priority });
            return this;
        };
        this.utils = utils_1.utilsWithChainNetwork(BitcoinBaseChain.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = interfaces_1.getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet ? "testnet" : "mainnet");
            return this.withDefaultAPIs(this.chainNetwork);
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => asset === this.asset;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Unsupported asset ${asset}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            if (asset === this.asset) {
                return 8;
            }
            throw new Error(`Unsupported asset ${asset}`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = async (asset, address, progress, onDeposit) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            if (this.chainNetwork === "regtest") {
                throw new Error(`Unable to fetch deposits on ${this.chainNetwork}`);
            }
            this.assertAssetIsSupported(asset);
            let txs;
            if (!progress) {
                try {
                    txs = await utils_1.retryNTimes(() => this.api.fetchTXs(address), 2);
                }
                catch (error) {
                    // Ignore error and fallback to getUTXOs.
                }
            }
            if (!txs) {
                txs = await this.api.fetchUTXOs(address);
            }
            await Promise.all(txs.map(async (tx) => onDeposit(transactionToDeposit(tx))));
            return true;
        };
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = async (transaction) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            transaction = await this.api.fetchUTXO(transaction.txHash, transaction.vOut);
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === "mainnet" ? 6 : 2,
            };
        };
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, publicKey, gHash) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            this.assertAssetIsSupported(asset);
            const isTestnet = this.chainNetwork === "testnet";
            return this.utils.createAddress(isTestnet, utils_1.hash160(publicKey), gHash, this.utils.p2shPrefix[isTestnet ? "testnet" : "mainnet"]);
        };
        /**
         * See [[LockChain.addressStringToBytes]].
         */
        this.addressStringToBytes = (address) => {
            try {
                return bs58_1.default.decode(address);
            }
            catch (error) {
                try {
                    const [type, ...words] = bech32_1.default.decode(address).words;
                    return Buffer.concat([
                        Buffer.from([type]),
                        Buffer.from(bech32_1.default.fromWords(words)),
                    ]);
                }
                catch (internalError) {
                    throw new Error(`Unrecognized address format "${address}".`);
                }
            }
        };
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.txHash;
        this.transactionFromID = (txid, txindex, reversed) => {
            let txidString;
            // RenVM returns TXIDs in the correct byte direction, so they should be
            // reversed when converting to a string.
            // See https://learnmeabitcoin.com/technical/txid#why
            if (reversed) {
                // Reverse bytes.
                const bufferTxid = typeof txid === "string"
                    ? Buffer.from(utils_1.strip0x(txid), "hex")
                    : txid;
                txidString = bufferTxid.reverse().toString("hex");
            }
            else {
                txidString = typeof txid === "string" ? txid : txid.toString("hex");
            }
            return this.api.fetchUTXO(txidString, parseInt(txindex, 10));
        };
        this.depositV1HashString = ({ transaction }) => {
            return `${utils_1.toBase64(utils_1.fromHex(transaction.txHash))}_${transaction.vOut}`;
        };
        this.transactionRPCFormat = (transaction, v2) => {
            const { txHash, vOut } = transaction;
            utils_1.assertType("string", { txHash });
            utils_1.assertType("number", { vOut });
            return {
                txid: v2
                    ? utils_1.fromHex(transaction.txHash).reverse()
                    : utils_1.fromHex(transaction.txHash),
                txindex: transaction.vOut.toFixed(),
            };
        };
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.Address = (address) => {
            // Type validation
            utils_1.assertType("string", { address });
            this.getBurnPayload = () => address;
            return this;
        };
        this.burnPayload = () => {
            return this.getBurnPayload ? this.getBurnPayload() : undefined;
        };
        this.toSats = (value) => new bignumber_js_1.default(value)
            .times(new bignumber_js_1.default(10).exponentiatedBy(8))
            .decimalPlaces(0)
            .toFixed();
        this.fromSats = (value) => new bignumber_js_1.default(value)
            .dividedBy(new bignumber_js_1.default(10).exponentiatedBy(8))
            .toFixed();
        this.chainNetwork = network;
    }
}
exports.BitcoinBaseChain = BitcoinBaseChain;
BitcoinBaseChain.chain = "Bitcoin";
// Asset
BitcoinBaseChain.asset = "BTC";
// Utils
BitcoinBaseChain.utils = {
    p2shPrefix: {},
    createAddress: script_1.createAddress(bs58_1.default.encode, bitcore_lib_1.Networks, bitcore_lib_1.Opcode, bitcore_lib_1.Script),
    calculatePubKeyScript: script_1.pubKeyScript(bitcore_lib_1.Networks, bitcore_lib_1.Opcode, bitcore_lib_1.Script),
    addressIsValid: (_address, _network = "mainnet") => true,
    addressExplorerLink: (_address, _network = "mainnet") => undefined,
    transactionExplorerLink: (_tx, _network = "mainnet") => undefined,
    resolveChainNetwork: (network) => {
        if (network === "mainnet" ||
            network === "testnet" ||
            network === "regtest") {
            return network;
        }
        const renNetwork = interfaces_1.getRenNetworkDetails(network);
        return renNetwork.isTestnet ? "testnet" : "mainnet";
    },
};
const _ = BitcoinBaseChain;
//# sourceMappingURL=base.js.map