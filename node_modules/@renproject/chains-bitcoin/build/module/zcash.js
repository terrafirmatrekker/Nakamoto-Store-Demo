import { Callable, utilsWithChainNetwork } from "@renproject/utils";
import { Networks, Opcode, Script } from "bitcore-lib-zcash";
import base58 from "bs58";
import { Insight } from "./APIs/insight";
import { SoChain, SoChainNetwork } from "./APIs/sochain";
import { BitcoinClass } from "./bitcoin";
import { createAddress, pubKeyScript } from "./script";
import { validateAddress } from "./utils";
var InsightEndpoints;
(function (InsightEndpoints) {
    // Testnet
    InsightEndpoints["TestnetZCash"] = "https://explorer.testnet.z.cash/api/";
    // Mainnet
    InsightEndpoints["ZCash"] = "https://explorer.z.cash/api/";
    InsightEndpoints["ZecBlockExplorer"] = "https://zecblockexplorer.com/api/";
    InsightEndpoints["ZecChain"] = "https://zechain.net/api/v1/";
    InsightEndpoints["BlockExplorer"] = "https://zcash.blockexplorer.com/api/";
})(InsightEndpoints || (InsightEndpoints = {}));
export class ZcashClass extends BitcoinClass {
    constructor() {
        super(...arguments);
        this.chain = ZcashClass.chain;
        this.name = ZcashClass.chain;
        this.legacyName = "Zec";
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(Insight(InsightEndpoints.ZCash))
                        .withAPI(Insight(InsightEndpoints.ZecBlockExplorer))
                        .withAPI(Insight(InsightEndpoints.ZecChain))
                        .withAPI(Insight(InsightEndpoints.BlockExplorer))
                        .withAPI(SoChain(SoChainNetwork.ZEC), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(Insight(InsightEndpoints.TestnetZCash))
                        .withAPI(SoChain(SoChainNetwork.ZECTEST), { priority: 15 });
                case "regtest":
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.asset = "ZEC";
        this.utils = utilsWithChainNetwork(Zcash.utils, () => this.chainNetwork);
    }
}
ZcashClass.chain = "Zcash";
ZcashClass.asset = "ZEC";
ZcashClass.utils = {
    resolveChainNetwork: BitcoinClass.utils.resolveChainNetwork,
    p2shPrefix: {
        mainnet: Buffer.from([0x1c, 0xbd]),
        testnet: Buffer.from([0x1c, 0xba]),
    },
    createAddress: createAddress(base58.encode, Networks, Opcode, Script),
    calculatePubKeyScript: pubKeyScript(Networks, Opcode, Script),
    addressIsValid: (address, network = "mainnet") => validateAddress(address, ZcashClass.asset, Zcash.utils.resolveChainNetwork(network)),
    addressExplorerLink: (address, network = "mainnet") => {
        switch (Zcash.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://sochain.com/address/ZEC/${address}/`;
            case "testnet":
                return `https://sochain.com/address/ZECTEST/${address}/`;
            case "regtest":
                return undefined;
        }
    },
    transactionExplorerLink: (tx, network = "mainnet") => {
        const txHash = typeof tx === "string" ? tx : tx.txHash;
        switch (Zcash.utils.resolveChainNetwork(network)) {
            case "mainnet":
                return `https://sochain.com/tx/ZEC/${txHash}/`;
            case "testnet":
                return `https://sochain.com/tx/ZECTEST/${txHash}/`;
            case "regtest":
                return undefined;
        }
    },
};
export const Zcash = Callable(ZcashClass);
const _ = Zcash;
//# sourceMappingURL=zcash.js.map