import bech32 from "bech32";
import { getRenNetworkDetails, } from "@renproject/interfaces";
import { assertType, fromHex, hash160, retryNTimes, strip0x, toBase64, utilsWithChainNetwork, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { Networks, Opcode, Script } from "bitcore-lib";
import base58 from "bs58";
import { CombinedAPI } from "./APIs/API";
import { Blockchair, BlockchairNetwork } from "./APIs/blockchair";
import { Blockstream } from "./APIs/blockstream";
import { SoChain, SoChainNetwork } from "./APIs/sochain";
import { createAddress, pubKeyScript as calculatePubKeyScript } from "./script";
const transactionToDeposit = (transaction) => ({
    transaction,
    amount: transaction.amount.toString(),
});
/**
 * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.
 */
export class BitcoinBaseChain {
    constructor(network) {
        this.chain = BitcoinBaseChain.chain;
        this.name = BitcoinBaseChain.chain;
        this.legacyName = "Btc";
        this.asset = "BTC";
        // APIs
        this.withDefaultAPIs = (network) => {
            switch (network) {
                case "mainnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockstream())
                        .withAPI(Blockchair())
                        .withAPI(SoChain(), { priority: 15 });
                case "testnet":
                    // prettier-ignore
                    return this
                        .withAPI(Blockstream({ testnet: true }))
                        .withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET))
                        .withAPI(SoChain(SoChainNetwork.BTCTEST), { priority: 15 });
                case "regtest":
                    // Will be supported when Electrum is added as an API.
                    throw new Error(`Regtest is currently not supported.`);
            }
        };
        this.api = CombinedAPI();
        this.withAPI = (api, { priority = 0 } = {}) => {
            this.api.withAPI(api, { priority });
            return this;
        };
        this.utils = utilsWithChainNetwork(BitcoinBaseChain.utils, () => this.chainNetwork);
        /**
         * See [[LockChain.initialize]].
         */
        this.initialize = (renNetwork) => {
            this.renNetwork = getRenNetworkDetails(renNetwork);
            // Prioritize the network passed in to the constructor.
            this.chainNetwork =
                this.chainNetwork ||
                    (this.renNetwork.isTestnet ? "testnet" : "mainnet");
            return this.withDefaultAPIs(this.chainNetwork);
        };
        /**
         * See [[LockChain.assetIsNative]].
         */
        this.assetIsNative = (asset) => asset === this.asset;
        this.assetIsSupported = this.assetIsNative;
        this.assertAssetIsSupported = (asset) => {
            if (!this.assetIsNative(asset)) {
                throw new Error(`Unsupported asset ${asset}.`);
            }
        };
        /**
         * See [[LockChain.assetDecimals]].
         */
        this.assetDecimals = (asset) => {
            if (asset === this.asset) {
                return 8;
            }
            throw new Error(`Unsupported asset ${asset}`);
        };
        /**
         * See [[LockChain.getDeposits]].
         */
        this.getDeposits = async (asset, address, progress, onDeposit) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            if (this.chainNetwork === "regtest") {
                throw new Error(`Unable to fetch deposits on ${this.chainNetwork}`);
            }
            this.assertAssetIsSupported(asset);
            let txs;
            if (!progress) {
                try {
                    txs = await retryNTimes(() => this.api.fetchTXs(address), 2);
                }
                catch (error) {
                    // Ignore error and fallback to getUTXOs.
                }
            }
            if (!txs) {
                txs = await this.api.fetchUTXOs(address);
            }
            await Promise.all(txs.map(async (tx) => onDeposit(transactionToDeposit(tx))));
            return true;
        };
        /**
         * See [[LockChain.transactionConfidence]].
         */
        this.transactionConfidence = async (transaction) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            transaction = await this.api.fetchUTXO(transaction.txHash, transaction.vOut);
            return {
                current: transaction.confirmations,
                target: this.chainNetwork === "mainnet" ? 6 : 2,
            };
        };
        /**
         * See [[LockChain.getGatewayAddress]].
         */
        this.getGatewayAddress = (asset, publicKey, gHash) => {
            if (!this.chainNetwork) {
                throw new Error(`${this.name} object not initialized`);
            }
            this.assertAssetIsSupported(asset);
            const isTestnet = this.chainNetwork === "testnet";
            return this.utils.createAddress(isTestnet, hash160(publicKey), gHash, this.utils.p2shPrefix[isTestnet ? "testnet" : "mainnet"]);
        };
        /**
         * See [[LockChain.addressStringToBytes]].
         */
        this.addressStringToBytes = (address) => {
            try {
                return base58.decode(address);
            }
            catch (error) {
                try {
                    const [type, ...words] = bech32.decode(address).words;
                    return Buffer.concat([
                        Buffer.from([type]),
                        Buffer.from(bech32.fromWords(words)),
                    ]);
                }
                catch (internalError) {
                    throw new Error(`Unrecognized address format "${address}".`);
                }
            }
        };
        /**
         * See [[LockChain.transactionID]].
         */
        this.transactionID = (transaction) => transaction.txHash;
        this.transactionFromID = (txid, txindex, reversed) => {
            let txidString;
            // RenVM returns TXIDs in the correct byte direction, so they should be
            // reversed when converting to a string.
            // See https://learnmeabitcoin.com/technical/txid#why
            if (reversed) {
                // Reverse bytes.
                const bufferTxid = typeof txid === "string"
                    ? Buffer.from(strip0x(txid), "hex")
                    : txid;
                txidString = bufferTxid.reverse().toString("hex");
            }
            else {
                txidString = typeof txid === "string" ? txid : txid.toString("hex");
            }
            return this.api.fetchUTXO(txidString, parseInt(txindex, 10));
        };
        this.depositV1HashString = ({ transaction }) => {
            return `${toBase64(fromHex(transaction.txHash))}_${transaction.vOut}`;
        };
        this.transactionRPCFormat = (transaction, v2) => {
            const { txHash, vOut } = transaction;
            assertType("string", { txHash });
            assertType("number", { vOut });
            return {
                txid: v2
                    ? fromHex(transaction.txHash).reverse()
                    : fromHex(transaction.txHash),
                txindex: transaction.vOut.toFixed(),
            };
        };
        /**
         * When burning, you can call `Bitcoin.Address("...")` to make the address
         * available to the burn params.
         *
         * @category Main
         */
        this.Address = (address) => {
            // Type validation
            assertType("string", { address });
            this.getBurnPayload = () => address;
            return this;
        };
        this.burnPayload = () => {
            return this.getBurnPayload ? this.getBurnPayload() : undefined;
        };
        this.toSats = (value) => new BigNumber(value)
            .times(new BigNumber(10).exponentiatedBy(8))
            .decimalPlaces(0)
            .toFixed();
        this.fromSats = (value) => new BigNumber(value)
            .dividedBy(new BigNumber(10).exponentiatedBy(8))
            .toFixed();
        this.chainNetwork = network;
    }
}
BitcoinBaseChain.chain = "Bitcoin";
// Asset
BitcoinBaseChain.asset = "BTC";
// Utils
BitcoinBaseChain.utils = {
    p2shPrefix: {},
    createAddress: createAddress(base58.encode, Networks, Opcode, Script),
    calculatePubKeyScript: calculatePubKeyScript(Networks, Opcode, Script),
    addressIsValid: (_address, _network = "mainnet") => true,
    addressExplorerLink: (_address, _network = "mainnet") => undefined,
    transactionExplorerLink: (_tx, _network = "mainnet") => undefined,
    resolveChainNetwork: (network) => {
        if (network === "mainnet" ||
            network === "testnet" ||
            network === "regtest") {
            return network;
        }
        const renNetwork = getRenNetworkDetails(network);
        return renNetwork.isTestnet ? "testnet" : "mainnet";
    },
};
const _ = BitcoinBaseChain;
//# sourceMappingURL=base.js.map