import { getRenNetworkDetails, NullLogger, RenNetwork, } from "@renproject/interfaces";
import { RenVMProvider as V1Provider } from "./v1";
import { RenVMProvider as V2Provider } from "./v2";
const isV1Selector = (selector) => {
    return ([
        "BTC0Btc2Eth",
        "BTC0Eth2Btc",
        "ZEC0Zec2Eth",
        "ZEC0Eth2Zec",
        "BCH0Bch2Eth",
        "BCH0Eth2Bch",
    ].indexOf(selector) >= 0);
};
export class CombinedProvider {
    constructor(network, logger = NullLogger) {
        this.selector = (params) => {
            const v1Selector = this.v1 && this.v1.selector(params);
            return v1Selector && isV1Selector(v1Selector)
                ? v1Selector
                : this.v2.selector(params);
        };
        this.version = (selector) => (isV1Selector(selector) ? 1 : 2);
        this.mintTxHash = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.mintTxHash(params)
            : this.v2.mintTxHash(params);
        this.submitMint = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.submitMint(params)
            : this.v2.submitMint(params);
        this.burnTxHash = (params) => {
            if (isV1Selector(params.selector)) {
                throw new Error(`Fetching burn txHash is not supported for ${params.selector}`);
            }
            return this.v2.burnTxHash(params);
        };
        this.submitBurn = (params) => this.v1 && isV1Selector(params.selector)
            ? this.v1.submitBurn(params)
            : this.v2.submitBurn(params);
        this.queryMintOrBurn = (selector, utxoTxHash) => this.v1 && isV1Selector(selector)
            ? this.v1.queryMintOrBurn(selector, utxoTxHash)
            : this.v2.queryMintOrBurn(selector, utxoTxHash);
        this.waitForTX = (selector, utxoTxHash, onStatus, cancelRequested, timeout) => this.v1 && isV1Selector(selector)
            ? this.v1.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout)
            : this.v2.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout);
        /**
         * selectPublicKey fetches the key for the RenVM shard handling
         * the provided contract.
         *
         * @returns The key hash (20 bytes) as a string.
         */
        this.selectPublicKey = (selector, assetOrChain) => this.v1 && isV1Selector(selector)
            ? this.v1.selectPublicKey(selector, assetOrChain)
            : this.v2.selectPublicKey(selector, assetOrChain);
        /**
         * Used to query what network a custom provider is connected to. LockAndMint
         * and BurnAndRelease use this to configure their chain parameters.
         */
        this.getNetwork = (selector) => this.v1 && isV1Selector(selector)
            ? this.v1.getNetwork(selector)
            : this.v2.getNetwork(selector);
        this.getConfirmationTarget = async (selector, chain) => this.v1 && isV1Selector(selector)
            ? this.v1.getConfirmationTarget(selector, chain)
            : this.v2.getConfirmationTarget(selector, chain);
        this.estimateTransactionFee = async (selector, chain) => this.v1 && isV1Selector(selector)
            ? this.v1.estimateTransactionFee(selector, chain)
            : this.v2.estimateTransactionFee(selector, chain);
        this.network = getRenNetworkDetails(network);
        let v1Network;
        let v2Network;
        switch (this.network.name) {
            case RenNetwork.Mainnet:
            case RenNetwork.Mainnet:
            case RenNetwork.MainnetVDot3:
            case RenNetwork.MainnetVDot3:
                v1Network = RenNetwork.Mainnet;
                v2Network = RenNetwork.MainnetVDot3;
                break;
            case RenNetwork.Testnet:
            case RenNetwork.Testnet:
            case RenNetwork.TestnetVDot3:
            case RenNetwork.TestnetVDot3:
                v1Network = RenNetwork.Testnet;
                v2Network = RenNetwork.TestnetVDot3;
                break;
            case RenNetwork.DevnetVDot3:
            case RenNetwork.DevnetVDot3:
                v2Network = RenNetwork.DevnetVDot3;
                break;
            default:
                v1Network = network;
                v2Network = network;
        }
        if (v1Network) {
            this.v1 = new V1Provider(v1Network, undefined, logger);
        }
        this.v2 = new V2Provider(v2Network, undefined, logger);
        // Default to the v2 network.
        this.sendMessage = this.v2.sendMessage;
    }
}
//# sourceMappingURL=combinedProvider.js.map