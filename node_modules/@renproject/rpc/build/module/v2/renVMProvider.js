import { getRenNetworkDetails, NullLogger, TxStatus, } from "@renproject/interfaces";
import { HttpProvider } from "@renproject/provider";
import { assertType, fromBase64, isDefined, SECONDS, sleep, toURLBase64, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { RPCMethod, } from "./methods";
import { hashTransaction, mintParamsType, } from "./transaction";
import { unmarshalBurnTx, unmarshalMintTx } from "./unmarshal";
export const resolveV2Contract = ({ asset, from, to, }) => {
    if (from.assetIsNative &&
        from.assetIsNative(asset)) {
        return `${asset}/to${to.name}`;
    }
    if (to.assetIsNative &&
        to.assetIsNative(asset)) {
        return `${asset}/from${from.name}`;
    }
    return `${asset}/from${from.name}To${to.name}`;
};
export class RenVMProvider {
    constructor(network, provider, logger = NullLogger) {
        this.version = () => 2;
        this.selector = (params) => {
            return resolveV2Contract(params);
        };
        this.queryBlock = async (blockHeight, retry) => this.sendMessage(RPCMethod.QueryBlock, { blockHeight }, retry);
        this.queryBlocks = async (blockHeight, n, retry) => this.sendMessage(RPCMethod.QueryBlocks, { blockHeight, n }, retry);
        this.submitTx = async (tx, retry) => this.sendMessage(RPCMethod.SubmitTx, { tx }, retry);
        this.queryTx = async (txHash, retry) => this.sendMessage(RPCMethod.QueryTx, { txHash }, retry);
        this.queryTxs = async (tags, page, pageSize, txStatus, retry) => this.sendMessage(RPCMethod.QueryTxs, {
            tags,
            page: (page || 0).toString(),
            pageSize: (pageSize || 0).toString(),
            txStatus,
        }, retry);
        this.queryConfig = async (retry) => this.sendMessage(RPCMethod.QueryConfig, {}, retry);
        this.queryState = async (retry) => this.sendMessage(RPCMethod.QueryState, {}, retry);
        this.buildTransaction = ({ selector, gHash, gPubKey, nHash, nonce, output, amount, payload, pHash, to, }) => {
            assertType("Buffer", {
                gHash,
                gPubKey,
                nHash,
                nonce,
                payload,
                pHash,
                txid: output.txid,
            });
            assertType("string", { to, amount, txindex: output.txindex });
            const version = "1";
            const txIn = {
                t: mintParamsType(),
                v: {
                    txid: toURLBase64(output.txid),
                    txindex: output.txindex,
                    ghash: toURLBase64(gHash),
                    gpubkey: toURLBase64(gPubKey),
                    nhash: toURLBase64(nHash),
                    nonce: toURLBase64(nonce),
                    payload: toURLBase64(payload),
                    phash: toURLBase64(pHash),
                    to,
                    amount,
                },
            };
            return {
                hash: toURLBase64(hashTransaction(version, selector, txIn)),
                selector: selector,
                version,
                // TODO: Fix types
                in: txIn,
            };
        };
        this.mintTxHash = (params) => {
            return fromBase64(this.buildTransaction(params).hash);
        };
        this.submitMint = async (params) => {
            const tx = this.buildTransaction(params);
            await this.submitTx(tx);
            return fromBase64(tx.hash);
        };
        this.burnTxHash = this.mintTxHash;
        this.submitBurn = this.submitMint;
        /**
         * Queries the result of a RenVM transaction and unmarshals the result into
         * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].
         *
         * @param renVMTxHash The transaction hash as a Buffer.
         */
        this.queryMintOrBurn = async (_selector, renVMTxHash) => {
            try {
                const response = await this.queryTx(toURLBase64(renVMTxHash));
                // Unmarshal transaction.
                // TODO: Improve mint/burn detection. Currently checks if the format
                // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return
                // a false positive if the chain name contains `To`.
                const isMint = /((\/to)|(To))/.exec(response.tx.selector);
                if (isMint) {
                    return unmarshalMintTx(response);
                }
                else {
                    return unmarshalBurnTx(response);
                }
            }
            catch (error) {
                throw error;
            }
        };
        /**
         * Fetches the result of a RenVM transaction on a repeated basis until the
         * transaction's status is `"done"`.
         *
         * @param utxoTxHash The transaction hash as a Buffer.
         * @param onStatus A callback called each time the status of the transaction
         * is refreshed - even if it hasn't changed.
         * @param _cancelRequested A function that returns `true` to cancel the
         * loop.
         */
        this.waitForTX = async (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => {
            assertType("Buffer", { utxoTxHash });
            let rawResponse;
            while (true) {
                if (_cancelRequested && _cancelRequested()) {
                    throw new Error(`waitForTX cancelled.`);
                }
                try {
                    const result = await this.queryMintOrBurn(selector, utxoTxHash);
                    if (result && result.txStatus === TxStatus.TxStatusDone) {
                        rawResponse = result;
                        break;
                    }
                    else if (onStatus && result && result.txStatus) {
                        onStatus(result.txStatus);
                    }
                }
                catch (error) {
                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {
                        // ignore
                    }
                    else {
                        this.logger.error(String(error));
                        // TODO: throw unexpected errors
                    }
                }
                await sleep(isDefined(timeout) ? timeout : 15 * SECONDS);
            }
            return rawResponse;
        };
        /**
         * selectPublicKey fetches the public key for the RenVM shard handling
         * the provided contract.
         *
         * @param chain The chain for which the public key should be fetched.
         * @returns The public key hash (20 bytes) as a string.
         */
        this.selectPublicKey = async (_selector, chain) => {
            // Call the ren_queryShards RPC.
            const response = await this.queryState(5);
            return fromBase64(response.state[chain].pubKey);
        };
        // In the future, this will be asynchronous. It returns a promise for
        // compatibility.
        // eslint-disable-next-line @typescript-eslint/require-await
        this.getNetwork = async (_selector) => {
            return this.network;
        };
        this.getConfirmationTarget = async (_selector, chain) => {
            const renVMConfig = await this.sendMessage(RPCMethod.QueryConfig, {});
            return parseInt(renVMConfig.confirmations[chain.name], 10);
        };
        this.estimateTransactionFee = async (_selector, chain) => {
            const renVMState = await this.sendMessage(RPCMethod.QueryState, {});
            if (!renVMState.state[chain.name]) {
                throw new Error(`No fee details found for ${chain.name}`);
            }
            const { gasLimit, gasCap } = renVMState.state[chain.name];
            const fee = new BigNumber(gasLimit).times(new BigNumber(gasCap));
            return {
                lock: fee,
                release: fee,
            };
        };
        if (!provider || typeof provider === "string") {
            const rpcUrl = provider || (getRenNetworkDetails(network) || {}).lightnode;
            try {
                provider = new HttpProvider(rpcUrl, logger);
            }
            catch (error) {
                if (/Invalid node URL/.exec(String(error && error.message))) {
                    throw new Error(`Invalid network or provider URL: "${(getRenNetworkDetails(network) || {}).name ||
                        String(network)}"`);
                }
                throw error;
            }
        }
        this.network = network;
        this.logger = logger;
        this.provider = provider;
        this.sendMessage = this.provider.sendMessage;
    }
}
//# sourceMappingURL=renVMProvider.js.map