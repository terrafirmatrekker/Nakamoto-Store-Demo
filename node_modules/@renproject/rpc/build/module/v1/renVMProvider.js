import { getRenNetworkDetails, NullLogger, RenJSErrors, TxStatus, } from "@renproject/interfaces";
import { HttpProvider } from "@renproject/provider";
import { assertType, extractError, fromBase64, isDefined, keccak256, parseV1Selector, SECONDS, sleep, strip0x, toBase64, } from "@renproject/utils";
import { List } from "immutable";
import { RPCMethod, } from "./methods";
import { unmarshalBurnTx, unmarshalFees, unmarshalMintTx } from "./unmarshal";
import { RenVMType } from "./value";
export const generateMintTxHash = (selector, encodedID, deposit, logger = NullLogger) => {
    // Type validation
    assertType("string", { encodedID, deposit });
    const message = `txHash_${selector}_${encodedID}_${deposit}`;
    const digest = keccak256(Buffer.from(message));
    logger.debug("Mint txHash", toBase64(digest), message);
    return digest;
};
export class RenVMProvider {
    constructor(network, provider, logger = NullLogger) {
        this.version = () => 1;
        this.selector = ({ asset, from, to, }) => {
            return `${asset}0${from.legacyName || from.name}2${to.legacyName || from.name}`;
        };
        this.queryBlock = async (blockHeight, retry) => this.sendMessage(RPCMethod.MethodQueryBlock, { blockHeight }, retry);
        this.queryBlocks = async (blockHeight, n, retry) => this.sendMessage(RPCMethod.MethodQueryBlocks, { blockHeight, n }, retry);
        this.submitTx = async (tx, retry) => this.sendMessage(RPCMethod.MethodSubmitTx, { tx }, retry);
        this.queryTx = async (txHash, retry) => this.sendMessage(RPCMethod.MethodQueryTx, { txHash }, retry);
        this.queryTxs = async (tags, page, pageSize, txStatus, retry) => this.sendMessage(RPCMethod.MethodQueryTxs, {
            tags,
            page: (page || 0).toString(),
            pageSize: (pageSize || 0).toString(),
            txStatus,
        }, retry);
        this.queryNumPeers = async (retry) => this.sendMessage(RPCMethod.MethodQueryNumPeers, {}, retry);
        this.queryPeers = async (retry) => this.sendMessage(RPCMethod.MethodQueryPeers, {}, retry);
        this.queryShards = async (retry) => this.sendMessage(RPCMethod.MethodQueryShards, {}, retry);
        this.queryStat = async (retry) => this.sendMessage(RPCMethod.MethodQueryStat, {}, retry);
        this.queryFees = async (retry) => this.sendMessage(RPCMethod.MethodQueryFees, {}, retry);
        this.getFees = async () => unmarshalFees(await this.queryFees());
        this.mintTxHash = ({ selector, gHash, outputHashFormat, }) => {
            assertType("Buffer", { gHash });
            assertType("string", { outputHashFormat });
            return generateMintTxHash(selector, toBase64(gHash), outputHashFormat, this.logger);
        };
        this.submitMint = async ({ selector, nonce, output, payload, to, token, fn, fnABI, tags, }) => {
            const { txindex, txid } = output;
            assertType("Buffer", { nonce, payload, txid });
            assertType("string", { to, token, fn, txindex });
            const response = await this.sendMessage(RPCMethod.MethodSubmitTx, {
                tx: {
                    to: selector,
                    in: [
                        //
                        {
                            name: "p",
                            type: RenVMType.ExtEthCompatPayload,
                            value: {
                                abi: toBase64(Buffer.from(JSON.stringify(fnABI))),
                                value: toBase64(payload),
                                fn: toBase64(Buffer.from(fn)),
                            },
                        },
                        // The hash of the payload data
                        // { name: "phash" as const, type: RenVMType.B32 as const, value: toBase64(pHash) },
                        // The amount of BTC (in SATs) that has be transferred to the gateway
                        // { name: "amount" as const, type: "u64", as const value: amount },
                        // The ERC20 contract address on Ethereum for BTC
                        {
                            name: "token",
                            type: RenVMType.ExtTypeEthCompatAddress,
                            value: strip0x(token),
                        },
                        // The address on the Ethereum blockchain to which BTC will be transferred
                        {
                            name: "to",
                            type: RenVMType.ExtTypeEthCompatAddress,
                            value: strip0x(to),
                        },
                        // The nonce is used to randomize the gateway
                        {
                            name: "n",
                            type: RenVMType.B32,
                            value: toBase64(nonce),
                        },
                        // UTXO
                        {
                            name: "utxo",
                            type: RenVMType.ExtTypeBtcCompatUTXO,
                            value: {
                                txHash: toBase64(txid),
                                vOut: txindex,
                            },
                        },
                    ],
                },
                tags,
            });
            return fromBase64(response.tx.hash);
        };
        this.submitBurn = async (params) => {
            const { selector, burnNonce, tags } = params;
            const response = await this.sendMessage(RPCMethod.MethodSubmitTx, {
                tx: {
                    to: selector,
                    in: [
                        {
                            name: "ref",
                            type: RenVMType.U64,
                            value: burnNonce.decimalPlaces(0).toFixed(),
                        },
                    ],
                },
                tags,
            });
            return fromBase64(response.tx.hash);
        };
        this.queryMintOrBurn = async (_selector, utxoTxHash) => {
            const response = await this.queryTx(toBase64(utxoTxHash));
            // Unmarshal transaction.
            const { asset, from } = parseV1Selector(response.tx.to);
            if (asset.toUpperCase() === from.toUpperCase()) {
                return unmarshalMintTx(response);
            }
            else {
                return unmarshalBurnTx(response);
            }
        };
        this.waitForTX = async (selector, utxoTxHash, onStatus, _cancelRequested, timeout) => {
            assertType("Buffer", { utxoTxHash });
            let rawResponse;
            while (true) {
                if (_cancelRequested && _cancelRequested()) {
                    throw new Error(`waitForTX cancelled`);
                }
                try {
                    const result = await this.queryMintOrBurn(selector, utxoTxHash);
                    if (result && result.txStatus === TxStatus.TxStatusDone) {
                        rawResponse = result;
                        break;
                    }
                    else if (onStatus && result && result.txStatus) {
                        onStatus(result.txStatus);
                    }
                }
                catch (error) {
                    if (/(not found)|(not available)/.exec(String((error || {}).message))) {
                        // ignore
                    }
                    else {
                        this.logger.error(String(error));
                        // TODO: throw unexpected errors
                    }
                }
                await sleep(isDefined(timeout) ? timeout : 15 * SECONDS);
            }
            return rawResponse;
        };
        /**
         * selectPublicKey fetches the public key for the RenVM shard handling
         * the provided contract.
         *
         * @param asset The asset for which the public key should be fetched.
         * @returns The public key hash (20 bytes) as a string.
         */
        this.selectPublicKey = async (_selector, asset) => {
            // Call the ren_queryShards RPC.
            const response = await this.queryShards(5);
            // Prioritize primary shards.
            const chosenShard = response.shards.sort((a, b) => a.primary && b.primary ? -1 : a.primary ? -1 : b.primary ? 1 : 0)[0];
            if (!chosenShard) {
                throw new Error("Unable to load public key from RenVM: no shards found");
            }
            // Get the gateway pubKey from the gateway with the right asset within
            // the shard with the lowest total value locked.
            const tokenGateway = List(chosenShard.gateways)
                .filter((gateway) => gateway.asset === asset)
                .first(undefined);
            if (!tokenGateway) {
                throw new Error(`Unable to load public key from RenVM: no gateway for the asset ${asset}`);
            }
            // Use this gateway pubKey to build the gateway address.
            // return hash160(
            return fromBase64(tokenGateway.pubKey);
        };
        // In the future, this will be asynchronous. It returns a promise for
        // compatibility.
        // eslint-disable-next-line @typescript-eslint/require-await
        this.getNetwork = async (_selector) => {
            return this.network;
        };
        this.getConfirmationTarget = async (selector, _chain) => {
            const { asset } = parseV1Selector(selector);
            switch (this.network) {
                case "mainnet":
                    switch (asset) {
                        case "BTC":
                            return 6;
                        case "ZEC":
                            return 24;
                        case "BCH":
                            return 15;
                        case "ETH":
                            return 30;
                    }
                    break;
                case "testnet":
                    switch (asset) {
                        case "BTC":
                            return 2;
                        case "ZEC":
                            return 6;
                        case "BCH":
                            return 2;
                        case "ETH":
                            return 12;
                    }
                    break;
            }
            return undefined;
        };
        this.estimateTransactionFee = async (_selector, chain) => {
            const fees = await this.getFees();
            return fees[chain.legacyName
                ? chain.legacyName.toLowerCase()
                : chain.name.toLowerCase()];
        };
        if (!provider) {
            const rpcUrl = (getRenNetworkDetails(network) || {}).lightnode;
            try {
                provider = new HttpProvider(rpcUrl, logger);
            }
            catch (error) {
                if (/Invalid node URL/.exec(String(error && error.message))) {
                    throw new Error(`Invalid network or provider URL: "${(getRenNetworkDetails(network) || {}).name ||
                        String(network)}"`);
                }
                throw error;
            }
        }
        this.network = network;
        this.logger = logger;
        this.provider = provider;
        this.sendMessage = async (method, request, retry = 2, timeout = 120 * SECONDS) => {
            try {
                return await this.provider.sendMessage(method, request, retry, timeout);
            }
            catch (error) {
                const errorString = extractError(error);
                if (/(tx hash=[a-zA-Z0-9+\/=]+ not found)/.exec(errorString)) {
                    error.code = RenJSErrors.RenVMTransactionNotFound;
                }
                if (/(insufficient funds)/.exec(errorString)) {
                    error.code = RenJSErrors.AmountTooSmall;
                }
                if (/(utxo spent or invalid index)/.exec(errorString)) {
                    error.code = RenJSErrors.DepositSpentOrNotFound;
                }
                throw error;
            }
        };
    }
}
//# sourceMappingURL=renVMProvider.js.map