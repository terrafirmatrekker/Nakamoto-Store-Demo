import { getRenNetworkDetails, RenNetwork, } from "@renproject/interfaces";
import { assertType, extractError, fromHex, Ox, payloadToABI, utilsWithChainNetwork, } from "@renproject/utils";
import BigNumber from "bignumber.js";
import Web3 from "web3";
import { renDevnetVDot3, renMainnet, renMainnetVDot3, renTestnet, renTestnetVDot3, } from "./networks";
import { addressIsValid, extractBurnDetails, findBurnByNonce, findTransactionBySigHash, forwardWeb3Events, getGatewayAddress, getTokenAddress, ignorePromiEventError, manualPromiEvent, submitToEthereum, withDefaultAccount, } from "./utils";
export const EthereumConfigMap = {
    [RenNetwork.Mainnet]: renMainnet,
    [RenNetwork.Testnet]: renTestnet,
    [RenNetwork.MainnetVDot3]: renMainnetVDot3,
    [RenNetwork.TestnetVDot3]: renTestnetVDot3,
    [RenNetwork.DevnetVDot3]: renDevnetVDot3,
};
const isEthereumConfig = (renNetwork) => {
    return !!renNetwork.addresses;
};
const resolveNetwork = (renNetwork) => {
    if (!renNetwork) {
        return EthereumConfigMap[RenNetwork.Mainnet];
    }
    let networkConfig;
    if (renNetwork && isEthereumConfig(renNetwork)) {
        networkConfig = renNetwork;
    }
    else if (renNetwork) {
        const networkDetails = getRenNetworkDetails(renNetwork);
        if (EthereumConfigMap[networkDetails.name]) {
            networkConfig = EthereumConfigMap[networkDetails.name];
        }
    }
    if (!networkConfig) {
        throw new Error(`Unrecognized network ${renNetwork}.`);
    }
    return networkConfig;
};
export class EthereumBaseChain {
    constructor(web3Provider, renNetwork) {
        this.chain = EthereumBaseChain.chain;
        this.name = EthereumBaseChain.chain;
        this.legacyName = "Eth";
        this.logRequestLimit = undefined;
        this.utils = utilsWithChainNetwork(EthereumBaseChain.utils, () => this.renNetworkDetails);
        this.getTokenContractAddress = async (asset) => {
            if (!this.web3 || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return getTokenAddress(this.renNetworkDetails, this.web3, asset);
        };
        this.getGatewayContractAddress = async (token) => {
            if (!this.web3 || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const gatewayAddress = await getGatewayAddress(this.renNetworkDetails, this.web3, token);
            if (gatewayAddress === "0x0000000000000000000000000000000000000000") {
                throw new Error(`Asset not supported on mint-chain.`);
            }
            return gatewayAddress;
        };
        this.withProvider = (web3Provider) => {
            this.web3 = new Web3(web3Provider);
            return this;
        };
        /**
         * See [LockChain.initialize].
         */
        this.initialize = (renNetwork) => {
            this.renNetworkDetails =
                this.renNetworkDetails ||
                    EthereumConfigMap[getRenNetworkDetails(renNetwork).name];
            if (!this.renNetworkDetails) {
                throw new Error(`Unable to set ${this.name} network for RenVM network ${getRenNetworkDetails(renNetwork).name}. Please provide ${this.name} network details to ${this.name} constructor.`);
            }
            return this;
        };
        // Supported assets
        this.assetIsNative = (asset) => {
            return asset === "ETH";
        };
        /**
         * `assetIsSupported` should return true if the asset is native to the
         * MintChain.
         *
         * ```ts
         * ethereum.assetIsSupported = asset => asset === "ETH";
         * ```
         */
        this.assetIsSupported = async (asset) => {
            if (this.assetIsNative(asset)) {
                return true;
            }
            if (!this.web3 || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            // Check that there's a gateway contract for the asset.
            try {
                return !!(await this.getGatewayContractAddress(asset));
            }
            catch (error) {
                if (/(Empty address returned)|(Asset not supported on mint-chain)/.exec(String((error || {}).message))) {
                    // Ignore
                }
                else {
                    console.warn(error);
                }
                return false;
            }
        };
        /**
         * `assetDecimals` should return the number of decimals of the asset.
         *
         * If the asset is not supported, an error should be thrown.
         *
         
         */
        this.assetDecimals = (asset) => {
            if (asset === "ETH") {
                return 18;
            }
            throw new Error(`Unsupported asset ${asset}.`);
        };
        this.transactionID = (transaction) => {
            return transaction || "";
        };
        this.transactionFromID = (txid, _txindex) => Ox(txid);
        this.transactionConfidence = async (transaction) => {
            if (!this.web3 || !this.renNetworkDetails) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            if (transaction === null) {
                throw new Error(`Unable to fetch transaction confidence, transaction hash: ${transaction}`);
            }
            const currentBlock = new BigNumber((await this.web3.eth.getBlockNumber()).toString());
            const receipt = await this.web3.eth.getTransactionReceipt(transaction);
            let current = 0;
            if (receipt.blockNumber) {
                const transactionBlock = new BigNumber(receipt.blockNumber.toString());
                current = currentBlock.minus(transactionBlock).plus(1).toNumber();
            }
            return {
                current,
                target: this.renNetworkDetails.isTestnet ? 15 : 30,
            };
        };
        this.submitMint = async (asset, contractCalls, mintTx, eventEmitter) => {
            if (!mintTx.out) {
                throw new Error(`No signature passed to mint submission.`);
            }
            if (mintTx.out.revert !== undefined) {
                throw new Error(`Unable to submit reverted RenVM transaction.`);
            }
            if (!this.web3) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const existingTransaction = await this.findTransaction(asset, mintTx.out.nhash, mintTx.out.sighash);
            if (existingTransaction) {
                await manualPromiEvent(this.web3, existingTransaction, eventEmitter);
                return existingTransaction;
            }
            return await submitToEthereum(this.web3, contractCalls, mintTx, eventEmitter);
        };
        this.findTransaction = async (asset, nHash, sigHash) => {
            if (!this.renNetworkDetails || !this.web3) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return findTransactionBySigHash(this.renNetworkDetails, this.web3, asset, nHash, sigHash, this.logRequestLimit);
        };
        this.resolveTokenGatewayContract = async (asset) => {
            if (!this.renNetworkDetails || !this.web3) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            return Ox(await getTokenAddress(this.renNetworkDetails, this.web3, asset));
        };
        /**
         * Read a burn reference from an Ethereum transaction - or submit a
         * transaction first if the transaction details have been provided.
         */
        this.findBurnTransaction = async (asset, 
        // Once of the following should not be undefined.
        burn, eventEmitter, logger, timeout) => {
            if (!this.renNetworkDetails || !this.web3) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const { burnNonce, contractCalls } = burn;
            let { transaction } = burn;
            if (!transaction && burnNonce) {
                return findBurnByNonce(this.renNetworkDetails, this.web3, asset, burnNonce.toString());
            }
            // There are three parameter configs:
            // Situation (1): A `burnNonce` is provided
            // Situation (2): Contract call details are provided
            // Situation (3): A transaction is provided
            // Handle situation (2)
            // Make a call to the provided contract and Pass on the
            // transaction hash.
            if (!transaction && contractCalls) {
                for (let i = 0; i < contractCalls.length; i++) {
                    const contractCall = contractCalls[i];
                    const last = i === contractCalls.length - 1;
                    const { contractParams, contractFn, sendTo } = contractCall;
                    const callParams = [
                        ...(contractParams || []).map((value) => value.value),
                    ];
                    const ABI = payloadToABI(contractFn, contractParams);
                    const contract = new this.web3.eth.Contract(ABI, sendTo);
                    const txConfig = typeof contractCall === "object"
                        ? contractCall.txConfig
                        : {};
                    const config = await withDefaultAccount(this.web3, {
                        ...txConfig,
                        ...{
                            value: txConfig && txConfig.value
                                ? txConfig.value.toString()
                                : undefined,
                            gasPrice: txConfig && txConfig.gasPrice
                                ? txConfig.gasPrice.toString()
                                : undefined,
                        },
                    });
                    logger.debug("Calling Ethereum contract", contractFn, sendTo, ...callParams, config);
                    const tx = contract.methods[contractFn](...callParams).send(config);
                    if (last) {
                        forwardWeb3Events(tx, eventEmitter);
                    }
                    transaction = await new Promise((resolve, reject) => tx.on("transactionHash", resolve).catch((error) => {
                        try {
                            if (ignorePromiEventError(error)) {
                                logger.error(extractError(error));
                                return;
                            }
                        }
                        catch (_error) {
                            /* Ignore _error */
                        }
                        reject(error);
                    }));
                    logger.debug("Transaction hash", transaction);
                }
            }
            if (!transaction) {
                throw new Error(`Unable to find burn from provided parameters.`);
            }
            return extractBurnDetails(this.web3, transaction, logger, timeout);
        };
        this.getFees = async (asset) => {
            if (!this.web3) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const gatewayAddress = await this.getGatewayContractAddress(asset);
            const mintFeeABI = {
                constant: true,
                inputs: [],
                name: "mintFee",
                outputs: [
                    {
                        internalType: "uint16",
                        name: "",
                        type: "uint16",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const burnFeeABI = {
                constant: true,
                inputs: [],
                name: "burnFee",
                outputs: [
                    {
                        internalType: "uint16",
                        name: "",
                        type: "uint16",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            const gatewayContract = new this.web3.eth.Contract([mintFeeABI, burnFeeABI], gatewayAddress);
            const mintFee = await gatewayContract.methods.mintFee().call();
            const burnFee = await gatewayContract.methods.burnFee().call();
            return {
                mint: new BigNumber(mintFee.toString()).toNumber(),
                burn: new BigNumber(burnFee.toString()).toNumber(),
            };
        };
        this.getBalance = async (asset, address) => {
            const balanceOfABI = {
                constant: true,
                inputs: [
                    {
                        internalType: "address",
                        name: "account",
                        type: "address",
                    },
                ],
                name: "balanceOf",
                outputs: [
                    {
                        internalType: "uint256",
                        name: "",
                        type: "uint256",
                    },
                ],
                payable: false,
                stateMutability: "view",
                type: "function",
            };
            if (!this.web3) {
                throw new Error(`${this.name} object not initialized - must provide network to constructor.`);
            }
            const tokenAddress = await this.getTokenContractAddress(asset);
            const tokenContract = new this.web3.eth.Contract([balanceOfABI], tokenAddress);
            const balanceRaw = await await tokenContract.methods
                .balanceOf(address)
                .call();
            return new BigNumber(balanceRaw.toString());
        };
        this.transactionRPCFormat = (transaction, _v2) => {
            assertType("string | null", { transaction });
            if (transaction === null) {
                throw new Error(`Unable to encode transaction, transaction hash: ${transaction}`);
            }
            return {
                txid: fromHex(transaction),
                txindex: "0",
            };
        };
        this.web3 = new Web3(web3Provider);
        if (renNetwork) {
            this.renNetworkDetails = resolveNetwork(renNetwork);
        }
    }
}
EthereumBaseChain.chain = "Ethereum";
EthereumBaseChain.utils = {
    resolveChainNetwork: resolveNetwork,
    addressIsValid,
    addressExplorerLink: (address, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||
        renMainnet).etherscan}/address/${address}`,
    transactionExplorerLink: (transaction, network) => `${(EthereumBaseChain.utils.resolveChainNetwork(network) ||
        renMainnet).etherscan}/tx/${transaction}`,
};
const _ = EthereumBaseChain;
//# sourceMappingURL=base.js.map