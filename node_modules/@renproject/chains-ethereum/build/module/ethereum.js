import { Callable, Ox } from "@renproject/utils";
import BigNumber from "bignumber.js";
import { EthereumBaseChain } from "./base";
export class EthereumClass extends EthereumBaseChain {
    constructor(web3Provider, renNetwork) {
        super(web3Provider, renNetwork);
        this.getMintParams = (asset) => this._getParams ? this._getParams(asset) : undefined;
        this.getBurnParams = (asset, burnPayload) => this._getParams ? this._getParams(asset, burnPayload) : undefined;
        /** @category Main */
        this.Address = (address, txConfig) => this.Account({ address }, txConfig);
        /** @category Main */
        this.Account = ({ value, address, }, txConfig) => {
            this._getParams = async (asset, burnPayload) => {
                if (!this.renNetworkDetails || !this.web3) {
                    throw new Error(`Ethereum must be initialized before calling 'getContractCalls'.`);
                }
                if (!value) {
                    // Mint
                    if (!address) {
                        throw new Error(`Must provide Ethereum recipient address.`);
                    }
                    // Resolve .ens name
                    if (/.*\.ens/.exec(address)) {
                        address = await this.web3.eth.ens.getAddress(address);
                    }
                    return {
                        contractCalls: [
                            {
                                sendTo: this.renNetworkDetails.addresses
                                    .BasicAdapter,
                                contractFn: "mint",
                                contractParams: [
                                    {
                                        type: "string",
                                        name: "_symbol",
                                        value: asset,
                                    },
                                    {
                                        type: "address",
                                        name: "_address",
                                        value: address,
                                    },
                                ],
                                txConfig,
                            },
                        ],
                    };
                }
                else {
                    // Burn
                    if (!value) {
                        throw new Error(`Send amount must be provided in order to send directly to an address.`);
                    }
                    if (!burnPayload) {
                        throw new Error(`Must provide burn recipient address`);
                    }
                    const addressToBuffer = Buffer.from(burnPayload);
                    const gateway = await this.getGatewayContractAddress(asset);
                    return {
                        contractCalls: [
                            {
                                sendTo: gateway,
                                contractFn: "burn",
                                contractParams: [
                                    {
                                        type: "bytes",
                                        name: "_to",
                                        value: Ox(addressToBuffer),
                                    },
                                    {
                                        type: "uint256",
                                        name: "_amount",
                                        value: new BigNumber(value).toFixed(),
                                    },
                                ],
                                txConfig,
                            },
                        ],
                    };
                }
            };
            return this;
        };
        /** @category Main */
        this.Contract = (contractCall) => {
            this._getParams = (asset, burnPayload) => {
                if (!this.renNetworkDetails) {
                    throw new Error(`Ethereum must be initialized before calling 'getContractCalls'`);
                }
                if (typeof contractCall === "function") {
                    if (!burnPayload) {
                        throw new Error(`Must provide burn payload`);
                    }
                    const addressToBuffer = Buffer.from(burnPayload);
                    return {
                        contractCalls: [contractCall(Ox(addressToBuffer), asset)],
                    };
                }
                else {
                    return { contractCalls: [contractCall] };
                }
            };
            return this;
        };
        /** @category Main */
        this.Transaction = (transaction) => {
            this._getParams = (_asset, _burnPayload) => {
                return {
                    transaction,
                };
            };
            return this;
        };
        /** @category Main */
        this.BurnNonce = (burnNonce) => {
            this._getParams = (_asset, _burnPayload) => {
                return {
                    burnNonce,
                };
            };
            return this;
        };
        this.toWei = (value) => new BigNumber(value)
            .times(new BigNumber(10).exponentiatedBy(18))
            .decimalPlaces(0)
            .toFixed();
        this.fromWei = (value) => new BigNumber(value)
            .dividedBy(new BigNumber(10).exponentiatedBy(18))
            .toFixed();
    }
}
// @dev Removes any static fields, except `utils`.
export const Ethereum = Callable(EthereumClass);
//# sourceMappingURL=ethereum.js.map