/// <reference types="node" />
import { BurnDetails, ContractCall, LockAndMintTransaction, Logger, MintChain, RenNetwork, RenNetworkDetails, RenNetworkString } from "@renproject/interfaces";
import BigNumber from "bignumber.js";
import { EventEmitter } from "events";
import Web3 from "web3";
import { provider } from "web3-providers";
import { EthereumConfig } from "./networks";
export declare const EthereumConfigMap: {
    mainnet: EthereumConfig;
    testnet: EthereumConfig;
    "mainnet-v0.3": EthereumConfig;
    "testnet-v0.3": EthereumConfig;
    "devnet-v0.3": EthereumConfig;
};
export declare type EthTransaction = string | null;
export declare type EthAddress = string;
export declare type NetworkInput = RenNetwork | RenNetworkString | RenNetworkDetails | EthereumConfig;
export declare class EthereumBaseChain implements MintChain<EthTransaction, EthAddress, EthereumConfig> {
    static chain: string;
    chain: string;
    name: string;
    legacyName: MintChain["legacyName"];
    logRequestLimit: number | undefined;
    static utils: {
        resolveChainNetwork: (renNetwork?: RenNetworkDetails | RenNetwork | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | EthereumConfig | undefined) => EthereumConfig;
        addressIsValid: (address: string) => boolean;
        addressExplorerLink: (address: EthAddress, network?: RenNetworkDetails | RenNetwork | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | EthereumConfig | undefined) => string;
        transactionExplorerLink: (transaction: EthTransaction, network?: RenNetworkDetails | RenNetwork | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | EthereumConfig | undefined) => string;
    };
    utils: {
        resolveChainNetwork: (renNetwork?: RenNetworkDetails | RenNetwork | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | EthereumConfig | undefined) => EthereumConfig;
        addressIsValid: (address: string) => boolean;
        addressExplorerLink: (address: EthAddress, network?: RenNetworkDetails | RenNetwork | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | EthereumConfig | undefined) => string;
        transactionExplorerLink: (transaction: EthTransaction, network?: RenNetworkDetails | RenNetwork | "mainnet" | "testnet" | "mainnet-v0.3" | "testnet-v0.3" | "devnet-v0.3" | EthereumConfig | undefined) => string;
    } & {
        addressIsValid: (address: string, network?: "mainnet" | "testnet" | EthereumConfig | undefined) => boolean;
        addressExplorerLink: ((address: any, network?: "mainnet" | "testnet" | EthereumConfig | undefined) => string | undefined) | undefined;
        transactionExplorerLink: ((tx: any, network?: "mainnet" | "testnet" | EthereumConfig | undefined) => string | undefined) | undefined;
    };
    web3: Web3 | undefined;
    renNetworkDetails: EthereumConfig | undefined;
    readonly getTokenContractAddress: (asset: string) => Promise<string>;
    readonly getGatewayContractAddress: (token: string) => Promise<string>;
    constructor(web3Provider: provider, renNetwork?: RenNetwork | RenNetworkString | RenNetworkDetails | EthereumConfig);
    withProvider: (web3Provider: provider) => this;
    /**
     * See [LockChain.initialize].
     */
    initialize: (renNetwork: RenNetwork | RenNetworkString | RenNetworkDetails) => this;
    assetIsNative: (asset: string) => boolean;
    /**
     * `assetIsSupported` should return true if the asset is native to the
     * MintChain.
     *
     * ```ts
     * ethereum.assetIsSupported = asset => asset === "ETH";
     * ```
     */
    assetIsSupported: (asset: string) => Promise<boolean>;
    /**
     * `assetDecimals` should return the number of decimals of the asset.
     *
     * If the asset is not supported, an error should be thrown.
     *
     
     */
    assetDecimals: (asset: string) => number;
    transactionID: (transaction: EthTransaction) => string;
    transactionFromID: (txid: string | Buffer, _txindex: string) => string;
    transactionConfidence: (transaction: EthTransaction) => Promise<{
        current: number;
        target: number;
    }>;
    submitMint: (asset: string, contractCalls: ContractCall[], mintTx: LockAndMintTransaction, eventEmitter: EventEmitter) => Promise<EthTransaction>;
    findTransaction: (asset: string, nHash: Buffer, sigHash?: Buffer | undefined) => Promise<EthTransaction | undefined>;
    resolveTokenGatewayContract: (asset: string) => Promise<string>;
    /**
     * Read a burn reference from an Ethereum transaction - or submit a
     * transaction first if the transaction details have been provided.
     */
    findBurnTransaction: (asset: string, burn: {
        transaction?: EthTransaction;
        burnNonce?: Buffer | string | number;
        contractCalls?: ContractCall[];
    }, eventEmitter: EventEmitter, logger: Logger, timeout?: number | undefined) => Promise<BurnDetails<EthTransaction>>;
    getFees: (asset: string) => Promise<{
        burn: number;
        mint: number;
    }>;
    getBalance: (asset: string, address?: string | undefined) => Promise<BigNumber>;
    transactionRPCFormat: (transaction: EthTransaction, _v2?: boolean | undefined) => {
        txid: Buffer;
        txindex: string;
    };
}
