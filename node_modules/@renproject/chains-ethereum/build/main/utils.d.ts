/// <reference types="node" />
import { BurnDetails, ContractCall, LockAndMintTransaction, Logger, PromiEvent } from "@renproject/interfaces";
import { EventEmitter } from "events";
import Web3 from "web3";
import { Log, TransactionConfig, TransactionReceipt } from "web3-core";
import { EthAddress, EthTransaction } from "./base";
import { EthereumConfig } from "./networks";
export declare type Web3Events = {
    transactionHash: [string];
    receipt: [TransactionReceipt];
    confirmation: [number, TransactionReceipt];
    error: [Error];
};
export declare type RenWeb3Events = {
    eth_transactionHash: [string];
    eth_receipt: [TransactionReceipt];
    eth_confirmation: [number, TransactionReceipt];
    error: [Error];
};
export declare const ignorePromiEventError: (error: Error) => boolean;
/**
 * Forward the events emitted by a Web3 PromiEvent to another PromiEvent.
 */
export declare const forwardWeb3Events: <T, TEvents extends Web3Events>(src: PromiEvent<T, TEvents>, dest: EventEmitter) => void;
/**
 * eventTopics contains the Ethereum event identifiers (the first log topic) for
 * Gateway contract events.
 */
export declare const eventTopics: {
    /**
     * ```js
     * event LogBurn(
     *     bytes _to,
     *     uint256 _amount,
     *     uint256 indexed _n,
     *     bytes indexed _indexedTo
     *  );
     * ```
     */
    LogBurn: string;
    /**
     * ```js
     * event LogMint(
     *     address indexed _to,
     *     uint256 _amount,
     *     uint256 indexed _n,
     *     bytes32 indexed _signedMessageHash
     * );
     * ```
     */
    LogMint: string;
};
/**
 * Waits for the receipt of a transaction to be available, retrying every 3
 * seconds until it is.
 *
 * @param web3 A web3 instance.
 * @param txHash The hash of the transaction being read.
 */
export declare const waitForReceipt: (web3: Web3, txHash: string, logger?: Logger | undefined, timeout?: number | undefined) => Promise<TransactionReceipt>;
export declare const parseBurnEvent: (web3: Web3, event: Log) => BurnDetails<EthTransaction>;
export declare const extractBurnDetails: (web3: Web3, txHash: string, logger?: Logger | undefined, timeout?: number | undefined) => Promise<BurnDetails<EthTransaction>>;
export declare const getGatewayAddress: (network: EthereumConfig, web3: Web3, asset: string) => Promise<string>;
export declare const findBurnByNonce: (network: EthereumConfig, web3: Web3, asset: string, nonce: Buffer | string | number) => Promise<BurnDetails<EthTransaction>>;
export declare const defaultAccountError = "No accounts found in Web3 wallet.";
export declare const withDefaultAccount: (web3: Web3, config: TransactionConfig) => Promise<TransactionConfig>;
/**
 * Bind a promiEvent to an Ethereum transaction hash, sending confirmation
 * events. Web3 may export a similar function, which should be used instead if
 * it exists.
 *
 * @param web3 A Web3 instance for watching for confirmations.
 * @param txHash The Ethereum transaction has as a hex string.
 * @param promiEvent The existing promiEvent to forward events to.
 */
export declare const manualPromiEvent: (web3: Web3, txHash: string, promiEvent: EventEmitter) => Promise<TransactionReceipt>;
export declare const getTokenAddress: (network: EthereumConfig, web3: Web3, asset: string) => Promise<string>;
export declare const findTransactionBySigHash: (network: EthereumConfig, web3: Web3, asset: string, nHash: Buffer, sigHash?: Buffer | undefined, blockLimit?: number | undefined) => Promise<string | undefined>;
export declare const submitToEthereum: (web3: Web3, contractCalls: ContractCall[], mintTx: LockAndMintTransaction, eventEmitter: EventEmitter, logger?: Logger) => Promise<EthTransaction>;
export declare const addressIsValid: (address: EthAddress) => boolean;
