"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
// TODO: Improve typings.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDepositMachine = exports.DepositStates = void 0;
const xstate_1 = require("xstate");
const actions_1 = require("xstate/lib/actions");
const utils_1 = require("@renproject/utils");
const mint_1 = require("../types/mint");
const largest = (x, y) => {
    if (!x) {
        if (y)
            return y;
        return 0;
    }
    if (!y) {
        if (x)
            return x;
        return 0;
    }
    if (x > y)
        return x;
    return y;
};
var DepositStates;
(function (DepositStates) {
    DepositStates["CHECKING_COMPLETION"] = "checkingCompletion";
    /** We are waiting for ren-js to find the deposit */
    DepositStates["RESTORING_DEPOSIT"] = "restoringDeposit";
    /** We couldn't restore this deposit */
    DepositStates["ERROR_RESTORING"] = "errorRestoring";
    /** renjs has found the deposit for the transaction */
    DepositStates["RESTORED_DEPOSIT"] = "restoredDeposit";
    /** we are waiting for the source chain to confirm the transaction */
    DepositStates["CONFIRMING_DEPOSIT"] = "srcSettling";
    /** source chain has confirmed the transaction, submitting to renvm for signature */
    DepositStates["RENVM_SIGNING"] = "srcConfirmed";
    /** renvm has accepted and signed the transaction */
    DepositStates["RENVM_ACCEPTED"] = "accepted";
    /** renvm did not accept the tx */
    DepositStates["ERROR_SIGNING"] = "errorAccepting";
    /** the user is submitting the transaction to mint on the destination chain */
    DepositStates["SUBMITTING_MINT"] = "claiming";
    /** there was an error submitting the tx to the destination chain */
    DepositStates["ERROR_MINTING"] = "errorSubmitting";
    /** We have recieved a txHash for the destination chain */
    DepositStates["MINTING"] = "destInitiated";
    /** user has acknowledged that the transaction is completed, so we can stop listening for further deposits */
    DepositStates["COMPLETED"] = "completed";
    /** user does not want to mint this deposit or the transaction reverted */
    DepositStates["REJECTED"] = "rejected";
})(DepositStates = exports.DepositStates || (exports.DepositStates = {}));
/** Statemachine that tracks individual deposits */
const buildDepositMachine = () => xstate_1.createMachine({
    id: "RenVMDepositTransaction",
    initial: DepositStates.CHECKING_COMPLETION,
    schema: {
        events: xstate_1.createSchema(),
        context: xstate_1.createSchema(),
    },
    states: {
        // Checking if deposit is completed so that we can skip initialization
        checkingCompletion: {
            entry: [xstate_1.send("CHECK")],
            // If we already have completed, no need to listen
            on: {
                CHECK: [
                    {
                        target: "completed",
                        cond: "isCompleted",
                    },
                    { target: "restoringDeposit" },
                ],
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(!state.context.deposit.error ? true : false, "Error must not exist");
                },
            },
        },
        errorRestoring: {
            entry: [actions_1.log((ctx, _) => ctx.deposit.error, "ERROR")],
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.deposit.error ? true : false, "Error must exist");
                },
            },
        },
        restoringDeposit: {
            entry: xstate_1.sendParent((c, _) => ({
                type: "RESTORE",
                data: c.deposit,
            })),
            on: {
                RESTORED: {
                    target: "restoredDeposit",
                    actions: [xstate_1.assign((_, e) => ({ deposit: e.data }))],
                },
                ERROR: {
                    target: "errorRestoring",
                    actions: xstate_1.assign((c, e) => ({
                        deposit: Object.assign(Object.assign({}, c.deposit), { error: e.error }),
                    })),
                },
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(!state.context.deposit.error ? true : false, "Error must not exist");
                },
            },
        },
        // Checking deposit internal state to transition to correct machine state
        restoredDeposit: {
            // Parent must send restored
            entry: [xstate_1.send("RESTORED")],
            on: {
                RESTORED: [
                    {
                        target: "srcSettling",
                        cond: "isSrcSettling",
                    },
                    {
                        target: "srcConfirmed",
                        cond: "isSrcSettled",
                    },
                    {
                        target: "accepted",
                        cond: "isAccepted",
                    },
                ].reverse(),
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        srcSettling: {
            entry: xstate_1.sendParent((ctx, _) => ({
                type: "SETTLE",
                hash: ctx.deposit.sourceTxHash,
            })),
            on: {
                CONFIRMED: [
                    {
                        target: "srcConfirmed",
                        actions: [
                            xstate_1.assign({
                                deposit: ({ deposit }, evt) => {
                                    if (mint_1.isConfirming(deposit) &&
                                        deposit.sourceTxConfTarget) {
                                        return Object.assign(Object.assign({}, deposit), { sourceTxConfs: largest(deposit.sourceTxConfs, evt.data.sourceTxConfs), sourceTxConfTarget: largest(deposit.sourceTxConfTarget, evt.data
                                                .sourceTxConfTarget) });
                                    }
                                    return deposit;
                                },
                            }),
                            xstate_1.sendParent((ctx, _) => {
                                return {
                                    type: "DEPOSIT_UPDATE",
                                    data: ctx.deposit,
                                };
                            }),
                        ],
                    },
                ],
                CONFIRMATION: [
                    {
                        actions: [
                            xstate_1.sendParent((ctx, evt) => ({
                                type: "DEPOSIT_UPDATE",
                                data: Object.assign(Object.assign({}, ctx.deposit), evt.data),
                            })),
                            xstate_1.assign({
                                deposit: (context, evt) => {
                                    var _a, _b;
                                    return (Object.assign(Object.assign({}, context.deposit), { sourceTxConfs: ((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxConfs) || 0, sourceTxConfTarget: (_b = evt.data) === null || _b === void 0 ? void 0 : _b.sourceTxConfTarget }));
                                },
                            }),
                        ],
                    },
                ],
                ERROR: [
                    {
                        actions: [
                            xstate_1.assign({
                                deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                            }),
                            actions_1.log((ctx, _) => ctx.deposit.error, "ERROR"),
                        ],
                    },
                ],
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        srcConfirmed: {
            entry: xstate_1.sendParent((ctx, _) => ({
                type: "SIGN",
                hash: ctx.deposit.sourceTxHash,
            })),
            on: {
                SIGN_ERROR: {
                    target: "errorAccepting",
                    actions: xstate_1.assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                    }),
                },
                REVERTED: {
                    target: "rejected",
                    actions: xstate_1.assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                    }),
                },
                SIGNED: {
                    target: "accepted",
                    actions: xstate_1.assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), evt.data)),
                    }),
                },
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        errorAccepting: {
            entry: [actions_1.log((ctx, _) => ctx.deposit.error, "ERROR")],
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.deposit.error ? true : false, "error must exist");
                },
            },
        },
        accepted: {
            entry: xstate_1.sendParent((ctx, _) => {
                return {
                    type: "CLAIMABLE",
                    data: ctx.deposit,
                };
            }),
            on: {
                CLAIM: {
                    target: "claiming",
                    actions: xstate_1.assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { contractParams: evt.params })),
                    }),
                },
                REJECT: "rejected",
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        errorSubmitting: {
            entry: [
                actions_1.log((ctx, _) => ctx.deposit.error, "ERROR"),
                xstate_1.sendParent((ctx, _) => {
                    return {
                        type: "CLAIMABLE",
                        data: ctx.deposit,
                    };
                }),
            ],
            on: {
                CLAIM: {
                    target: "claiming",
                    actions: xstate_1.assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { contractParams: evt.data })),
                    }),
                },
                REJECT: "rejected",
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.deposit.error ? true : false, "error must exist");
                },
            },
        },
        claiming: {
            entry: xstate_1.sendParent((ctx) => ({
                type: "MINT",
                hash: ctx.deposit.sourceTxHash,
                data: mint_1.isSubmitted(ctx.deposit) &&
                    ctx.deposit.contractParams,
            })),
            on: {
                SUBMIT_ERROR: [
                    {
                        target: "errorSubmitting",
                        actions: [
                            xstate_1.assign({
                                deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                            }),
                            xstate_1.sendParent((ctx, _) => ({
                                type: "DEPOSIT_UPDATE",
                                data: ctx.deposit,
                            })),
                        ],
                    },
                ],
                SUBMITTED: [
                    {
                        target: "destInitiated",
                        actions: [
                            xstate_1.assign({
                                deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), evt.data)),
                            }),
                            xstate_1.sendParent((ctx, _) => ({
                                type: "DEPOSIT_UPDATE",
                                data: ctx.deposit,
                            })),
                        ],
                    },
                ],
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        destInitiated: {
            on: {
                ACKNOWLEDGE: {
                    target: "completed",
                    actions: [
                        xstate_1.assign({
                            deposit: (ctx, _) => (Object.assign(Object.assign({}, ctx.deposit), { completedAt: new Date().getTime() })),
                        }),
                    ],
                },
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        rejected: {
            entry: [
                xstate_1.sendParent((ctx, _) => {
                    return {
                        type: "DEPOSIT_UPDATE",
                        data: ctx.deposit,
                    };
                }),
            ],
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        completed: {
            entry: [
                xstate_1.sendParent((ctx, _) => ({
                    type: "DEPOSIT_COMPLETED",
                    data: ctx.deposit,
                })),
                xstate_1.sendParent((ctx, _) => ({
                    type: "DEPOSIT_UPDATE",
                    data: ctx.deposit,
                })),
            ],
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.deposit.completedAt
                        ? true
                        : false, "Must have completedAt timestamp");
                },
            },
        },
    },
}, {
    guards: {
        isSrcSettling: ({ deposit }) => mint_1.isConfirming(deposit) &&
            (deposit.sourceTxConfs || 0) <
                (deposit.sourceTxConfTarget ||
                    Number.POSITIVE_INFINITY),
        isSrcSettled: ({ deposit }) => mint_1.isConfirming(deposit) &&
            (deposit.sourceTxConfs || 0) >= deposit.sourceTxConfTarget,
        isAccepted: ({ deposit }) => mint_1.isAccepted(deposit) && deposit.renSignature ? true : false,
        isDestInitiated: ({ deposit }) => mint_1.isMinted(deposit) && deposit.destTxHash ? true : false,
        isCompleted: ({ deposit }) => mint_1.isCompleted(deposit) && deposit.completedAt ? true : false,
    },
});
exports.buildDepositMachine = buildDepositMachine;
//# sourceMappingURL=deposit.js.map