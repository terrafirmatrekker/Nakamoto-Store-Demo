"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildMintMachine = exports.buildMintContextWithMap = exports.GatewayStates = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const xstate_1 = require("xstate");
const utils_1 = require("@renproject/utils");
const actions_1 = require("xstate/lib/actions");
const mint_1 = require("../types/mint");
var GatewayStates;
(function (GatewayStates) {
    GatewayStates["RESTORING"] = "restoring";
    GatewayStates["CREATING"] = "creating";
    GatewayStates["ERROR_CREATING"] = "srcInitializeError";
    GatewayStates["LISTENING"] = "listening";
    GatewayStates["COMPLETED"] = "completed";
})(GatewayStates = exports.GatewayStates || (exports.GatewayStates = {}));
const buildMintContextWithMap = (params) => {
    const from = params.fromChainMap[params.tx.sourceChain];
    const to = params.toChainMap[params.tx.destChain];
    const constructed = {
        tx: params.tx,
        to,
        sdk: params.sdk,
        from,
    };
    return constructed;
};
exports.buildMintContextWithMap = buildMintContextWithMap;
/**
 * An Xstate machine that, when given a serializable [[GatewaySession]] tx,
 * will instantiate a RenJS LockAndMint session, provide a gateway address,
 * listen for deposits, and request a signature once a deposit has reached
 * the appropriate number of confirmations.
 *
 * Given the same [[GatewaySession]] parameters, as long as the tx has not
 * expired, the machine will restore the transaction to the appropriate
 * state and enable the completion of in-progress minting transactions.
 *
 * The machine allows for multiple deposits to be detected; it is up to the
 * developer to decide if a detected deposit should be signed or rejected.
 * See `/demos/simpleMint.ts` for example usage.
 */
const buildMintMachine = () => xstate_1.createMachine({
    id: "RenVMGatewaySession",
    initial: "restoring",
    states: {
        restoring: {
            entry: [
                xstate_1.send("RESTORE"),
                xstate_1.assign({
                    mintRequests: (_c, _e) => [],
                    depositMachines: (_ctx, _evt) => ({}),
                }),
            ],
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
            on: {
                RESTORE: [
                    {
                        target: "completed",
                        cond: "isExpired",
                    },
                    {
                        target: "listening",
                        cond: "isCreated",
                    },
                    {
                        target: "creating",
                    },
                ],
            },
        },
        creating: {
            meta: {
                test: (_, state) => {
                    utils_1.assert(!state.context.tx.gatewayAddress ? true : false, "Gateway address should not be initialized");
                },
            },
            invoke: {
                src: "txCreator",
                onDone: {
                    target: "listening",
                    actions: xstate_1.assign({
                        tx: (_context, evt) => (Object.assign({}, evt.data)),
                    }),
                },
                onError: {
                    target: "srcInitializeError",
                    actions: [
                        xstate_1.assign({
                            tx: (context, evt) => {
                                const newTx = Object.assign(Object.assign({}, context.tx), { error: evt.data || true });
                                return newTx;
                            },
                        }),
                        actions_1.log((_ctx, evt) => evt.data, "ERROR"),
                    ],
                },
            },
        },
        srcInitializeError: {
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.error ? true : false, "Error must exist");
                },
            },
        },
        listening: {
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.gatewayAddress ? true : false, "GatewayAddress must exist");
                },
            },
            invoke: {
                src: "depositListener",
            },
            on: {
                EXPIRED: "completed",
                // once we have ren-js listening for deposits,
                // start the statemachines to determine deposit states
                LISTENING: { actions: "depositMachineSpawner" },
                ERROR_LISTENING: {
                    target: "srcInitializeError",
                    actions: [
                        xstate_1.assign({
                            tx: (context, evt) => {
                                const newTx = Object.assign(Object.assign({}, context.tx), { error: evt.data || true });
                                return newTx;
                            },
                        }),
                        actions_1.log((_ctx, evt) => evt.data, "ERROR"),
                    ],
                },
                // forward messages from child machines to renjs listeners
                RESTORE: [
                    {
                        cond: "isPersistedDeposit",
                        actions: "forwardEvent",
                    },
                    {
                        actions: [
                            xstate_1.assign({
                                tx: ({ tx }, e) => {
                                    if (!e.data.sourceTxHash)
                                        return tx;
                                    return Object.assign(Object.assign({}, tx), { transactions: Object.assign(Object.assign({}, tx.transactions), { [e.data.sourceTxHash]: e.data }) });
                                },
                            }),
                            "spawnDepositMachine",
                            "forwardEvent",
                        ],
                    },
                ],
                SETTLE: {
                    actions: "forwardEvent",
                },
                SIGN: {
                    actions: "forwardEvent",
                },
                MINT: {
                    actions: "forwardEvent",
                },
                // Send messages to child machines
                RESTORED: {
                    actions: "routeEvent",
                },
                CLAIM: { actions: "routeEvent" },
                CONFIRMATION: { actions: "routeEvent" },
                CONFIRMED: { actions: "routeEvent" },
                ERROR: { actions: "routeEvent" },
                SIGN_ERROR: { actions: "routeEvent" },
                REVERTED: { actions: "routeEvent" },
                SUBMIT_ERROR: { actions: "routeEvent" },
                SIGNED: { actions: "routeEvent" },
                SUBMITTED: { actions: "routeEvent" },
                ACKNOWLEDGE: { actions: "routeEvent" },
                CLAIMABLE: {
                    actions: xstate_1.assign({
                        mintRequests: (context, evt) => {
                            var _a;
                            const oldRequests = context.mintRequests || [];
                            const newRequest = (_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxHash;
                            if (!newRequest) {
                                return oldRequests;
                            }
                            if (oldRequests.includes(newRequest)) {
                                return oldRequests;
                            }
                            return [...oldRequests, newRequest];
                        },
                        tx: (context, evt) => {
                            if (evt.data.sourceTxHash) {
                                context.tx.transactions[evt.data.sourceTxHash] = evt.data;
                            }
                            return context.tx;
                        },
                    }),
                },
                // We only complete when expiring
                // DEPOSIT_COMPLETED: {
                //     target: "completed",
                //     cond: "isCompleted",
                // },
                DEPOSIT_UPDATE: [
                    {
                        actions: [
                            xstate_1.assign({
                                mintRequests: (ctx, evt) => {
                                    var _a;
                                    // check if completed
                                    if (mint_1.isMinted(evt.data)) {
                                        return (((_a = ctx.mintRequests) === null || _a === void 0 ? void 0 : _a.filter((x) => x !==
                                            evt.data
                                                .sourceTxHash)) || []);
                                    }
                                    else {
                                        return ctx.mintRequests;
                                    }
                                },
                                tx: (context, evt) => {
                                    if (evt.data.sourceTxHash) {
                                        context.tx.transactions[evt.data.sourceTxHash] = evt.data;
                                    }
                                    return context.tx;
                                },
                            }),
                            xstate_1.send((_, evt) => {
                                return {
                                    type: "UPDATE",
                                    hash: evt.data.sourceTxHash,
                                    data: evt.data,
                                };
                            }, {
                                to: (_ctx) => "depositListener",
                            }),
                        ],
                    },
                ],
                DEPOSIT: {
                    cond: "isNewDeposit",
                    actions: [
                        xstate_1.assign({
                            tx: (context, evt) => {
                                // Replace the transaction with the newly
                                // detected one; the listener will provide
                                // persisted data if it is already present
                                return Object.assign(Object.assign({}, context.tx), { transactions: Object.assign(Object.assign({}, context.tx.transactions), { [evt.data.sourceTxHash]: evt.data }) });
                            },
                        }),
                        "spawnDepositMachine",
                    ],
                },
            },
        },
        completed: {
            meta: {
                test: (_, state) => {
                    if (state.context.depositListenerRef) {
                        throw Error("Deposit listener has not been cleaned up");
                    }
                },
            },
        },
    },
}, {
    guards: {
        isPersistedDeposit: (ctx, evt) => {
            const depositEvt = evt;
            if (!depositEvt.data)
                return false;
            return (ctx.tx.transactions || {})[depositEvt.data.sourceTxHash]
                ? true
                : false;
        },
        isNewDeposit: (ctx, evt) => {
            const depositEvt = evt;
            if (!depositEvt.data)
                return false;
            return !(ctx.depositMachines || {})[depositEvt.data.sourceTxHash];
        },
        isExpired: ({ tx }) => tx.expiryTime < new Date().getTime(),
        isCreated: ({ tx }) => mint_1.isOpen(tx),
    },
});
exports.buildMintMachine = buildMintMachine;
//# sourceMappingURL=mint.js.map