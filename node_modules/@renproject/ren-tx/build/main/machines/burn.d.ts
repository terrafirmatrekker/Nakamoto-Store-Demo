import { Actor } from "xstate";
import RenJS from "@renproject/ren";
import { LockChain, MintChain } from "@renproject/interfaces";
import { BurnSession, BurnTransaction, CompletedBurnTransaction, ConfirmedBurnTransaction, ErroringBurnSession, ReleasedBurnTransaction } from "../types/burn";
import { LockChainMap, MintChainMap } from "./mint";
export interface BurnMachineContext<BurnType, ReleaseType> {
    /**
     * The TX to be processed
     */
    tx: BurnSession<BurnType, ReleaseType> | ErroringBurnSession<BurnType>;
    sdk: RenJS;
    /**
     * Automatically request burn submission to the host chain provider
     * (eg. will prompt web3 tx dialog after starting machine)
     */
    autoSubmit?: boolean;
    /**
     * Function to create the "from" param;
     */
    from: (context: BurnMachineContext<BurnType, ReleaseType>) => MintChain<BurnType>;
    /**
     * Function to create the "to" RenJS param;
     */
    to: (context: BurnMachineContext<BurnType, ReleaseType>) => LockChain<ReleaseType>;
    /**
     * @private
     * Tracks the RenJS BurnAndRelease callback
     */
    burnListenerRef?: Actor<any>;
}
export declare enum BurnStates {
    /** Tx is resolving which state it should be in based on feedback from renjs */
    RESTORE = "restoring",
    /** Tx is being initialized by renjs */
    CREATING = "creating",
    /** Tx has been initialized by renjs successfully and is ready to be submitted*/
    CREATED = "created",
    /** Burn has been submitted to host chain */
    SUBMITTING_BURN = "submittingBurn",
    /** Source/host chain is awaiting sufficient confirmations */
    CONFIRMING_BURN = "srcSettling",
    /** There was an error encountered while processing the burn tx
     * Could be either from renvm or the host chain */
    ERROR_BURNING = "errorBurning",
    /** Source/host chain has reached sufficient confirmations and tx
     * can be submitted to renVM for release */
    RENVM_RELEASING = "srcConfirmed",
    /** RenVM has recieved the tx and provided a hash */
    RENVM_ACCEPTED = "accepted",
    /** An error occored while processing the release
     * Should only come from renVM */
    ERROR_RELEASING = "errorReleasing",
    /** The release tx has successfully been broadcast
     * For network v0.3+ we get the release destTxHash
     * otherwise it will never be provided
     */
    RELEASED = "destInitiated"
}
export interface BurnMachineSchema {
    states: {
        /** Tx is resolving which state it should be in based on feedback from renjs */
        restoring: {};
        /** Tx is being initialized by renjs */
        creating: {};
        /** Tx has been initialized by renjs successfully and is ready to be submitted*/
        created: {};
        /** Burn has been submitted to host chain */
        submittingBurn: {};
        /** Source/host chain is awaiting sufficient confirmations */
        srcSettling: {};
        /** There was an error encountered while processing the burn tx
         * Could be either from renvm or the host chain */
        errorBurning: {};
        /** Source/host chain has reached sufficient confirmations and tx
         * can be submitted to renVM for release */
        srcConfirmed: {};
        /** RenVM has recieved the tx and provided a hash */
        accepted: {};
        /** An error occored while processing the release
         * Should only come from renVM */
        errorReleasing: {};
        /** The release tx has successfully been broadcast
         * For network v0.3 we get the release destTxHash
         * otherwise it will never be provided
         */
        destInitiated: {};
    };
}
export declare type BurnMachineEvent<X, Y> = {
    type: "NOOP";
} | {
    type: "RETRY";
} | {
    type: "RESTORE";
} | {
    type: "CREATED";
} | {
    type: "SUBMIT";
} | {
    type: "SUBMITTED";
    data: BurnTransaction;
} | {
    type: "RELEASE";
} | {
    type: "RELEASE_ERROR";
    data: Partial<BurnTransaction>;
    error: Error;
} | {
    type: "BURN_ERROR";
    data: Partial<BurnSession<X, Y>>;
    error: Error;
} | {
    type: "CONFIRMATION";
    data: BurnTransaction;
} | {
    type: "CONFIRMED";
    data: BurnTransaction;
} | {
    type: "ACCEPTED";
    data: ConfirmedBurnTransaction<X>;
} | {
    type: "RELEASED";
    data: ReleasedBurnTransaction<X>;
} | {
    type: "COMPLETED";
    data: CompletedBurnTransaction<X, Y>;
};
export declare const buildBurnContextWithMap: <BurnType, ReleaseType>(params: {
    tx: BurnSession<BurnType, ReleaseType, {}>;
    sdk: RenJS;
    /**
     * Functions to create the "to" RenJS param, for each native chain that you
     * want to support
     *
     * Example:
     * ```js
     * cosnt toChainMap = {
     *     bitcoin: (context: GatewayMachineContext) =>
     *         Bitcoin().Address(context.tx.destAddress),
     * }
     * ```
     */
    toChainMap: LockChainMap<BurnMachineContext<BurnType, ReleaseType>>;
    /**
     * Functions to create the "from" RenJS param, for each host chain that you
     * want to support.
     * Example:
     * ```js
     * const fromChainMap = {
     *     ethereum: (context: GatewayMachineContext) => {
     *         const {
     *             destAddress,
     *             sourceChain,
     *             suggestedAmount,
     *             network,
     *         } = context.tx;
     *         const { providers } = context;
     *
     *         return Ethereum(providers[sourceChain], network).Account({
     *             address: destAddress,
     *             value: suggestedAmount,
     *         });
     *     },
     * }
     * ```
     */
    fromChainMap: MintChainMap<BurnMachineContext<BurnType, ReleaseType>>;
}) => BurnMachineContext<any, any>;
/**
 * An Xstate machine that, when given a serializable [[BurnSession]] tx,
 * will instantiate a RenJS BurnAndRelease session, prompt the user to submit a
 * burn transaction (or automatically submit if the `autoSubmit` flag is set),
 * on the host chain, listen for confirmations, and detect the release transaction
 * once the native asset has been released.
 *
 * Given the same [[BurnSession]] parameters, as long as the tx has not
 * expired, the machine will restore the transaction to the appropriate
 * state and enable the completion of in-progress burning transactions, however
 * RenVM will generally automatically complete asset releases once the burn
 * transaction has been submitted to the host chain.
 *
 * See `/demos/simpleBurn.ts` for example usage.
 */
export declare const buildBurnMachine: <BurnType, ReleaseType>() => import("xstate").StateMachine<BurnMachineContext<BurnType, ReleaseType>, BurnMachineSchema, BurnMachineEvent<BurnType, ReleaseType>, {
    value: any;
    context: BurnMachineContext<BurnType, ReleaseType>;
}>;
