"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
// TODO: Improve typings.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildBurnMachine = exports.buildBurnContextWithMap = exports.BurnStates = void 0;
const xstate_1 = require("xstate");
const utils_1 = require("@renproject/utils");
const burn_1 = require("../types/burn");
var BurnStates;
(function (BurnStates) {
    /** Tx is resolving which state it should be in based on feedback from renjs */
    BurnStates["RESTORE"] = "restoring";
    /** Tx is being initialized by renjs */
    BurnStates["CREATING"] = "creating";
    /** Tx has been initialized by renjs successfully and is ready to be submitted*/
    BurnStates["CREATED"] = "created";
    /** Burn has been submitted to host chain */
    BurnStates["SUBMITTING_BURN"] = "submittingBurn";
    /** Source/host chain is awaiting sufficient confirmations */
    BurnStates["CONFIRMING_BURN"] = "srcSettling";
    /** There was an error encountered while processing the burn tx
     * Could be either from renvm or the host chain */
    BurnStates["ERROR_BURNING"] = "errorBurning";
    /** Source/host chain has reached sufficient confirmations and tx
     * can be submitted to renVM for release */
    BurnStates["RENVM_RELEASING"] = "srcConfirmed";
    /** RenVM has recieved the tx and provided a hash */
    BurnStates["RENVM_ACCEPTED"] = "accepted";
    /** An error occored while processing the release
     * Should only come from renVM */
    BurnStates["ERROR_RELEASING"] = "errorReleasing";
    /** The release tx has successfully been broadcast
     * For network v0.3+ we get the release destTxHash
     * otherwise it will never be provided
     */
    BurnStates["RELEASED"] = "destInitiated";
})(BurnStates = exports.BurnStates || (exports.BurnStates = {}));
const buildBurnContextWithMap = (params) => {
    const from = params.fromChainMap[params.tx.sourceChain];
    const to = params.toChainMap[params.tx.destChain];
    const constructed = {
        tx: params.tx,
        to,
        sdk: params.sdk,
        from,
    };
    return constructed;
};
exports.buildBurnContextWithMap = buildBurnContextWithMap;
/**
 * An Xstate machine that, when given a serializable [[BurnSession]] tx,
 * will instantiate a RenJS BurnAndRelease session, prompt the user to submit a
 * burn transaction (or automatically submit if the `autoSubmit` flag is set),
 * on the host chain, listen for confirmations, and detect the release transaction
 * once the native asset has been released.
 *
 * Given the same [[BurnSession]] parameters, as long as the tx has not
 * expired, the machine will restore the transaction to the appropriate
 * state and enable the completion of in-progress burning transactions, however
 * RenVM will generally automatically complete asset releases once the burn
 * transaction has been submitted to the host chain.
 *
 * See `/demos/simpleBurn.ts` for example usage.
 */
const buildBurnMachine = () => xstate_1.Machine({
    id: "RenVMBurnMachine",
    initial: "restoring",
    states: {
        restoring: {
            entry: xstate_1.send("RESTORE"),
            on: {
                RESTORE: [
                    {
                        target: "destInitiated",
                        cond: "isDestInitiated",
                    },
                    // We can't restore to this state, because the machine needs
                    // to be initialized
                    // { target: "srcConfirmed", cond: "isSrcConfirmed" },
                    { target: "srcSettling", cond: "isSrcSettling" },
                    { target: "creating" },
                ],
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        creating: {
            entry: "burnSpawner",
            on: {
                CREATED: "created",
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(!state.context.tx.transaction ? true : false, "Should not have a transaction");
                },
            },
        },
        created: {
            on: {
                // When we fail to submit to the host chain, we don't enter the
                // settling state, so handle the error here
                BURN_ERROR: {
                    target: "errorBurning",
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => evt.data
                            ? Object.assign(Object.assign({}, ctx.tx), { error: evt.data }) : ctx.tx,
                    }),
                },
                SUBMIT: {
                    target: BurnStates.SUBMITTING_BURN,
                    actions: xstate_1.send("SUBMIT", {
                        to: (ctx) => {
                            var _a;
                            return ((_a = ctx.burnListenerRef) === null || _a === void 0 ? void 0 : _a.id) || "";
                        },
                    }),
                },
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(!state.context.tx.transaction ? true : false, "Should not have a transaction");
                },
            },
        },
        errorBurning: {
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.error ? true : false, "Error must exist");
                },
            },
        },
        submittingBurn: {
            on: {
                BURN_ERROR: {
                    target: "errorBurning",
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => evt.data
                            ? Object.assign(Object.assign({}, ctx.tx), { error: evt.error }) : ctx.tx,
                    }),
                },
                SUBMITTED: {
                    actions: [
                        xstate_1.assign({
                            tx: (ctx, evt) => (Object.assign(Object.assign({}, ctx.tx), { transaction: evt.data })),
                        }),
                    ],
                },
                // Wait for a confirmation before entering confirming
                CONFIRMATION: {
                    target: "srcSettling",
                    // update src confs
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => (Object.assign(Object.assign({}, ctx.tx), { transaction: evt.data })),
                    }),
                },
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.error ? false : true, "Error must not exist");
                },
            },
        },
        srcSettling: {
            // spawn in case we aren't creating
            entry: "burnSpawner",
            on: {
                // In case we restored and didn't submit
                SUBMIT: {
                    actions: xstate_1.send("SUBMIT", {
                        to: (ctx) => {
                            var _a;
                            return ((_a = ctx.burnListenerRef) === null || _a === void 0 ? void 0 : _a.id) || "";
                        },
                    }),
                },
                CONFIRMATION: {
                    // update src confs
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => (Object.assign(Object.assign({}, ctx.tx), { transaction: evt.data })),
                    }),
                },
                CONFIRMED: {
                    actions: [
                        xstate_1.assign({
                            tx: (ctx, evt) => (Object.assign(Object.assign({}, ctx.tx), { transaction: evt.data })),
                        }),
                    ],
                    target: "srcConfirmed",
                },
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(Object.keys(state.context.tx.transaction).length
                        ? true
                        : false, "Should have a transaction");
                },
            },
        },
        errorReleasing: {
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.error ? true : false, "Error must exist");
                },
            },
        },
        srcConfirmed: {
            entry: xstate_1.send("RELEASE", {
                to: (ctx) => {
                    var _a;
                    return ((_a = ctx.burnListenerRef) === null || _a === void 0 ? void 0 : _a.id) || "";
                },
            }),
            on: {
                RELEASE_ERROR: {
                    target: "errorReleasing",
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => evt.data
                            ? Object.assign(Object.assign({}, ctx.tx), { error: evt.error }) : ctx.tx,
                    }),
                },
                ACCEPTED: {
                    actions: [
                        xstate_1.assign({
                            tx: (ctx, evt) => (Object.assign(Object.assign({}, ctx.tx), { transaction: evt.data })),
                        }),
                    ],
                    target: "accepted",
                },
            },
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.transaction.sourceTxConfs >=
                        (state.context.tx.transaction
                            .sourceTxConfTarget || 0)
                        ? true
                        : false, "Should have a confirmed transaction");
                },
            },
        },
        accepted: {
            on: {
                RELEASE_ERROR: {
                    target: "errorReleasing",
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => evt.data
                            ? Object.assign(Object.assign({}, ctx.tx), { error: evt.error }) : ctx.tx,
                    }),
                },
                RELEASED: {
                    target: "destInitiated",
                    actions: xstate_1.assign({
                        tx: (ctx, evt) => (Object.assign(Object.assign({}, ctx.tx), { transaction: evt.data })),
                    }),
                },
            },
            meta: { test: () => __awaiter(void 0, void 0, void 0, function* () { }) },
        },
        destInitiated: {
            meta: {
                test: (_, state) => {
                    utils_1.assert(state.context.tx.transaction.renResponse
                        ? true
                        : false, "renResponse must exist");
                },
            },
        },
    },
}, {
    guards: {
        isSrcSettling: (ctx, _evt) => {
            return ctx.tx.transaction && ctx.tx.transaction.sourceTxHash
                ? true
                : false;
        },
        isSrcConfirmed: (ctx, _evt) => !!ctx.tx.transaction &&
            ctx.tx.transaction.sourceTxConfs >=
                (ctx.tx.transaction.sourceTxConfTarget ||
                    Number.POSITIVE_INFINITY),
        // We assume that the renVmHash implies that the dest tx has been initiated
        isDestInitiated: (ctx, _evt) => !!ctx.tx.transaction &&
            burn_1.isReleased(ctx.tx.transaction) &&
            !!ctx.tx.transaction.renResponse,
    },
});
exports.buildBurnMachine = buildBurnMachine;
//# sourceMappingURL=burn.js.map