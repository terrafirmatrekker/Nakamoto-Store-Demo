import { StateSchema } from "xstate";
import { AcceptedGatewayTransaction, AllGatewayTransactions, ConfirmingGatewayTransaction, GatewayTransaction, MintedGatewayTransaction, SubmittingGatewayTransaction } from "../types/mint";
declare type extractGeneric<Type> = Type extends AllGatewayTransactions<infer X> ? X : never;
/** The context that the deposit machine acts on */
export interface DepositMachineContext<Deposit extends AllGatewayTransactions<extractGeneric<Deposit>>> {
    /** The deposit being tracked */
    deposit: Deposit;
}
export declare enum DepositStates {
    CHECKING_COMPLETION = "checkingCompletion",
    /** We are waiting for ren-js to find the deposit */
    RESTORING_DEPOSIT = "restoringDeposit",
    /** We couldn't restore this deposit */
    ERROR_RESTORING = "errorRestoring",
    /** renjs has found the deposit for the transaction */
    RESTORED_DEPOSIT = "restoredDeposit",
    /** we are waiting for the source chain to confirm the transaction */
    CONFIRMING_DEPOSIT = "srcSettling",
    /** source chain has confirmed the transaction, submitting to renvm for signature */
    RENVM_SIGNING = "srcConfirmed",
    /** renvm has accepted and signed the transaction */
    RENVM_ACCEPTED = "accepted",
    /** renvm did not accept the tx */
    ERROR_SIGNING = "errorAccepting",
    /** the user is submitting the transaction to mint on the destination chain */
    SUBMITTING_MINT = "claiming",
    /** there was an error submitting the tx to the destination chain */
    ERROR_MINTING = "errorSubmitting",
    /** We have recieved a txHash for the destination chain */
    MINTING = "destInitiated",
    /** user has acknowledged that the transaction is completed, so we can stop listening for further deposits */
    COMPLETED = "completed",
    /** user does not want to mint this deposit or the transaction reverted */
    REJECTED = "rejected"
}
export declare type DepositMachineTypestate<X> = {
    value: DepositStates.CHECKING_COMPLETION;
    context: DepositMachineContext<AllGatewayTransactions<X>>;
} | {
    value: DepositStates.RESTORING_DEPOSIT;
    context: DepositMachineContext<AllGatewayTransactions<X>>;
} | {
    value: DepositStates.ERROR_RESTORING;
    context: DepositMachineContext<GatewayTransaction<X>>;
} | {
    value: DepositStates.RESTORED_DEPOSIT;
    context: DepositMachineContext<GatewayTransaction<X>>;
} | {
    value: DepositStates.CONFIRMING_DEPOSIT;
    context: DepositMachineContext<ConfirmingGatewayTransaction<X>>;
} | {
    value: DepositStates.RENVM_SIGNING;
    context: DepositMachineContext<AcceptedGatewayTransaction<X>>;
} | {
    value: DepositStates.RENVM_ACCEPTED;
    context: DepositMachineContext<AcceptedGatewayTransaction<X>>;
} | {
    value: DepositStates.ERROR_SIGNING;
    context: DepositMachineContext<ConfirmingGatewayTransaction<X>>;
} | {
    value: DepositStates.SUBMITTING_MINT;
    context: DepositMachineContext<SubmittingGatewayTransaction<X>>;
} | {
    value: DepositStates.ERROR_MINTING;
    context: DepositMachineContext<SubmittingGatewayTransaction<X>>;
} | {
    value: DepositStates.MINTING;
    context: DepositMachineContext<MintedGatewayTransaction<X>>;
} | {
    value: DepositStates.COMPLETED;
    context: DepositMachineContext<MintedGatewayTransaction<X>>;
} | {
    value: DepositStates.REJECTED;
    context: DepositMachineContext<GatewayTransaction<X>>;
};
/** The states a deposit can be in */
export interface DepositMachineSchema<X> extends StateSchema<DepositMachineContext<AllGatewayTransactions<X>>> {
    states: {
        /** check if we can skip instantiating the deposit, if we finished the tx
         * previously  */
        checkingCompletion: {};
        /** We are waiting for ren-js to find the deposit */
        restoringDeposit: {};
        /** We couldn't restore this deposit */
        errorRestoring: {};
        /** renjs has found the deposit for the transaction */
        restoredDeposit: {};
        /** we are waiting for the source chain to confirm the transaction */
        srcSettling: {};
        /** source chain has confirmed the transaction */
        srcConfirmed: {};
        /** renvm has accepted and signed the transaction */
        accepted: {};
        /** renvm did not accept the tx */
        errorAccepting: {};
        /** the user is submitting the transaction to mint on the destination chain */
        claiming: {};
        /** there was an error submitting the tx to the destination chain */
        errorSubmitting: {};
        /** We have recieved a txHash for the destination chain */
        destInitiated: {};
        /** user has acknowledged that the transaction is completed, so we can stop listening for further deposits */
        completed: {};
        /** user does not want to claim this deposit */
        rejected: {};
    };
}
export interface ContractParams {
    [key: string]: any;
}
export declare type DepositMachineEvent<X> = {
    type: "NOOP";
} | {
    type: "CHECK";
} | {
    type: "LISTENING";
} | {
    type: "DETECTED";
} | {
    type: "ERROR";
    data: Partial<GatewayTransaction<X>>;
    error: Error;
} | {
    type: "RESTORE";
    data: Partial<AllGatewayTransactions<X>>;
} | {
    type: "RESTORED";
    data: AllGatewayTransactions<X>;
} | {
    type: "CONFIRMED";
    data: Partial<ConfirmingGatewayTransaction<X>>;
} | {
    type: "CONFIRMATION";
    data: Partial<ConfirmingGatewayTransaction<X>>;
} | {
    type: "SIGNED";
    data: AcceptedGatewayTransaction<X>;
} | {
    type: "SIGN_ERROR";
    data: GatewayTransaction<X>;
    error: Error;
} | {
    type: "REVERTED";
    data: GatewayTransaction<X>;
    error: Error;
} | {
    type: "CLAIM";
    data: AcceptedGatewayTransaction<X>;
    params: ContractParams;
} | {
    type: "REJECT";
} | {
    type: "SUBMITTED";
    data: Partial<SubmittingGatewayTransaction<X>>;
} | {
    type: "SUBMIT_ERROR";
    data: Partial<SubmittingGatewayTransaction<X>>;
    error: Error;
} | {
    type: "ACKNOWLEDGE";
    data: Partial<SubmittingGatewayTransaction<X>>;
};
/** Statemachine that tracks individual deposits */
export declare const buildDepositMachine: <X>() => import("xstate").StateMachine<DepositMachineContext<AllGatewayTransactions<X>>, any, DepositMachineEvent<X>, DepositMachineTypestate<X>>;
export {};
