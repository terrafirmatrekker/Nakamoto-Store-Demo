"use strict";
/* eslint-disable @typescript-eslint/no-explicit-any */
// TODO: Improve typings.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildMintConfig = exports.renLockAndMint = void 0;
const lockAndMint_1 = require("@renproject/ren/build/main/lockAndMint");
const xstate_1 = require("xstate");
const deposit_1 = require("../machines/deposit");
const mint_1 = require("../types/mint");
// Recursively cast all buffers in an object to hex
const hexify = (obj) => {
    if (!obj)
        return;
    const entries = Object.entries(obj);
    for (const [k, v] of entries) {
        if (Buffer.isBuffer(v)) {
            obj[k] = v.toString("hex");
        }
    }
    return obj;
};
// Create a LockAndMint instance from a RenTX context
const renLockAndMint = (context) => __awaiter(void 0, void 0, void 0, function* () {
    const { nonce, sourceAsset } = context.tx;
    const { sdk, to, from } = context;
    const mint = yield sdk.lockAndMint({
        asset: sourceAsset.toUpperCase(),
        from: from(context),
        to: to(context),
        nonce,
    });
    return mint;
});
exports.renLockAndMint = renLockAndMint;
// FIXME: These should exist at the RenJS level (gateway validity estimate)
const getSessionDay = () => Math.floor(Date.now() / 1000 / 60 / 60 / 24);
// const getSessionExpiry = () => (getSessionDay() + 3) * 60 * 60 * 24 * 1000;
// Format a transaction and get the gateway address
const txCreator = (context) => __awaiter(void 0, void 0, void 0, function* () {
    // If no nonce is provided, mock the behavior of a new gateway every day
    if (!context.tx.nonce) {
        const nonce = getSessionDay();
        context.tx.nonce = Buffer.from(nonce.toString(16).padStart(32)).toString("hex");
    }
    const minter = yield exports.renLockAndMint(context);
    const gatewayAddress = minter === null || minter === void 0 ? void 0 : minter.gatewayAddress;
    const newTx = Object.assign(Object.assign({}, context.tx), { gatewayAddress });
    return newTx;
});
const initMinter = (context, callback) => __awaiter(void 0, void 0, void 0, function* () {
    const minter = yield exports.renLockAndMint(context);
    if (mint_1.isOpen(context.tx) &&
        minter.gatewayAddress != context.tx.gatewayAddress) {
        callback({
            type: "ERROR_LISTENING",
            data: new Error(`Incorrect gateway address ${String(minter.gatewayAddress)} != ${context.tx.gatewayAddress}`),
        });
    }
    return minter;
});
const handleSettle = (sourceTxHash, deposit, callback) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const res = yield deposit
            .confirmed()
            .on("target", (targetConfs) => {
            const confirmedTx = {
                sourceTxHash,
                sourceTxConfs: 0,
                sourceTxConfTarget: targetConfs,
            };
            callback({
                type: "CONFIRMATION",
                data: confirmedTx,
            });
        })
            .on("confirmation", (confs, targetConfs) => {
            const confirmedTx = {
                sourceTxHash,
                sourceTxConfs: confs,
                sourceTxConfTarget: targetConfs,
            };
            callback({
                type: "CONFIRMATION",
                data: confirmedTx,
            });
        });
        callback({
            type: "CONFIRMED",
            data: {
                sourceTxConfTarget: res._state.targetConfirmations,
                sourceTxConfs: res._state.targetConfirmations,
                sourceTxHash,
            },
        });
    }
    catch (e) {
        callback({
            type: "ERROR",
            data: {
                sourceTxHash,
            },
            error: e,
        });
    }
});
// Handle signing on RenVM
const handleSign = (tx, deposit, callback) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        const v = yield deposit.signed();
        // TODO: handle status? .on("status", (state) => {});
        if (!v._state.queryTxResult || !v._state.queryTxResult.out) {
            callback({
                type: "SIGN_ERROR",
                data: Object.assign({}, tx),
                error: new Error("No signature!"),
            });
            return;
        }
        if ((v._state.queryTxResult.out &&
            v._state.queryTxResult.out.revert !== undefined) ||
            v.revertReason) {
            callback({
                type: "REVERTED",
                data: Object.assign({}, tx),
                error: new Error(((_a = v._state.queryTxResult.out.revert) === null || _a === void 0 ? void 0 : _a.toString()) ||
                    v.revertReason ||
                    "unknown"),
            });
            return;
        }
        else {
            const data = Object.assign(Object.assign({}, tx), { renResponse: hexify(v._state.queryTxResult.out), renSignature: (_b = v._state.queryTxResult.out.signature) === null || _b === void 0 ? void 0 : _b.toString("hex") });
            callback({
                type: "SIGNED",
                data,
            });
        }
    }
    catch (e) {
        // If error was due to revert - enter reverted state
        if (deposit.revertReason) {
            callback({
                type: "REVERTED",
                data: Object.assign({}, tx),
                error: new Error(deposit.revertReason),
            });
            return;
        }
        // If a tx has already been minted, we will get an error at this step
        // We can assume that a "utxo spent" error implies that the asset has been minted
        callback({
            type: "SIGN_ERROR",
            data: tx,
            // Error must be stringified because full log breaks xstate serialization
            error: e,
        });
    }
});
// Handle minting on destination chain
const handleMint = (sourceTxHash, deposit, callback, params) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const minter = deposit.mint(params);
        const onConfirmation = (_, receipt) => {
            const submittedTx = {
                sourceTxHash,
            };
            if (receipt.status == false) {
                callback({
                    type: "SUBMIT_ERROR",
                    data: { sourceTxHash },
                    error: new Error("Transaction was reverted"),
                });
            }
            else {
                callback({
                    type: "ACKNOWLEDGE",
                    data: submittedTx,
                });
            }
            // only acknowledge once
            minter.removeListener("confirmation", onConfirmation);
        };
        yield minter.on("transactionHash", (transactionHash) => {
            const submittedTx = {
                sourceTxHash,
                destTxHash: transactionHash,
            };
            callback({
                type: "SUBMITTED",
                data: submittedTx,
            });
        });
        yield minter.on("confirmation", onConfirmation);
        yield minter;
    }
    catch (e) {
        callback({
            type: "SUBMIT_ERROR",
            data: { sourceTxHash },
            error: e,
        });
    }
});
const resolveDeposit = (hash, deposit) => {
    var _a, _b, _c, _d, _f;
    const rawSourceTx = deposit.depositDetails; // as DepositCommon<>;
    const newDepositState = {
        sourceTxHash: hash,
        renVMHash: deposit.txHash(),
        sourceTxAmount: rawSourceTx.amount,
        sourceTxConfs: parseInt(rawSourceTx.transaction.confirmations || "0"),
        rawSourceTx,
        detectedAt: new Date().getTime(),
    };
    if (!deposit._state.queryTxResult || !deposit._state.queryTxResult.out) {
        return newDepositState;
    }
    else {
        if ((_a = deposit._state.queryTxResult.out) === null || _a === void 0 ? void 0 : _a.revert) {
            newDepositState.error = new Error((_b = deposit._state.queryTxResult.out) === null || _b === void 0 ? void 0 : _b.revert.toString());
            return newDepositState;
        }
        else {
            // only accepted if the queryTxResult has an "out" field
            const acceptedData = Object.assign(Object.assign({}, newDepositState), { sourceTxConfTarget: (_c = deposit._state.targetConfirmations) !== null && _c !== void 0 ? _c : newDepositState.sourceTxConfs, renResponse: hexify(deposit._state.queryTxResult || {}), renSignature: (_d = deposit._state.queryTxResult.out) === null || _d === void 0 ? void 0 : _d.signature });
            if (deposit.status === lockAndMint_1.DepositStatus.Submitted) {
                const data = Object.assign(Object.assign({}, acceptedData), { destTxAmount: ((_f = deposit._state.queryTxResult.out) === null || _f === void 0 ? void 0 : _f.amount) || "0", rawDestTx: {}, contractParams: {}, 
                    // we don't actually know when the tx completed,
                    // so assume it is now
                    completedAt: Date.now(), destTxHash: deposit.mintTransaction });
                return data;
            }
            else {
                return acceptedData;
            }
        }
    }
};
const mintFlow = (context, callback, receive, minter) => {
    // Transactions that we have resolved
    const detectedTransactions = new Map();
    const restoredDeposits = new Map();
    const depositHandler = (deposit) => {
        const txHash = deposit.params.from.transactionID(deposit.depositDetails.transaction);
        const restored = restoredDeposits.get(txHash);
        // if we have previously restored the deposit,
        // don't emit an event
        if (restored) {
            return;
        }
        const persistedTx = context.tx.transactions[txHash] || detectedTransactions.get(txHash);
        if (persistedTx) {
            restoredDeposits.set(txHash, deposit);
            detectedTransactions.set(txHash, persistedTx);
            let data = persistedTx;
            if (deposit.status === lockAndMint_1.DepositStatus.Submitted) {
                const completedTx = Object.assign(Object.assign({}, persistedTx), { destTxHash: deposit.mintTransaction, completedAt: Date.now() });
                data = completedTx;
            }
            return callback({ type: "RESTORED", data });
        }
        const resolved = resolveDeposit(txHash, deposit);
        detectedTransactions.set(txHash, resolved);
        callback({
            type: "DEPOSIT",
            data: resolved,
        });
    };
    minter.on("deposit", depositHandler);
    receive((event) => {
        const deposit = restoredDeposits.get(event.hash);
        if (!deposit)
            return;
        const tx = detectedTransactions.get(event.hash);
        if (!tx || !mint_1.isConfirming(tx)) {
            callback({
                type: "ERROR",
                data: event.data,
                error: new Error(`Invalid deposit: ${String(event.hash)}`),
            });
            return;
        }
        const handle = () => __awaiter(void 0, void 0, void 0, function* () {
            switch (event.type) {
                case "UPDATE":
                    detectedTransactions.set(event.hash, event.data);
                    break;
                case "SETTLE":
                    yield handleSettle(event.hash, deposit, callback);
                    break;
                case "SIGN":
                    yield handleSign(tx, deposit, callback);
                    break;
                case "MINT":
                    yield handleMint(event.hash, deposit, callback, event.params);
                    break;
            }
        });
        handle()
            .then()
            .catch((e) => {
            console.error(e, event.data);
            callback({
                type: "ERROR",
                data: event.data,
                error: e,
            });
        });
    });
    receive((event) => {
        switch (event.type) {
            case "RESTORE":
                minter
                    .processDeposit(event.data.rawSourceTx)
                    .then((r) => {
                    // Previously the on('deposit') event would have fired when restoring
                    // Now, we use the promise result to set up the handler as well in
                    // case the `deposit` event does not fire
                    depositHandler(r);
                })
                    .catch((e) => {
                    callback({
                        type: "ERROR",
                        data: event.data,
                        error: e,
                    });
                });
                break;
        }
    });
};
// Listen for confirmations on the source chain
const depositListener = (context) => (callback, receive) => {
    let cleanup = () => { };
    initMinter(context, callback)
        .then((minter) => {
        cleanup = () => minter.removeAllListeners();
        mintFlow(context, callback, receive, minter);
        callback({ type: "LISTENING" });
    })
        .catch((e) => {
        callback({ type: "ERROR_LISTENING", data: e });
    });
    return () => {
        cleanup();
    };
};
// Spawn an actor that will listen for either all deposits to a gatewayAddress,
// or to a single deposit if present in the context
const listenerAction = xstate_1.assign({
    depositListenerRef: (c, _e) => {
        const actorName = `${c.tx.id}SessionListener`;
        if (c.depositListenerRef) {
            console.warn("listener already exists");
            return c.depositListenerRef;
        }
        const cb = depositListener(c);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        return xstate_1.spawn(cb, actorName);
    },
});
const spawnDepositMachine = (machineContext, name) => xstate_1.spawn(deposit_1.buildDepositMachine()
    .withContext(machineContext)
    .withConfig({
    actions: {
        listenerAction: listenerAction,
    },
}), {
    // sync: true,
    name,
});
const buildMintConfig = () => ({
    services: {
        txCreator,
        depositListener,
    },
    actions: {
        broadcast: xstate_1.actions.pure((ctx, event) => {
            return Object.values(ctx.depositMachines || {}).map((m) => xstate_1.send(event, { to: m.id }));
        }),
        forwardEvent: xstate_1.send((_, b) => {
            return b;
        }, {
            to: (_ctx) => "depositListener",
        }),
        routeEvent: xstate_1.send((_, b) => {
            return b;
        }, {
            to: (ctx, evt) => {
                var _a, _b;
                const machines = ctx.depositMachines || {};
                if (!evt.data)
                    throw new Error("missing data" + JSON.stringify(evt));
                return (((_b = machines[((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxHash) || ""]) === null || _b === void 0 ? void 0 : _b.id) || "missing");
            },
        }),
        spawnDepositMachine: xstate_1.assign({
            depositMachines: (context, evt) => {
                var _a;
                const machines = context.depositMachines || {};
                if (machines[((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxHash) || ""] || !evt.data) {
                    return machines;
                }
                const newMachines = {};
                for (const machine of Object.entries(machines)) {
                    newMachines[machine[0]] = machine[1];
                }
                newMachines[evt.data.sourceTxHash] = spawnDepositMachine({ deposit: evt.data }, String(evt.data.sourceTxHash));
                return newMachines;
            },
        }),
        depositMachineSpawner: xstate_1.assign({
            depositMachines: (context, _) => {
                const machines = {};
                for (const tx of Object.entries(context.tx.transactions || {})) {
                    const machineContext = {
                        deposit: tx[1],
                    };
                    machines[tx[0]] = spawnDepositMachine(machineContext, machineContext.deposit.sourceTxHash);
                }
                return Object.assign(Object.assign({}, machines), context.depositMachines);
            },
        }),
        listenerAction: listenerAction,
    },
});
exports.buildMintConfig = buildMintConfig;
//# sourceMappingURL=genericMint.js.map