"use strict";
/* eslint-disable no-console */
/* eslint-disable @typescript-eslint/no-explicit-any */
// TODO: Improve typings.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildBurnConfig = void 0;
const burnAndRelease_1 = require("@renproject/ren/build/main/burnAndRelease");
const xstate_1 = require("xstate");
const burnAndRelease = (context) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const transaction = (_a = context.tx.transaction) === null || _a === void 0 ? void 0 : _a.sourceTxHash;
    return yield context.sdk.burnAndRelease(Object.assign({ asset: context.tx.sourceAsset.toUpperCase(), to: context.to(context), from: context.from(context) }, (transaction ? { transaction } : {})));
});
const spawnBurnTransaction = xstate_1.assign({
    burnListenerRef: (c, _e) => {
        const actorName = `${c.tx.id}BurnListener`;
        if (c.burnListenerRef) {
            console.warn("listener already exists");
            return c.burnListenerRef;
        }
        const cb = burnTransactionListener(c);
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        return xstate_1.spawn(cb, actorName);
    },
});
const extractTx = (burn) => {
    if (!burn.burnDetails)
        throw new Error("missing burn");
    const tx = {
        renVMHash: burn.txHash(),
        rawSourceTx: burn.burnDetails.transaction,
        sourceTxConfTarget: 0,
        sourceTxConfs: 0,
        sourceTxHash: burn.burnDetails.transaction.hash,
        detectedAt: Date.now(),
        sourceTxAmount: burn.burnDetails.amount.toString(),
    };
    return tx;
};
const performBurn = (burn, callback, cleaners, context) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    // will resume from previous tx if we have the hash
    const burnRef = burn.burn();
    let tx;
    const burnListener = (confs /* actually eth tx target: number */) => {
        burn.confirmationTarget()
            .then((target) => {
            // We need to wait for burn details to resolve, which
            // might not be ready even if we have sufficient confirmations
            const data = Object.assign(Object.assign({}, Object.assign(Object.assign({}, tx), context.tx.transaction)), { sourceTxConfs: confs, sourceTxConfTarget: target });
            callback({
                type: "CONFIRMATION",
                data,
            });
            if (target <= confs) {
                const data = Object.assign(Object.assign({}, Object.assign(Object.assign({}, extractTx(burn)), context.tx.transaction)), { sourceTxConfs: target, sourceTxConfTarget: target });
                callback({
                    type: "CONFIRMED",
                    data,
                });
            }
        })
            .catch((e) => {
            throw e;
        });
    };
    cleaners.push(() => {
        burnRef._cancel();
        burnRef.removeListener("confirmation", burnListener);
    });
    try {
        // ensure we have a target
        const target = ((_b = context.tx.transaction) === null || _b === void 0 ? void 0 : _b.sourceTxConfTarget) ||
            (yield burn.confirmationTarget());
        const r = yield burnRef
            // host chain tx hash
            .on("transactionHash", (txHash) => {
            const data = {
                sourceTxConfs: 0,
                sourceTxConfTarget: target,
                sourceTxHash: txHash,
                detectedAt: Date.now(),
                sourceTxAmount: context.tx.targetAmount,
            };
            tx = data;
            callback({
                type: "SUBMITTED",
                data,
            });
        })
            .on("confirmation", burnListener);
        // stop listening for confirmations once confirmed
        burnRef.removeListener("confirmation", burnListener);
        if (r.status == burnAndRelease_1.BurnAndReleaseStatus.Burned ||
            r.status == burnAndRelease_1.BurnAndReleaseStatus.Released) {
            const data = Object.assign(Object.assign({}, Object.assign(Object.assign({}, extractTx(burn)), context.tx.transaction)), { sourceTxConfs: target, sourceTxConfTarget: target });
            callback({
                type: "CONFIRMED",
                data,
            });
            return data;
        }
        if (r.status == burnAndRelease_1.BurnAndReleaseStatus.Reverted) {
            throw new Error(`Burn tx reverted: ${r.revertReason}`);
        }
        throw new Error(`Burn interrupted`);
    }
    catch (error) {
        throw error;
    }
});
const performRelease = (burn, callback, cleaners, tx) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    // Only start processing release once confirmed
    // Release from renvm status
    const releaseListener = (status) => {
        status === "confirming"
            ? console.debug(`confirming`)
            : console.debug("status", status);
    };
    const hashListener = (renVMHash) => {
        const data = Object.assign(Object.assign({}, tx), { renVMHash });
        callback({
            type: "ACCEPTED",
            data,
        });
    };
    let response;
    const transactionListener = (transaction) => {
        if (!burn.burnDetails)
            return;
        const data = Object.assign(Object.assign({}, tx), { rawSourceTx: burn.burnDetails.transaction, destTxHash: transaction.hash, 
            // Can be used to construct blockchain explorer link
            renResponse: response, rawDestTx: transaction, completedAt: Date.now(), destTxAmount: transaction
                .amount });
        callback({
            type: "COMPLETED",
            data,
        });
    };
    const releaseRef = burn.release();
    cleaners.push(() => {
        releaseRef._cancel();
        releaseRef.removeListener("status", releaseListener);
        releaseRef.removeListener("transaction", transactionListener);
        releaseRef.removeListener("txHash", hashListener);
    });
    releaseRef.catch((e) => {
        console.error("release error", e);
        callback({
            type: "RELEASE_ERROR",
            data: tx,
            error: e,
        });
    });
    try {
        const res = yield releaseRef
            .on("status", releaseListener)
            .on("transaction", transactionListener)
            .on("txHash", hashListener);
        if (!((_c = burn.burnDetails) === null || _c === void 0 ? void 0 : _c.transaction))
            return;
        response = res;
        const data = Object.assign(Object.assign({}, tx), { rawSourceTx: burn.burnDetails.transaction, destTxHash: burn.releaseTransaction, renResponse: res });
        callback({
            type: "RELEASED",
            data,
        });
    }
    catch (e) {
        callback({
            type: "RELEASE_ERROR",
            data: tx,
            error: e,
        });
    }
});
const burnTransactionListener = (context) => (callback, receive) => {
    const cleaners = [];
    let burning = false;
    let tx;
    burnAndRelease(context)
        .then((burn) => {
        // Ready to recieve SUBMIT
        callback({ type: "CREATED" });
        if (context.autoSubmit ||
            // Alway "SUBMIT" if we have submitted previously
            context.tx.transaction) {
            setTimeout(() => callback("SUBMIT"), 500);
        }
        receive((event) => {
            if (event.type === "SUBMIT") {
                // Only burn once
                if (burning) {
                    return;
                }
                burning = true;
                performBurn(burn, callback, cleaners, context)
                    .then((r) => (tx = r))
                    .catch((e) => {
                    console.error(e);
                    callback({
                        type: "BURN_ERROR",
                        data: e.toString(),
                        error: e,
                    });
                });
            }
            if (event.type === "RELEASE") {
                const tx = context.tx
                    .transaction ||
                    extractTx(burn);
                performRelease(burn, callback, cleaners, tx)
                    .then()
                    .catch((e) => {
                    callback({
                        type: "BURN_ERROR",
                        data: context.tx,
                        error: e,
                    });
                });
            }
        });
    })
        .catch((e) => {
        console.error(e);
        callback({ type: "BURN_ERROR", data: {}, error: e });
    });
    return () => {
        for (const cleaner of cleaners) {
            cleaner();
        }
    };
};
const buildBurnConfig = () => ({
    actions: {
        burnSpawner: spawnBurnTransaction,
    },
    services: {
        burnListener: burnTransactionListener,
    },
});
exports.buildBurnConfig = buildBurnConfig;
//# sourceMappingURL=genericBurn.js.map