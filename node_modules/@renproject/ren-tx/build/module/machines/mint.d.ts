import { Actor, SpawnedActorRef, State } from "xstate";
import RenJS from "@renproject/ren";
import { DepositCommon, LockChain, MintChain } from "@renproject/interfaces";
import { UTXO } from "@renproject/chains-bitcoin/build/main/APIs/API";
import { AllGatewayTransactions, AcceptedGatewayTransaction, ConfirmingGatewayTransaction, GatewaySession, GatewayTransaction, MintedGatewayTransaction, OpenedGatewaySession } from "../types/mint";
import { DepositMachineContext, DepositMachineEvent, DepositMachineSchema, DepositMachineTypestate } from "./deposit";
export interface GatewayMachineContext<DepositType, MintType = any> {
    /**
     * The session arguments used for instantiating a mint gateway
     */
    tx: GatewaySession<DepositType> | OpenedGatewaySession<DepositType>;
    /**
     * A reference to a deposit hashes of transactions that can be
     * minted on their destination chains
     */
    mintRequests?: string[];
    /**
     * @private
     * Keeps track of child machines that track underlying deposits
     */
    depositMachines?: {
        [key in string]: SpawnedActorRef<DepositMachineEvent<DepositType>, State<DepositMachineContext<AllGatewayTransactions<DepositType>>, DepositMachineEvent<DepositType>, DepositMachineSchema<DepositType>, DepositMachineTypestate<DepositType>>>;
    };
    /**
     * @private
     * a listener callback that interacts with renjs deposit objects
     */
    depositListenerRef?: Actor<any>;
    /**
     * Function to create the "from" param;
     */
    from: (context: GatewayMachineContext<DepositType>) => LockChain<DepositType, DepositCommon<DepositType>>;
    /**
     * Function to create the "to" RenJS param;
     */
    to: (context: GatewayMachineContext<DepositType>) => MintChain<MintType>;
    sdk: RenJS;
}
export declare enum GatewayStates {
    RESTORING = "restoring",
    CREATING = "creating",
    ERROR_CREATING = "srcInitializeError",
    LISTENING = "listening",
    COMPLETED = "completed"
}
export interface GatewayMachineSchema {
    states: {
        restoring: {};
        creating: {};
        srcInitializeError: {};
        listening: {};
        completed: {};
    };
}
export declare type DepositEvent<DepositType> = {
    type: "DEPOSIT";
    data: GatewayTransaction<DepositType>;
};
export declare type GatewayMachineEvent<DepositType> = DepositMachineEvent<DepositType> | {
    type: "CLAIMABLE";
    data: AcceptedGatewayTransaction<DepositType>;
} | {
    type: "ERROR_LISTENING";
    data: any;
} | DepositEvent<DepositType> | {
    type: "DEPOSIT_UPDATE";
    data: AllGatewayTransactions<DepositType>;
} | {
    type: "DEPOSIT_COMPLETED";
    data: MintedGatewayTransaction<DepositType>;
} | {
    type: "SIGN";
    data: ConfirmingGatewayTransaction<DepositType>;
} | {
    type: "SETTLE";
    data: GatewayTransaction<DepositType>;
} | {
    type: "MINT";
    data: AcceptedGatewayTransaction<DepositType>;
} | {
    type: "EXPIRED";
    data: GatewayTransaction<DepositType>;
} | {
    type: "ACKNOWLEDGE";
    data: any;
} | {
    type: "RESTORE";
    data: GatewayTransaction<DepositType>;
};
export interface LockChainMap<Context> {
    [key: string]: (context: Context) => LockChain<any, DepositCommon<any>>;
}
export interface MintChainMap<Context> {
    [key: string]: (context: Context) => MintChain<any>;
}
export declare const buildMintContextWithMap: <X>(params: {
    tx: GatewaySession<X, {}> | OpenedGatewaySession<X, {}>;
    sdk: RenJS;
    /**
     * Functions to create the "from" param;
     */
    fromChainMap: LockChainMap<GatewayMachineContext<X, any>>;
    /**
     * Functions to create the "to" RenJS param;
     */
    toChainMap: MintChainMap<GatewayMachineContext<X, any>>;
}) => GatewayMachineContext<any, any>;
/**
 * An Xstate machine that, when given a serializable [[GatewaySession]] tx,
 * will instantiate a RenJS LockAndMint session, provide a gateway address,
 * listen for deposits, and request a signature once a deposit has reached
 * the appropriate number of confirmations.
 *
 * Given the same [[GatewaySession]] parameters, as long as the tx has not
 * expired, the machine will restore the transaction to the appropriate
 * state and enable the completion of in-progress minting transactions.
 *
 * The machine allows for multiple deposits to be detected; it is up to the
 * developer to decide if a detected deposit should be signed or rejected.
 * See `/demos/simpleMint.ts` for example usage.
 */
export declare const buildMintMachine: <X extends UTXO>() => import("xstate").StateMachine<GatewayMachineContext<X, any>, any, GatewayMachineEvent<X>, {
    value: any;
    context: GatewayMachineContext<X, any>;
}>;
