/* eslint-disable @typescript-eslint/no-explicit-any */
// TODO: Improve typings.
import { assign, createMachine, createSchema, send, sendParent, } from "xstate";
import { log } from "xstate/lib/actions";
import { assert } from "@renproject/utils";
import { isAccepted, isCompleted, isConfirming, isMinted, isSubmitted, } from "../types/mint";
const largest = (x, y) => {
    if (!x) {
        if (y)
            return y;
        return 0;
    }
    if (!y) {
        if (x)
            return x;
        return 0;
    }
    if (x > y)
        return x;
    return y;
};
export var DepositStates;
(function (DepositStates) {
    DepositStates["CHECKING_COMPLETION"] = "checkingCompletion";
    /** We are waiting for ren-js to find the deposit */
    DepositStates["RESTORING_DEPOSIT"] = "restoringDeposit";
    /** We couldn't restore this deposit */
    DepositStates["ERROR_RESTORING"] = "errorRestoring";
    /** renjs has found the deposit for the transaction */
    DepositStates["RESTORED_DEPOSIT"] = "restoredDeposit";
    /** we are waiting for the source chain to confirm the transaction */
    DepositStates["CONFIRMING_DEPOSIT"] = "srcSettling";
    /** source chain has confirmed the transaction, submitting to renvm for signature */
    DepositStates["RENVM_SIGNING"] = "srcConfirmed";
    /** renvm has accepted and signed the transaction */
    DepositStates["RENVM_ACCEPTED"] = "accepted";
    /** renvm did not accept the tx */
    DepositStates["ERROR_SIGNING"] = "errorAccepting";
    /** the user is submitting the transaction to mint on the destination chain */
    DepositStates["SUBMITTING_MINT"] = "claiming";
    /** there was an error submitting the tx to the destination chain */
    DepositStates["ERROR_MINTING"] = "errorSubmitting";
    /** We have recieved a txHash for the destination chain */
    DepositStates["MINTING"] = "destInitiated";
    /** user has acknowledged that the transaction is completed, so we can stop listening for further deposits */
    DepositStates["COMPLETED"] = "completed";
    /** user does not want to mint this deposit or the transaction reverted */
    DepositStates["REJECTED"] = "rejected";
})(DepositStates || (DepositStates = {}));
/** Statemachine that tracks individual deposits */
export const buildDepositMachine = () => createMachine({
    id: "RenVMDepositTransaction",
    initial: DepositStates.CHECKING_COMPLETION,
    schema: {
        events: createSchema(),
        context: createSchema(),
    },
    states: {
        // Checking if deposit is completed so that we can skip initialization
        checkingCompletion: {
            entry: [send("CHECK")],
            // If we already have completed, no need to listen
            on: {
                CHECK: [
                    {
                        target: "completed",
                        cond: "isCompleted",
                    },
                    { target: "restoringDeposit" },
                ],
            },
            meta: {
                test: (_, state) => {
                    assert(!state.context.deposit.error ? true : false, "Error must not exist");
                },
            },
        },
        errorRestoring: {
            entry: [log((ctx, _) => ctx.deposit.error, "ERROR")],
            meta: {
                test: (_, state) => {
                    assert(state.context.deposit.error ? true : false, "Error must exist");
                },
            },
        },
        restoringDeposit: {
            entry: sendParent((c, _) => ({
                type: "RESTORE",
                data: c.deposit,
            })),
            on: {
                RESTORED: {
                    target: "restoredDeposit",
                    actions: [assign((_, e) => ({ deposit: e.data }))],
                },
                ERROR: {
                    target: "errorRestoring",
                    actions: assign((c, e) => ({
                        deposit: Object.assign(Object.assign({}, c.deposit), { error: e.error }),
                    })),
                },
            },
            meta: {
                test: (_, state) => {
                    assert(!state.context.deposit.error ? true : false, "Error must not exist");
                },
            },
        },
        // Checking deposit internal state to transition to correct machine state
        restoredDeposit: {
            // Parent must send restored
            entry: [send("RESTORED")],
            on: {
                RESTORED: [
                    {
                        target: "srcSettling",
                        cond: "isSrcSettling",
                    },
                    {
                        target: "srcConfirmed",
                        cond: "isSrcSettled",
                    },
                    {
                        target: "accepted",
                        cond: "isAccepted",
                    },
                ].reverse(),
            },
            meta: { test: async () => { } },
        },
        srcSettling: {
            entry: sendParent((ctx, _) => ({
                type: "SETTLE",
                hash: ctx.deposit.sourceTxHash,
            })),
            on: {
                CONFIRMED: [
                    {
                        target: "srcConfirmed",
                        actions: [
                            assign({
                                deposit: ({ deposit }, evt) => {
                                    if (isConfirming(deposit) &&
                                        deposit.sourceTxConfTarget) {
                                        return Object.assign(Object.assign({}, deposit), { sourceTxConfs: largest(deposit.sourceTxConfs, evt.data.sourceTxConfs), sourceTxConfTarget: largest(deposit.sourceTxConfTarget, evt.data
                                                .sourceTxConfTarget) });
                                    }
                                    return deposit;
                                },
                            }),
                            sendParent((ctx, _) => {
                                return {
                                    type: "DEPOSIT_UPDATE",
                                    data: ctx.deposit,
                                };
                            }),
                        ],
                    },
                ],
                CONFIRMATION: [
                    {
                        actions: [
                            sendParent((ctx, evt) => ({
                                type: "DEPOSIT_UPDATE",
                                data: Object.assign(Object.assign({}, ctx.deposit), evt.data),
                            })),
                            assign({
                                deposit: (context, evt) => {
                                    var _a, _b;
                                    return (Object.assign(Object.assign({}, context.deposit), { sourceTxConfs: ((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxConfs) || 0, sourceTxConfTarget: (_b = evt.data) === null || _b === void 0 ? void 0 : _b.sourceTxConfTarget }));
                                },
                            }),
                        ],
                    },
                ],
                ERROR: [
                    {
                        actions: [
                            assign({
                                deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                            }),
                            log((ctx, _) => ctx.deposit.error, "ERROR"),
                        ],
                    },
                ],
            },
            meta: { test: async () => { } },
        },
        srcConfirmed: {
            entry: sendParent((ctx, _) => ({
                type: "SIGN",
                hash: ctx.deposit.sourceTxHash,
            })),
            on: {
                SIGN_ERROR: {
                    target: "errorAccepting",
                    actions: assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                    }),
                },
                REVERTED: {
                    target: "rejected",
                    actions: assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                    }),
                },
                SIGNED: {
                    target: "accepted",
                    actions: assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), evt.data)),
                    }),
                },
            },
            meta: { test: async () => { } },
        },
        errorAccepting: {
            entry: [log((ctx, _) => ctx.deposit.error, "ERROR")],
            meta: {
                test: (_, state) => {
                    assert(state.context.deposit.error ? true : false, "error must exist");
                },
            },
        },
        accepted: {
            entry: sendParent((ctx, _) => {
                return {
                    type: "CLAIMABLE",
                    data: ctx.deposit,
                };
            }),
            on: {
                CLAIM: {
                    target: "claiming",
                    actions: assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { contractParams: evt.params })),
                    }),
                },
                REJECT: "rejected",
            },
            meta: { test: async () => { } },
        },
        errorSubmitting: {
            entry: [
                log((ctx, _) => ctx.deposit.error, "ERROR"),
                sendParent((ctx, _) => {
                    return {
                        type: "CLAIMABLE",
                        data: ctx.deposit,
                    };
                }),
            ],
            on: {
                CLAIM: {
                    target: "claiming",
                    actions: assign({
                        deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { contractParams: evt.data })),
                    }),
                },
                REJECT: "rejected",
            },
            meta: {
                test: (_, state) => {
                    assert(state.context.deposit.error ? true : false, "error must exist");
                },
            },
        },
        claiming: {
            entry: sendParent((ctx) => ({
                type: "MINT",
                hash: ctx.deposit.sourceTxHash,
                data: isSubmitted(ctx.deposit) &&
                    ctx.deposit.contractParams,
            })),
            on: {
                SUBMIT_ERROR: [
                    {
                        target: "errorSubmitting",
                        actions: [
                            assign({
                                deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), { error: evt.error })),
                            }),
                            sendParent((ctx, _) => ({
                                type: "DEPOSIT_UPDATE",
                                data: ctx.deposit,
                            })),
                        ],
                    },
                ],
                SUBMITTED: [
                    {
                        target: "destInitiated",
                        actions: [
                            assign({
                                deposit: (ctx, evt) => (Object.assign(Object.assign({}, ctx.deposit), evt.data)),
                            }),
                            sendParent((ctx, _) => ({
                                type: "DEPOSIT_UPDATE",
                                data: ctx.deposit,
                            })),
                        ],
                    },
                ],
            },
            meta: { test: async () => { } },
        },
        destInitiated: {
            on: {
                ACKNOWLEDGE: {
                    target: "completed",
                    actions: [
                        assign({
                            deposit: (ctx, _) => (Object.assign(Object.assign({}, ctx.deposit), { completedAt: new Date().getTime() })),
                        }),
                    ],
                },
            },
            meta: { test: async () => { } },
        },
        rejected: {
            entry: [
                sendParent((ctx, _) => {
                    return {
                        type: "DEPOSIT_UPDATE",
                        data: ctx.deposit,
                    };
                }),
            ],
            meta: { test: async () => { } },
        },
        completed: {
            entry: [
                sendParent((ctx, _) => ({
                    type: "DEPOSIT_COMPLETED",
                    data: ctx.deposit,
                })),
                sendParent((ctx, _) => ({
                    type: "DEPOSIT_UPDATE",
                    data: ctx.deposit,
                })),
            ],
            meta: {
                test: (_, state) => {
                    assert(state.context.deposit.completedAt
                        ? true
                        : false, "Must have completedAt timestamp");
                },
            },
        },
    },
}, {
    guards: {
        isSrcSettling: ({ deposit }) => isConfirming(deposit) &&
            (deposit.sourceTxConfs || 0) <
                (deposit.sourceTxConfTarget ||
                    Number.POSITIVE_INFINITY),
        isSrcSettled: ({ deposit }) => isConfirming(deposit) &&
            (deposit.sourceTxConfs || 0) >= deposit.sourceTxConfTarget,
        isAccepted: ({ deposit }) => isAccepted(deposit) && deposit.renSignature ? true : false,
        isDestInitiated: ({ deposit }) => isMinted(deposit) && deposit.destTxHash ? true : false,
        isCompleted: ({ deposit }) => isCompleted(deposit) && deposit.completedAt ? true : false,
    },
});
//# sourceMappingURL=deposit.js.map