/// <reference types="node" />
import { GatewaySession, GatewayMachineContext, DepositStates, GatewayStates, LockChainMap, MintChainMap } from "@renproject/ren-tx";
import RenJS from "@renproject/ren";
import { LockChain, MintChain, RenNetwork } from "@renproject/interfaces";
import { BurnSession } from "@renproject/ren-tx/build/main/types/burn";
import { UTXO } from "../../../../lib/chains/chains-bitcoin/build/main/APIs/API";
interface MintParams {
    /**
     * Asset to be minted/burned (on native chain) eg. "BTC"
     */
    sourceAsset: string;
    /**
     * Ren network version to be used, which determines network versions for the selected chains
     */
    network: RenNetwork | "testnet" | "mainnet";
    /**
     * Address that will recieve the asset, eg. "0xA1..."
     */
    destinationAddress: string;
    /**
     * How much the user expects to recieve in destAsset (eg. BTC)
     *
     */
    targetAmount?: string | number;
    /**
     * Amount of sourceAsset user is suggested to send in the base denomination (eg. SATs for Bitcoin)
     * Usually the targetAmount + fees
     */
    suggestedAmount?: string | number;
    /**
     * Optional random 32 bytes to make the gateway address unique. Must be persisted in order to restore the transaction
     */
    nonce?: string | Buffer;
}
export declare const getSessionDay: () => number;
export declare const getSessionExpiry: () => number;
export declare function idFromParams(session: GatewaySession<any> | BurnSession<any, any>): string;
export interface MintConfig {
    sdk: RenJS;
    mintParams: MintParams;
    debug?: boolean;
}
export interface MintConfigSingle extends MintConfig {
    to: MintChain;
    from: LockChain;
}
export interface MintConfigMultiple<CustomParams = {}> extends MintConfig {
    toMap: MintChainMap<GatewayMachineContext<any>>;
    fromMap: LockChainMap<GatewayMachineContext<any>>;
    /**
     * Chain that the source asset is located on, eg. "Bitcoin"
     */
    sourceChain: string;
    /**
     * Chain that the asset will be recieved on eg. "Ethereum"
     */
    destinationChain: string;
    /**
     * Address that can cryptographically be proven to belong to a user. Used as a "from" address for some chains
     */
    userAddress: string;
    /**
     * Extra parameters to be used for constructing to/from contract parameters
     */
    customParams: CustomParams;
}
export declare const useLockAndMint: (config: MintConfigSingle | MintConfigMultiple) => {
    addDeposit: (amount: any, txHash: any, vOut: any) => void;
    deposits: string[];
    formatAmount: (amount: string) => number;
    session: GatewaySession<UTXO, {}> | import("@renproject/ren-tx").OpenedGatewaySession<UTXO, {}>;
    sessionMachine: import("xstate").Interpreter<GatewayMachineContext<UTXO, any>, any, import("@renproject/ren-tx").GatewayMachineEvent<UTXO>, {
        value: any;
        context: GatewayMachineContext<UTXO, any>;
    }>;
    state: GatewayStates;
};
export declare const useDeposit: (session: ReturnType<typeof useLockAndMint>, depositId: string) => {
    state: import("xstate").State<import("@renproject/ren-tx").DepositMachineContext<import("@renproject/ren-tx").AllGatewayTransactions<UTXO>>, import("@renproject/ren-tx").DepositMachineEvent<UTXO>, import("@renproject/ren-tx").DepositMachineSchema<UTXO>, import("@renproject/ren-tx").DepositMachineTypestate<UTXO>>;
    formatAmount: (amount: string) => number;
    value: DepositStates;
    deposit: import("@renproject/ren-tx").AllGatewayTransactions<UTXO>;
    mint: () => void;
} | undefined;
export {};
