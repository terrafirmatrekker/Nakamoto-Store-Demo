/// <reference types="node" />
import { BurnMachineContext, BurnStates, LockChainMap, MintChainMap } from "@renproject/ren-tx";
import RenJS from "@renproject/ren";
import { LockChain, MintChain, RenNetwork } from "@renproject/interfaces";
import { BurnSession } from "@renproject/ren-tx/build/main/types/burn";
interface BurnParams {
    /**
     * Asset to be minted/burned (on native chain) eg. "BTC"
     */
    sourceAsset: string;
    /**
     * Ren network version to be used, which determines network versions for the selected chains
     */
    network: RenNetwork | "testnet" | "mainnet";
    /**
     * Address that will recieve the asset, eg. "0xA1..."
     */
    destinationAddress: string;
    /**
     * How much the user wishes to burn in the minimum denomination (eg SATS for BTC)
     */
    targetAmount: string;
    /**
     * Optional random 32 bytes to make the gateway address unique. Must be persisted in order to restore the transaction
     */
    nonce?: string | Buffer;
}
export interface BurnConfig {
    sdk: RenJS;
    burnParams: BurnParams;
    debug?: boolean;
    autoSubmit?: boolean;
}
export interface BurnConfigSingle extends BurnConfig {
    to: LockChain;
    from: MintChain;
}
export interface BurnConfigMultiple<CustomParams = {}> extends BurnConfig {
    toMap: LockChainMap<BurnMachineContext<any, any>>;
    fromMap: MintChainMap<BurnMachineContext<any, any>>;
    /**
     * Chain that the source asset is located on, eg. "Bitcoin"
     */
    sourceChain: string;
    /**
     * Chain that the asset will be recieved on eg. "Ethereum"
     */
    destinationChain: string;
    /**
     * Address that can cryptographically be proven to belong to a user. Used as a "from" address for some chains
     */
    userAddress: string;
    /**
     * Extra parameters to be used for constructing to/from contract parameters
     */
    customParams: CustomParams;
}
export declare const useBurnAndRelease: (config: BurnConfigSingle | BurnConfigMultiple) => {
    machine: import("xstate").Interpreter<BurnMachineContext<unknown, unknown>, any, import("@renproject/ren-tx").BurnMachineEvent<unknown, unknown>, {
        value: any;
        context: BurnMachineContext<unknown, unknown>;
    }>;
    state: import("xstate").State<BurnMachineContext<unknown, unknown>, import("@renproject/ren-tx").BurnMachineEvent<unknown, unknown>, any, {
        value: any;
        context: BurnMachineContext<unknown, unknown>;
    }>;
    formatAmount: (amount: string) => number;
    value: BurnStates;
    session: BurnSession<unknown, unknown, {}> | import("@renproject/ren-tx").ErroringBurnSession<unknown, {}>;
    tx: import("@renproject/ren-tx").BurnTransaction | import("@renproject/ren-tx").ConfirmedBurnTransaction<unknown> | import("@renproject/ren-tx").ReleasedBurnTransaction<unknown> | import("@renproject/ren-tx").CompletedBurnTransaction<unknown, unknown> | import("@renproject/ren-tx").CompletedBurnTransaction<unknown, {}> | undefined;
    burn: () => void;
};
export {};
