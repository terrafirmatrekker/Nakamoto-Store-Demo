{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar base58check = require('bs58check');\n\nvar bcrypto = require('./crypto');\n\nvar createHmac = require('create-hmac');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar NETWORKS = require('./networks');\n\nvar BigInteger = require('bigi');\n\nvar ECPair = require('./ecpair');\n\nvar ecurve = require('ecurve');\n\nvar curve = ecurve.getCurveByName('secp256k1');\n\nvar fastcurve = require('./fastcurve');\n\nfunction HDNode(keyPair, chainCode) {\n  typeforce(types.tuple('ECPair', types.Buffer256bit), arguments);\n  if (!keyPair.compressed) throw new TypeError('BIP32 only allows compressed keyPairs');\n  this.keyPair = keyPair;\n  this.chainCode = chainCode;\n  this.depth = 0;\n  this.index = 0;\n  this.parentFingerprint = 0x00000000;\n  this.derivationCache = {};\n}\n\nHDNode.HIGHEST_BIT = 0x80000000;\nHDNode.LENGTH = 78;\nHDNode.MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8');\n\nHDNode.fromSeedBuffer = function (seed, network) {\n  typeforce(types.tuple(types.Buffer, types.maybe(types.Network)), arguments);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  var I = createHmac('sha512', HDNode.MASTER_SECRET).update(seed).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32); // In case IL is 0 or >= n, the master key is invalid\n  // This is handled by the ECPair constructor\n\n  var pIL = BigInteger.fromBuffer(IL);\n  var keyPair = new ECPair(pIL, null, {\n    network: network\n  });\n  return new HDNode(keyPair, IR);\n};\n\nHDNode.fromSeedHex = function (hex, network) {\n  return HDNode.fromSeedBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nHDNode.fromBase58 = function (string, networks) {\n  var buffer = base58check.decode(string);\n  if (buffer.length !== 78) throw new Error('Invalid buffer length'); // 4 bytes: version bytes\n\n  var version = buffer.readUInt32BE(0);\n  var network; // list of networks?\n\n  if (Array.isArray(networks)) {\n    // FIXME(BG-16845):\n    // This is only useful when you know the coin but you are not sure if it is mainnet or testnet.\n    // All mainnets have xpub/xprv and all testnets have tpub/tprv as version.\n    network = networks.filter(function (x) {\n      return version === x.bip32.private || version === x.bip32.public;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = networks || NETWORKS.bitcoin;\n  }\n\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new Error('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  var depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  var parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new Error('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  var index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new Error('Invalid index'); // 32 bytes: the chain code\n\n  var chainCode = buffer.slice(13, 45);\n  var keyPair; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new Error('Invalid private key');\n    var d = BigInteger.fromBuffer(buffer.slice(46, 78));\n    keyPair = new ECPair(d, null, {\n      network: network\n    }); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    var Q = ecurve.Point.decodeFrom(curve, buffer.slice(45, 78)); // Q.compressed is assumed, if somehow this assumption is broken, `new HDNode` will throw\n    // Verify that the X coordinate in the public point corresponds to a point on the curve.\n    // If not, the extended public key is invalid.\n\n    curve.validate(Q);\n    keyPair = new ECPair(null, Q, {\n      network: network\n    });\n  }\n\n  var hd = new HDNode(keyPair, chainCode);\n  hd.depth = depth;\n  hd.index = index;\n  hd.parentFingerprint = parentFingerprint;\n  return hd;\n};\n\nHDNode.prototype.getAddress = function () {\n  return this.keyPair.getAddress();\n};\n\nHDNode.prototype.getIdentifier = function () {\n  return bcrypto.hash160(this.keyPair.getPublicKeyBuffer());\n};\n\nHDNode.prototype.getFingerprint = function () {\n  return this.getIdentifier().slice(0, 4);\n};\n\nHDNode.prototype.getNetwork = function () {\n  return this.keyPair.getNetwork();\n};\n\nHDNode.prototype.getPublicKeyBuffer = function () {\n  return this.keyPair.getPublicKeyBuffer();\n};\n\nHDNode.prototype.neutered = function () {\n  var neuteredKeyPair = new ECPair(null, this.keyPair.Q, {\n    network: this.keyPair.network\n  });\n  var neutered = new HDNode(neuteredKeyPair, this.chainCode);\n  neutered.depth = this.depth;\n  neutered.index = this.index;\n  neutered.parentFingerprint = this.parentFingerprint;\n  return neutered;\n};\n\nHDNode.prototype.sign = function (hash) {\n  return this.keyPair.sign(hash);\n};\n\nHDNode.prototype.verify = function (hash, signature) {\n  return this.keyPair.verify(hash, signature);\n};\n\nHDNode.prototype.toBase58 = function (__isPrivate) {\n  if (__isPrivate !== undefined) throw new TypeError('Unsupported argument in 2.0.0'); // Version\n\n  var network = this.keyPair.network;\n  var version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n  var buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n  buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n  buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in big endian. (0x00000000 if master key)\n\n  buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n  this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n  if (!this.isNeutered()) {\n    // 0x00 + k for private keys\n    buffer.writeUInt8(0, 45);\n    this.keyPair.d.toBuffer(32).copy(buffer, 46); // 33 bytes: the public key\n  } else {\n    // X9.62 encoding for public keys\n    this.keyPair.getPublicKeyBuffer().copy(buffer, 45);\n  }\n\n  return base58check.encode(buffer);\n}; // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n\nHDNode.prototype.derive = function (index) {\n  typeforce(types.UInt32, index);\n  var isHardened = index >= HDNode.HIGHEST_BIT;\n  var data = Buffer.allocUnsafe(37); // Hardened child\n\n  if (isHardened) {\n    if (this.isNeutered()) throw new TypeError('Could not derive hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n    data[0] = 0x00;\n    this.keyPair.d.toBuffer(32).copy(data, 1);\n    data.writeUInt32BE(index, 33); // Normal child\n  } else {\n    // data = serP(point(kpar)) || ser32(index)\n    //      = serP(Kpar) || ser32(index)\n    this.keyPair.getPublicKeyBuffer().copy(data, 0);\n    data.writeUInt32BE(index, 33);\n  }\n\n  var I = createHmac('sha512', this.chainCode).update(data).digest();\n  var IL = I.slice(0, 32);\n  var IR = I.slice(32);\n  var pIL = BigInteger.fromBuffer(IL); // In case parse256(IL) >= n, proceed with the next value for i\n\n  if (pIL.compareTo(curve.n) >= 0) {\n    return this.derive(index + 1);\n  } // Private parent key -> private child key\n\n\n  var derivedKeyPair;\n\n  if (!this.isNeutered()) {\n    // ki = parse256(IL) + kpar (mod n)\n    var ki = pIL.add(this.keyPair.d).mod(curve.n); // In case ki == 0, proceed with the next value for i\n\n    if (ki.signum() === 0) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(ki, null, {\n      network: this.keyPair.network\n    }); // Public parent key -> public child key\n  } else {\n    // Ki = point(parse256(IL)) + Kpar\n    //    = G*IL + Kpar\n    var point = fastcurve.publicKeyCreate(IL, false);\n    var Ki = point !== undefined ? ecurve.Point.decodeFrom(curve, point).add(this.keyPair.Q) : curve.G.multiply(pIL).add(this.keyPair.Q); // In case Ki is the point at infinity, proceed with the next value for i\n\n    if (curve.isInfinity(Ki)) {\n      return this.derive(index + 1);\n    }\n\n    derivedKeyPair = new ECPair(null, Ki, {\n      network: this.keyPair.network\n    });\n  }\n\n  var hd = new HDNode(derivedKeyPair, IR);\n  hd.depth = this.depth + 1;\n  hd.index = index;\n  hd.parentFingerprint = this.getFingerprint().readUInt32BE(0);\n  return hd;\n};\n\nHDNode.prototype.deriveHardened = function (index) {\n  typeforce(types.UInt31, index); // Only derives hardened private keys by default\n\n  return this.derive(index + HDNode.HIGHEST_BIT);\n}; // Private === not neutered\n// Public === neutered\n\n\nHDNode.prototype.isNeutered = function () {\n  return !this.keyPair.d;\n};\n\nHDNode.prototype.derivePath = function (path, cache) {\n  typeforce(types.BIP32Path, path);\n  typeforce(types.maybe(types.Object), cache);\n  cache = cache || this.derivationCache;\n  var splitPath = path.split('/');\n\n  if (splitPath[0] === 'm') {\n    if (this.parentFingerprint) {\n      throw new Error('Not a master node');\n    }\n\n    splitPath = splitPath.slice(1);\n  }\n\n  return splitPath.reduce(function (prevHd, indexStr) {\n    var index;\n    var cacheObject = cache[indexStr] || {};\n\n    if (cacheObject.node) {\n      cache = cacheObject.next;\n      return cacheObject.node;\n    }\n\n    if (indexStr.slice(-1) === \"'\") {\n      index = parseInt(indexStr.slice(0, -1), 10);\n      cacheObject.node = prevHd.deriveHardened(index);\n    } else {\n      index = parseInt(indexStr, 10);\n      cacheObject.node = prevHd.derive(index);\n    }\n\n    cache[indexStr] = cacheObject;\n    cacheObject.next = {};\n    cache = cacheObject.next;\n    return cacheObject.node;\n  }, this);\n};\n/**\n * Create a new ECPair object from this HDNode's ECPair.\n *\n * Uses secp256k1 if available for accelerated computation of the cloned public key.\n * @return {ECPair}\n */\n\n\nHDNode.prototype.cloneKeypair = function () {\n  var k = this.keyPair;\n  var result = new ECPair(k.d, k.d ? null : k.Q, {\n    network: k.network,\n    compressed: k.compressed\n  }); // Creating Q from d takes ~25ms, so if it's not created, use native bindings to pre-compute\n  // if Q is not set here, it will be lazily computed via the slow path\n\n  if (!result.__Q) {\n    var point = fastcurve.publicKeyCreate(k.d.toBuffer(32), false);\n\n    if (point !== undefined) {\n      result.__Q = ecurve.Point.decodeFrom(curve, point);\n    }\n  }\n\n  return result;\n};\n\nmodule.exports = HDNode;","map":null,"metadata":{},"sourceType":"script"}