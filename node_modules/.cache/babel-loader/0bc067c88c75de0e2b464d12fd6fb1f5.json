{"ast":null,"code":"import _defineProperty from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _inherits from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _getPrototypeOf from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _assertThisInitialized from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\n\nvar _DepositStatusIndex;\n\nimport { getRenNetworkDetails, newPromiEvent, NullLogger, RenJSErrors, TxStatus, TxStatusIndex } from \"@renproject/interfaces\";\nimport { assertObject, assertType, emptyNonce, extractError, fromBase64, fromHex, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, overrideContractCalls, Ox, payloadToMintABI, renVMHashToBase64, retryNTimes, SECONDS, sleep, strip0x, toBase64, toURLBase64 } from \"@renproject/utils\";\nimport { EventEmitter } from \"events\";\nimport { OrderedMap } from \"immutable\";\nimport { AbiCoder } from \"web3-eth-abi\";\n/**\n * A `LockAndMint` object tied to a particular gateway address. LockAndMint\n * should not be created directly. Instead, [[RenJS.lockAndMint]] will create a\n * `LockAndMint` object.\n *\n * `LockAndMint` extends the EventEmitter class, and emits a `\"deposit\"` event\n * for each new deposit that is observed. Deposits will only be watched for if\n * there is an active listener for the `\"deposit\"` event.\n *\n * A LockAndMint object watches transactions to the [[gatewayAddress]] on the\n * lock-chain.\n *\n * Deposits to the gateway address can be listened to with the `\"deposit\"`\n * event using [[on]], which will return [[LockAndMintDeposit]] instances.\n *\n * ```ts\n * console.log(`Deposit to ${JSON.stringify(lockAndMint.gatewayAddress)}`);\n *\n * lockAndMint.on(\"deposit\", async (deposit) => {\n *    console.log(`Received deposit`, deposit);\n *    await RenJS.defaultDepositHandler(deposit);\n * });\n * ```\n *\n * @noInheritDoc\n */\n\nexport var LockAndMint =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(LockAndMint, _EventEmitter);\n\n  /**\n   * @hidden - should be created using [[RenJS.lockAndMint]] instead.\n   */\n  function LockAndMint(renVM, params) {\n    var _this;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, LockAndMint);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LockAndMint).call(this));\n    /**\n     * Deposits represents the lock deposits that have been so far.\n     */\n\n    _this.deposits = OrderedMap();\n    _this.confirmationTarget =\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var target, getConfirmationTarget, defaultConfirmations;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!isDefined(_this._state.targetConfirmations)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", _this._state.targetConfirmations);\n\n            case 2:\n              getConfirmationTarget = _this.renVM.getConfirmationTarget;\n\n              if (!getConfirmationTarget) {\n                _context2.next = 7;\n                break;\n              }\n\n              _context2.next = 6;\n              return retryNTimes(\n              /*#__PURE__*/\n              _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        return _context.abrupt(\"return\", getConfirmationTarget(_this._state.selector, _this.params.from));\n\n                      case 1:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })), 2);\n\n            case 6:\n              target = _context2.sent;\n\n            case 7:\n              defaultConfirmations = _this._state.renNetwork && _this._state.renNetwork.isTestnet ? 2 : 6;\n              _this._state.targetConfirmations = isDefined(target) ? target : defaultConfirmations;\n              return _context2.abrupt(\"return\", _this._state.targetConfirmations);\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    /**\n     * @hidden - Called automatically when calling [[RenJS.lockAndMint]]. It has\n     * been split from the constructor because it's asynchronous.\n     */\n\n    _this._initialize =\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3() {\n      var overwriteParams;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.t0 = _this._state.renNetwork;\n\n              if (_context3.t0) {\n                _context3.next = 7;\n                break;\n              }\n\n              _context3.t1 = getRenNetworkDetails;\n              _context3.next = 5;\n              return _this.renVM.getNetwork(_this._state.selector);\n\n            case 5:\n              _context3.t2 = _context3.sent;\n              _context3.t0 = (0, _context3.t1)(_context3.t2);\n\n            case 7:\n              _this._state.renNetwork = _context3.t0;\n\n              if (_this.params.from.renNetwork) {\n                _context3.next = 11;\n                break;\n              }\n\n              _context3.next = 11;\n              return _this.params.from.initialize(_this._state.renNetwork);\n\n            case 11:\n              if (_this.params.to.renNetwork) {\n                _context3.next = 14;\n                break;\n              }\n\n              _context3.next = 14;\n              return _this.params.to.initialize(_this._state.renNetwork);\n\n            case 14:\n              _context3.t3 = _this.params.to.getMintParams;\n\n              if (!_context3.t3) {\n                _context3.next = 19;\n                break;\n              }\n\n              _context3.next = 18;\n              return _this.params.to.getMintParams(_this.params.asset);\n\n            case 18:\n              _context3.t3 = _context3.sent;\n\n            case 19:\n              overwriteParams = _context3.t3;\n              _this.params = _objectSpread({}, overwriteParams, _this.params);\n              _context3.prev = 21;\n              _context3.next = 24;\n              return _this.generateGatewayAddress();\n\n            case 24:\n              _this.gatewayAddress = _context3.sent;\n              _context3.next = 30;\n              break;\n\n            case 27:\n              _context3.prev = 27;\n              _context3.t4 = _context3[\"catch\"](21);\n              throw _context3.t4;\n\n            case 30:\n              // Will fetch deposits as long as there's at least one deposit.\n              _this.wait().catch(console.error);\n\n              _context3.prev = 31;\n              _context3.next = 34;\n              return _this.confirmationTarget();\n\n            case 34:\n              _this._state.targetConfirmations = _context3.sent;\n              _context3.next = 40;\n              break;\n\n            case 37:\n              _context3.prev = 37;\n              _context3.t5 = _context3[\"catch\"](31);\n              console.error(_context3.t5);\n\n            case 40:\n              return _context3.abrupt(\"return\", _assertThisInitialized(_assertThisInitialized(_this)));\n\n            case 41:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[21, 27], [31, 37]]);\n    }));\n    /**\n     * `processDeposit` allows you to manually provide the details of a deposit\n     * and returns a [[LockAndMintDeposit]] object.\n     *\n     * @param deposit The deposit details in the format defined by the\n     * LockChain. This should be the same format as `deposit.depositDetails` for\n     * a deposit returned from `.on(\"deposit\", ...)`.\n     *\n     * ```ts\n     * lockAndMint\n     *   .processDeposit({\n     *       transaction: {\n     *           cid:\n     *               \"bafy2bzacedvu74e7ohjcwlh4fbx7ddf6li42fiuosajob6metcj2qwkgkgof2\",\n     *           to: \"t1v2ftlxhedyoijv7uqgxfygiziaqz23lgkvks77i\",\n     *           amount: (0.01 * 1e8).toString(),\n     *           params: \"EzGbvVHf8lb0v8CUfjh8y+tLbZzfIFcnNnt/gh6axmw=\",\n     *           confirmations: 1,\n     *           nonce: 7,\n     *       },\n     *       amount: (0.01 * 1e8).toString(),\n     *   })\n     *   .on(deposit => RenJS.defaultDepositHandler)\n     *   .catch(console.error);\n     * ```\n     *\n     * @category Main\n     */\n\n    _this.processDeposit =\n    /*#__PURE__*/\n    function () {\n      var _ref4 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(deposit) {\n        var depositID, depositObject;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!_this._state.renNetwork || !_this._state.pHash || !_this._state.gHash || !_this._state.gPubKey || !_this.gatewayAddress)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Gateway address must be generated before calling 'wait'.\");\n\n              case 2:\n                depositID = _this.params.from.transactionID(deposit.transaction);\n                depositObject = _this.deposits.get(depositID); // If the confidence has increased.\n\n                if (depositObject) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                depositObject = new LockAndMintDeposit(deposit, _this.params, _this.renVM, _objectSpread({}, _this._state, {\n                  renNetwork: _this._state.renNetwork,\n                  pHash: _this._state.pHash,\n                  gHash: _this._state.gHash,\n                  gPubKey: _this._state.gPubKey,\n                  targetConfirmations: isDefined(_this._state.targetConfirmations) ? _this._state.targetConfirmations : undefined\n                }));\n                _context4.next = 8;\n                return depositObject._initialize();\n\n              case 8:\n                // Check if deposit has already been submitted.\n                if (_this._state.config.loadCompletedDeposits || depositObject.status !== DepositStatus.Submitted) {\n                  _this.emit(\"deposit\", depositObject); // this.deposits.set(deposit);\n\n\n                  _this._state.logger.debug(\"new deposit:\", deposit);\n\n                  _this.deposits = _this.deposits.set(depositID, depositObject);\n                }\n\n              case 9:\n                return _context4.abrupt(\"return\", depositObject);\n\n              case 10:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x) {\n        return _ref4.apply(this, arguments);\n      };\n    }();\n\n    _this.addListener = function (event, listener) {\n      // Emit previous deposit events.\n      if (event === \"deposit\") {\n        _this.deposits.map(function (deposit) {\n          listener(deposit);\n        });\n      }\n\n      _get(_getPrototypeOf(LockAndMint.prototype), \"on\", _assertThisInitialized(_this)).call(_assertThisInitialized(_this), event, listener);\n\n      return _assertThisInitialized(_assertThisInitialized(_this));\n    };\n    /**\n     * `on` creates a new listener to `\"deposit\"` events, returning\n     * [[LockAndMintDeposit]] instances.\n     *\n     * `on` extends `EventEmitter.on`, modifying it to immediately return all\n     * previous `\"deposit\"` events, in addition to new events, when a new\n     * listener is created.\n     *\n     * @category Main\n     */\n\n\n    _this.on = function (event, listener) {\n      return _this.addListener(event, listener);\n    }; // Private methods /////////////////////////////////////////////////////////\n\n\n    _this.generateGatewayAddress =\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5() {\n      var _this$params, nonce, contractCalls, _contractCalls, contractParams, sendTo, tokenGatewayContract, gHash, gatewayAddress;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!_this.gatewayAddress) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", _this.gatewayAddress);\n\n            case 2:\n              _this$params = _this.params, nonce = _this$params.nonce, contractCalls = _this$params.contractCalls;\n\n              if (nonce) {\n                _context5.next = 5;\n                break;\n              }\n\n              throw new Error(\"Must call 'initialize' before calling 'generateGatewayAddress'.\");\n\n            case 5:\n              if (contractCalls) {\n                _context5.next = 7;\n                break;\n              }\n\n              throw new Error(\"Must provide contract call details.\");\n\n            case 7:\n              // Last contract call\n              _contractCalls = contractCalls[contractCalls.length - 1], contractParams = _contractCalls.contractParams, sendTo = _contractCalls.sendTo;\n\n              if (!(_this.renVM.version(_this._state.selector) >= 2)) {\n                _context5.next = 12;\n                break;\n              }\n\n              _context5.t0 = Ox(generateSHash(_this._state.selector));\n              _context5.next = 15;\n              break;\n\n            case 12:\n              _context5.next = 14;\n              return _this.params.to.resolveTokenGatewayContract(_this.params.asset);\n\n            case 14:\n              _context5.t0 = _context5.sent;\n\n            case 15:\n              tokenGatewayContract = _context5.t0;\n              _this._state.pHash = generatePHash(contractParams || [], _this._state.logger);\n              gHash = generateGHash(contractParams || [], sendTo, tokenGatewayContract, fromHex(nonce), _this.renVM.version(_this._state.selector) >= 2, _this._state.logger);\n              _this._state.gHash = gHash;\n              _context5.next = 21;\n              return _this.renVM.selectPublicKey(_this._state.selector, _this.renVM.version(_this._state.selector) >= 2 ? _this.params.from.name : _this.params.asset);\n\n            case 21:\n              _this._state.gPubKey = _context5.sent;\n\n              _this._state.logger.debug(\"gPubKey:\", Ox(_this._state.gPubKey));\n\n              _context5.next = 25;\n              return _this.params.from.getGatewayAddress(_this.params.asset, _this._state.gPubKey, gHash);\n\n            case 25:\n              gatewayAddress = _context5.sent;\n              _this.gatewayAddress = gatewayAddress;\n\n              _this._state.logger.debug(\"gateway address:\", _this.gatewayAddress);\n\n              return _context5.abrupt(\"return\", _this.gatewayAddress);\n\n            case 29:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    _this.wait =\n    /*#__PURE__*/\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8() {\n      var listenerCancelled, onDeposit, cancelDeposit;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              if (!(!_this._state.pHash || !_this._state.gHash || !_this._state.gPubKey || !_this.gatewayAddress)) {\n                _context8.next = 2;\n                break;\n              }\n\n              throw new Error(\"Gateway address must be generated before calling 'wait'.\");\n\n            case 2:\n              if (!true) {\n                _context8.next = 29;\n                break;\n              }\n\n              listenerCancelled = function listenerCancelled() {\n                return _this.listenerCount(\"deposit\") === 0;\n              };\n\n              _context8.prev = 4;\n\n              if (!listenerCancelled()) {\n                _context8.next = 9;\n                break;\n              }\n\n              _context8.next = 8;\n              return sleep(1 * SECONDS);\n\n            case 8:\n              return _context8.abrupt(\"continue\", 2);\n\n            case 9:\n              _context8.next = 14;\n              break;\n\n            case 11:\n              _context8.prev = 11;\n              _context8.t0 = _context8[\"catch\"](4);\n\n              _this._state.logger.error(extractError(_context8.t0));\n\n            case 14:\n              // Change the return type of `this.processDeposit` to `void`.\n              onDeposit =\n              /*#__PURE__*/\n              function () {\n                var _ref7 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee6(deposit) {\n                  return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                    while (1) {\n                      switch (_context6.prev = _context6.next) {\n                        case 0:\n                          _context6.next = 2;\n                          return _this.processDeposit(deposit);\n\n                        case 2:\n                        case \"end\":\n                          return _context6.stop();\n                      }\n                    }\n                  }, _callee6);\n                }));\n\n                return function onDeposit(_x2) {\n                  return _ref7.apply(this, arguments);\n                };\n              }(); // TODO: Flag deposits that have been cancelled, updating their status.\n\n\n              cancelDeposit =\n              /*#__PURE__*/\n              function () {\n                var _ref8 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee7() {\n                  return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          return _context7.abrupt(\"return\", Promise.resolve());\n\n                        case 1:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee7);\n                }));\n\n                return function cancelDeposit() {\n                  return _ref8.apply(this, arguments);\n                };\n              }();\n\n              _context8.prev = 16;\n              _context8.next = 19;\n              return _this.params.from.getDeposits(_this.params.asset, _this.gatewayAddress, _this.getDepositsProgress, onDeposit, cancelDeposit, listenerCancelled);\n\n            case 19:\n              _this.getDepositsProgress = _context8.sent;\n              _context8.next = 25;\n              break;\n\n            case 22:\n              _context8.prev = 22;\n              _context8.t1 = _context8[\"catch\"](16);\n\n              _this._state.logger.error(extractError(_context8.t1));\n\n            case 25:\n              _context8.next = 27;\n              return sleep(_this._state.config.networkDelay);\n\n            case 27:\n              _context8.next = 2;\n              break;\n\n            case 29:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8, null, [[4, 11], [16, 22]]);\n    }));\n    _this.params = params;\n    _this.renVM = renVM;\n    _this._state = {\n      logger: config.logger || NullLogger,\n      selector: _this.renVM.selector(_this.params),\n      config: _objectSpread({}, config, {\n        networkDelay: config.networkDelay || 15 * SECONDS\n      })\n    };\n    var txHash = _this.params.txHash; // Decode nonce or use empty nonce 0x0.\n\n    var nonce = _this.params.nonce ? fromHex(_this.params.nonce) : emptyNonce();\n    _this.params.nonce = nonce;\n\n    if (!txHash) {\n      _this.params.nonce = nonce;\n    }\n\n    {\n      // Debug log\n      var _this$params2 = _this.params,\n          _to = _this$params2.to,\n          _from = _this$params2.from,\n          restOfParams = _objectWithoutProperties(_this$params2, [\"to\", \"from\"]);\n\n      _this._state.logger.debug(\"lockAndMint created:\", restOfParams);\n    }\n    return _this;\n  }\n\n  return LockAndMint;\n}(EventEmitter);\nexport var DepositStatus;\n\n(function (DepositStatus) {\n  DepositStatus[\"Detected\"] = \"detected\";\n  DepositStatus[\"Confirmed\"] = \"confirmed\";\n  DepositStatus[\"Signed\"] = \"signed\";\n  DepositStatus[\"Reverted\"] = \"reverted\";\n  DepositStatus[\"Submitted\"] = \"submitted\";\n})(DepositStatus || (DepositStatus = {}));\n\nexport var DepositStatusIndex = (_DepositStatusIndex = {}, _defineProperty(_DepositStatusIndex, DepositStatus.Detected, 0), _defineProperty(_DepositStatusIndex, DepositStatus.Confirmed, 1), _defineProperty(_DepositStatusIndex, DepositStatus.Signed, 2), _defineProperty(_DepositStatusIndex, DepositStatus.Reverted, 3), _defineProperty(_DepositStatusIndex, DepositStatus.Submitted, 4), _DepositStatusIndex);\n/**\n * A LockAndMintDeposit represents a deposit that has been made to a gateway\n * address.\n *\n * Once it has been detected, the steps required to complete the mint are:\n * 1. Wait for the transaction to be mined. The number of confirmations here\n * depends on the asset.\n * 2. Submit the deposit to RenVM and wait for a signature.\n * 3. Submit the deposit to the lock-chain.\n *\n * Each of these steps can be performed using their respective methods. Each\n * of these return a PromiEvent, meaning that in addition to being a promise,\n * they also emit events that can be listened to.\n *\n * ```ts\n * await deposit.confirmed();\n * await deposit.signed();\n * await deposit.mint();\n * ```\n */\n\nexport var LockAndMintDeposit =\n/** @hidden */\nfunction LockAndMintDeposit(depositDetails, params, renVM, state) {\n  var _this2 = this;\n\n  _classCallCheck(this, LockAndMintDeposit);\n\n  /** @hidden */\n  this._initialize =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee9() {\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.next = 2;\n            return _this2.refreshStatus();\n\n          case 2:\n            _context9.next = 4;\n            return _this2.params.to.resolveTokenGatewayContract(_this2.params.asset);\n\n          case 4:\n            _this2._state.token = _context9.sent;\n            return _context9.abrupt(\"return\", _this2);\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9);\n  }));\n  /**\n   * `txHash` returns the RenVM transaction hash, which is distinct from the\n   * lock or mint chain transaction hashes. It can be used to query the\n   * lock-and-mint details from RenVM  once they've been submitted to it.\n   *\n   * The RenVM txHash is a URL-base64 string.\n   *\n   * ```ts\n   * deposit.txHash();\n   * // > \"QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI\"\n   * ```\n   */\n\n  this.txHash = function () {\n    // The type of `txHash` is a function instead of a string to match the\n    // interface of BurnAndRelease.\n    return _this2._state.txHash;\n  };\n  /**\n   * `queryTx` fetches the RenVM transaction details of the deposit.\n   *\n   * ```ts\n   * await deposit.queryTx();\n   * // > { to: \"...\", hash: \"...\", status: \"done\", in: {...}, out: {...} }\n   */\n\n\n  this.queryTx =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee10() {\n    var response;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            if (!(DepositStatusIndex[_this2.status] >= DepositStatusIndex[DepositStatus.Signed] && _this2._state.queryTxResult)) {\n              _context10.next = 2;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", _this2._state.queryTxResult);\n\n          case 2:\n            _context10.next = 4;\n            return _this2.renVM.queryMintOrBurn(_this2._state.selector, fromBase64(_this2.txHash()));\n\n          case 4:\n            response = _context10.sent;\n            _this2._state.queryTxResult = response; // Update status.\n\n            if (response.out && response.out.revert !== undefined) {\n              _this2.status = DepositStatus.Reverted;\n              _this2.revertReason = response.out.revert.toString();\n            } else if (response.out && response.out.signature) {\n              if (DepositStatusIndex[_this2.status] < DepositStatusIndex[DepositStatus.Signed]) {\n                _this2.status = DepositStatus.Signed;\n              }\n            }\n\n            return _context10.abrupt(\"return\", response);\n\n          case 8:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n  /**\n   * `refreshStatus` fetches the deposit's status on the mint-chain, RenVM\n   * and lock-chain to calculate it's [[DepositStatus]].\n   *\n   * ```ts\n   * await deposit.refreshStatus();\n   * // > \"signed\"\n   * ```\n   */\n\n  this.refreshStatus =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee12() {\n    var status;\n    return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n      while (1) {\n        switch (_context12.prev = _context12.next) {\n          case 0:\n            _context12.next = 2;\n            return _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee11() {\n              var queryTxResult, transaction, confirmations;\n              return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                while (1) {\n                  switch (_context11.prev = _context11.next) {\n                    case 0:\n                      _context11.prev = 0;\n                      _context11.next = 3;\n                      return _this2.queryTx();\n\n                    case 3:\n                      queryTxResult = _context11.sent;\n                      _context11.next = 9;\n                      break;\n\n                    case 6:\n                      _context11.prev = 6;\n                      _context11.t0 = _context11[\"catch\"](0);\n                      // Ignore error.\n                      queryTxResult = null;\n\n                    case 9:\n                      _context11.prev = 9;\n                      _context11.next = 12;\n                      return _this2.findTransaction();\n\n                    case 12:\n                      transaction = _context11.sent;\n\n                      if (!(transaction !== undefined)) {\n                        _context11.next = 15;\n                        break;\n                      }\n\n                      return _context11.abrupt(\"return\", DepositStatus.Submitted);\n\n                    case 15:\n                      _context11.next = 19;\n                      break;\n\n                    case 17:\n                      _context11.prev = 17;\n                      _context11.t1 = _context11[\"catch\"](9);\n\n                    case 19:\n                      _context11.prev = 19;\n\n                      if (!(queryTxResult === undefined)) {\n                        _context11.next = 26;\n                        break;\n                      }\n\n                      _context11.next = 23;\n                      return _this2.queryTx();\n\n                    case 23:\n                      _context11.t2 = _context11.sent;\n                      _context11.next = 27;\n                      break;\n\n                    case 26:\n                      _context11.t2 = queryTxResult;\n\n                    case 27:\n                      queryTxResult = _context11.t2;\n\n                      if (!(queryTxResult && queryTxResult.txStatus === TxStatus.TxStatusDone)) {\n                        _context11.next = 35;\n                        break;\n                      }\n\n                      if (!(queryTxResult.out && queryTxResult.out.revert !== undefined)) {\n                        _context11.next = 34;\n                        break;\n                      }\n\n                      _this2.status = DepositStatus.Reverted;\n                      _this2.revertReason = queryTxResult.out.revert.toString();\n                      _context11.next = 35;\n                      break;\n\n                    case 34:\n                      return _context11.abrupt(\"return\", DepositStatus.Signed);\n\n                    case 35:\n                      _context11.next = 39;\n                      break;\n\n                    case 37:\n                      _context11.prev = 37;\n                      _context11.t3 = _context11[\"catch\"](19);\n\n                    case 39:\n                      _context11.prev = 39;\n                      _context11.next = 42;\n                      return _this2.confirmations();\n\n                    case 42:\n                      confirmations = _context11.sent;\n\n                      if (!(confirmations.current >= confirmations.target)) {\n                        _context11.next = 45;\n                        break;\n                      }\n\n                      return _context11.abrupt(\"return\", DepositStatus.Confirmed);\n\n                    case 45:\n                      _context11.next = 49;\n                      break;\n\n                    case 47:\n                      _context11.prev = 47;\n                      _context11.t4 = _context11[\"catch\"](39);\n\n                    case 49:\n                      return _context11.abrupt(\"return\", DepositStatus.Detected);\n\n                    case 50:\n                    case \"end\":\n                      return _context11.stop();\n                  }\n                }\n              }, _callee11, null, [[0, 6], [9, 17], [19, 37], [39, 47]]);\n            }))();\n\n          case 2:\n            status = _context12.sent;\n            _this2.status = status;\n            return _context12.abrupt(\"return\", status);\n\n          case 5:\n          case \"end\":\n            return _context12.stop();\n        }\n      }\n    }, _callee12);\n  }));\n  /**\n   * `confirmations` returns the deposit's current and target number of\n   * confirmations on the lock-chain.\n   *\n   * ```ts\n   * await deposit\n   *  .confirmations();\n   * // > { current: 4, target: 6 }\n   * ```\n   */\n\n  this.confirmations =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee13() {\n    var _ref14, current, target;\n\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return _this2.params.from.transactionConfidence(_this2.depositDetails.transaction);\n\n          case 2:\n            _ref14 = _context13.sent;\n            current = _ref14.current;\n            target = _ref14.target;\n            return _context13.abrupt(\"return\", {\n              current: current,\n              target: isDefined(_this2._state.targetConfirmations) ? _this2._state.targetConfirmations : target\n            });\n\n          case 6:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  this.confirmationTarget =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee15() {\n    var target, getConfirmationTarget, defaultConfirmations;\n    return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            if (!isDefined(_this2._state.targetConfirmations)) {\n              _context15.next = 2;\n              break;\n            }\n\n            return _context15.abrupt(\"return\", _this2._state.targetConfirmations);\n\n          case 2:\n            getConfirmationTarget = _this2.renVM.getConfirmationTarget;\n\n            if (!getConfirmationTarget) {\n              _context15.next = 7;\n              break;\n            }\n\n            _context15.next = 6;\n            return retryNTimes(\n            /*#__PURE__*/\n            _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee14() {\n              return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n                while (1) {\n                  switch (_context14.prev = _context14.next) {\n                    case 0:\n                      return _context14.abrupt(\"return\", getConfirmationTarget(_this2._state.selector, _this2.params.from));\n\n                    case 1:\n                    case \"end\":\n                      return _context14.stop();\n                  }\n                }\n              }, _callee14);\n            })), 2);\n\n          case 6:\n            target = _context15.sent;\n\n          case 7:\n            defaultConfirmations = _this2._state.renNetwork && _this2._state.renNetwork.isTestnet ? 2 : 6;\n            _this2._state.targetConfirmations = isDefined(target) ? target : defaultConfirmations;\n            return _context15.abrupt(\"return\", _this2._state.targetConfirmations);\n\n          case 10:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  /**\n   * `confirmed` will return once the deposit has reached the target number of\n   * confirmations.\n   *\n   * It returns a PromiEvent which emits a `\"confirmation\"` event with the\n   * current and target number of confirmations as the event parameters.\n   *\n   * The events emitted by the PromiEvent are:\n   * 1. `\"confirmation\"` - called when a new confirmation is seen\n   * 2. `\"target\"` - called immediately to make the target confirmations\n   * available.\n   *\n   * ```ts\n   * await deposit\n   *  .confirmed()\n   *  .on(\"target\", (target) => console.log(`Waiting for ${target} confirmations`))\n   *  .on(\"confirmation\", (confs, target) => console.log(`${confs}/${target}`))\n   * ```\n   *\n   * @category Main\n   */\n\n  this.confirmed = function () {\n    var promiEvent = newPromiEvent();\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee16() {\n      var transactionIsConfirmed, iterationCount, currentConfidenceRatio, confidence, confidenceRatio;\n      return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.prev = 0;\n              _context16.t0 = promiEvent;\n              _context16.next = 4;\n              return _this2.confirmationTarget();\n\n            case 4:\n              _context16.t1 = _context16.sent;\n\n              _context16.t0.emit.call(_context16.t0, \"target\", _context16.t1);\n\n              _context16.next = 11;\n              break;\n\n            case 8:\n              _context16.prev = 8;\n              _context16.t2 = _context16[\"catch\"](0);\n\n              _this2._state.logger.error(_context16.t2);\n\n            case 11:\n              // If the transaction has been confirmed according to RenVM, return.\n              transactionIsConfirmed = function transactionIsConfirmed() {\n                return DepositStatusIndex[_this2.status] >= DepositStatusIndex[DepositStatus.Confirmed] || _this2._state.queryTxResult && TxStatusIndex[_this2._state.queryTxResult.txStatus] >= TxStatusIndex[TxStatus.TxStatusPending];\n              };\n\n              iterationCount = 0;\n              currentConfidenceRatio = 0; // Continue while the transaction isn't confirmed and the promievent\n              // isn't cancelled.\n\n            case 14:\n              if (!(!promiEvent._isCancelled() && !transactionIsConfirmed())) {\n                _context16.next = 48;\n                break;\n              }\n\n              if (!(iterationCount % 5 === 0)) {\n                _context16.next = 29;\n                break;\n              }\n\n              _context16.prev = 16;\n\n              if (_this2._state.renTxSubmitted) {\n                _context16.next = 20;\n                break;\n              }\n\n              _context16.next = 20;\n              return _this2._submitMintTransaction();\n\n            case 20:\n              _context16.next = 22;\n              return _this2.queryTx();\n\n            case 22:\n              if (!transactionIsConfirmed()) {\n                _context16.next = 24;\n                break;\n              }\n\n              return _context16.abrupt(\"break\", 48);\n\n            case 24:\n              _context16.next = 29;\n              break;\n\n            case 26:\n              _context16.prev = 26;\n              _context16.t3 = _context16[\"catch\"](16);\n\n              // Ignore error.\n              _this2._state.logger.debug(_context16.t3);\n\n            case 29:\n              _context16.prev = 29;\n              _context16.next = 32;\n              return _this2.confirmations();\n\n            case 32:\n              confidence = _context16.sent;\n              confidenceRatio = confidence.target === 0 ? 1 : confidence.current / confidence.target;\n\n              if (confidenceRatio > currentConfidenceRatio) {\n                currentConfidenceRatio = confidenceRatio;\n                promiEvent.emit(\"confirmation\", confidence.current, confidence.target);\n              }\n\n              if (!(confidenceRatio >= 1)) {\n                _context16.next = 37;\n                break;\n              }\n\n              return _context16.abrupt(\"break\", 48);\n\n            case 37:\n              _this2._state.logger.debug(\"deposit confidence: \".concat(confidence.current, \" / \").concat(confidence.target));\n\n              _context16.next = 43;\n              break;\n\n            case 40:\n              _context16.prev = 40;\n              _context16.t4 = _context16[\"catch\"](29);\n\n              _this2._state.logger.error(\"Error fetching transaction confidence: \".concat(extractError(_context16.t4)));\n\n            case 43:\n              _context16.next = 45;\n              return sleep(_this2._state.config.networkDelay);\n\n            case 45:\n              iterationCount += 1;\n              _context16.next = 14;\n              break;\n\n            case 48:\n              // Update status.\n              if (DepositStatusIndex[_this2.status] < DepositStatusIndex[DepositStatus.Confirmed]) {\n                _this2.status = DepositStatus.Confirmed;\n              }\n\n              return _context16.abrupt(\"return\", _this2);\n\n            case 50:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, _callee16, null, [[0, 8], [16, 26], [29, 40]]);\n    }))().then(promiEvent.resolve).catch(promiEvent.reject);\n\n    return promiEvent;\n  };\n  /**\n   * `signed` waits for RenVM's signature to be available.\n   *\n   * It returns a PromiEvent which emits a `\"txHash\"` event with the deposit's\n   * RenVM txHash (aka Transaction ID).\n   *\n   * ```ts\n   * await deposit\n   *  .signed()\n   *  .on(\"txHash\", (txHash) => console.log(txHash))\n   * ```\n   *\n   * The events emitted by the PromiEvent are:\n   * 1. `txHash` - the RenVM transaction hash of the deposit.\n   * 2. `status` - the RenVM status of the transaction, of type [[TxStatus]].\n   *\n   * @category Main\n   */\n\n\n  this.signed = function () {\n    var promiEvent = newPromiEvent();\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee18() {\n      var txHash, queryTxResponse, submitted, response;\n      return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              txHash = _this2.txHash(); // If the transaction has been reverted, throw the revert reason.\n\n              if (!(_this2.status === DepositStatus.Reverted)) {\n                _context18.next = 3;\n                break;\n              }\n\n              throw new Error(_this2.revertReason || \"RenVM transaction \".concat(txHash, \" reverted.\"));\n\n            case 3:\n              if (!(DepositStatusIndex[_this2.status] >= DepositStatusIndex[DepositStatus.Signed] && _this2._state.queryTxResult && _this2._state.queryTxResult.out)) {\n                _context18.next = 5;\n                break;\n              }\n\n              return _context18.abrupt(\"return\", _this2);\n\n            case 5:\n              promiEvent.emit(\"txHash\", txHash);\n\n              _this2._state.logger.debug(\"RenVM txHash:\", txHash); // Try to submit to RenVM. If that fails, see if they already\n              // know about the transaction.\n\n\n              _context18.prev = 7;\n              _context18.next = 10;\n              return _this2._submitMintTransaction();\n\n            case 10:\n              txHash = _context18.sent;\n              _context18.next = 41;\n              break;\n\n            case 13:\n              _context18.prev = 13;\n              _context18.t0 = _context18[\"catch\"](7);\n              _context18.prev = 15;\n              _context18.next = 18;\n              return _this2.queryTx();\n\n            case 18:\n              queryTxResponse = _context18.sent;\n\n              if (!(queryTxResponse.txStatus === TxStatus.TxStatusNil)) {\n                _context18.next = 21;\n                break;\n              }\n\n              throw new Error(\"Transaction \".concat(txHash, \" has not been submitted previously.\"));\n\n            case 21:\n              txHash = queryTxResponse.hash;\n              _context18.next = 41;\n              break;\n\n            case 24:\n              _context18.prev = 24;\n              _context18.t1 = _context18[\"catch\"](15);\n              submitted = false; // If transaction is not found, check for RenVM v0.2 error message.\n\n              if (!(_context18.t1.code === RenJSErrors.RenVMTransactionNotFound)) {\n                _context18.next = 38;\n                break;\n              }\n\n              if (!(_context18.t0.code === RenJSErrors.AmountTooSmall || _context18.t0.code === RenJSErrors.DepositSpentOrNotFound)) {\n                _context18.next = 34;\n                break;\n              }\n\n              _this2.status = DepositStatus.Reverted;\n              _this2.revertReason = String((_context18.t0 || {}).message).replace(/Node returned status \\d+ with reason: /, \"\");\n              throw new Error(_this2.revertReason);\n\n            case 34:\n              _context18.next = 36;\n              return retryNTimes(\n              /*#__PURE__*/\n              _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee17() {\n                return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n                  while (1) {\n                    switch (_context17.prev = _context17.next) {\n                      case 0:\n                        return _context17.abrupt(\"return\", _this2._submitMintTransaction());\n\n                      case 1:\n                      case \"end\":\n                        return _context17.stop();\n                    }\n                  }\n                }, _callee17);\n              })), 2, 5 * SECONDS);\n\n            case 36:\n              txHash = _context18.sent;\n              submitted = true;\n\n            case 38:\n              // Ignore errorInner.\n              _this2._state.logger.debug(_context18.t1);\n\n              if (submitted) {\n                _context18.next = 41;\n                break;\n              }\n\n              throw _context18.t0;\n\n            case 41:\n              _context18.next = 43;\n              return _this2.renVM.waitForTX(_this2._state.selector, fromBase64(txHash), function (status) {\n                promiEvent.emit(\"status\", status);\n\n                _this2._state.logger.debug(\"transaction status:\", status);\n              }, function () {\n                return promiEvent._isCancelled();\n              }, _this2._state.config.networkDelay);\n\n            case 43:\n              response = _context18.sent;\n              _this2._state.queryTxResult = response; // Update status.\n\n              if (!(response.out && response.out.revert !== undefined)) {\n                _context18.next = 51;\n                break;\n              }\n\n              _this2.status = DepositStatus.Reverted;\n              _this2.revertReason = response.out.revert.toString();\n              throw new Error(_this2.revertReason);\n\n            case 51:\n              if (response.out && response.out.signature) {\n                if (DepositStatusIndex[_this2.status] < DepositStatusIndex[DepositStatus.Signed]) {\n                  _this2.status = DepositStatus.Signed;\n                }\n\n                _this2._state.logger.debug(\"signature:\", response.out && response.out.signature);\n              }\n\n            case 52:\n              return _context18.abrupt(\"return\", _this2);\n\n            case 53:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, _callee18, null, [[7, 13], [15, 24]]);\n    }))().then(promiEvent.resolve).catch(promiEvent.reject);\n\n    return promiEvent;\n  };\n  /**\n   * `findTransaction` checks if the deposit signature has already been\n   * submitted to the mint chain.\n   *\n   * ```ts\n   * await deposit.findTransaction();\n   * // > \"0x1234\" // (or undefined)\n   * ```\n   */\n\n\n  this.findTransaction =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee19() {\n    var sigHash;\n    return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n      while (1) {\n        switch (_context19.prev = _context19.next) {\n          case 0:\n            sigHash = _this2._state.queryTxResult && _this2._state.queryTxResult.out && _this2._state.queryTxResult.out.revert === undefined ? _this2._state.queryTxResult.out.sighash : undefined; // Check if the signature has already been submitted\n\n            _context19.next = 3;\n            return _this2.params.to.findTransaction(_this2.params.asset, _this2._state.nHash, sigHash);\n\n          case 3:\n            _this2.mintTransaction = _context19.sent;\n            return _context19.abrupt(\"return\", _this2.mintTransaction);\n\n          case 5:\n          case \"end\":\n            return _context19.stop();\n        }\n      }\n    }, _callee19);\n  }));\n  /**\n   * `mint` submits the RenVM signature to the mint chain.\n   *\n   * It returns a PromiEvent and the events emitted depend on the mint chain.\n   *\n   * The PromiEvent's events are defined by the mint-chain implementation. For\n   * Ethereum, it emits the same events as a Web3 PromiEvent.\n   *\n   * @category Main\n   */\n\n  this.mint = function (override) {\n    var promiEvent = newPromiEvent();\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee20() {\n      var overrideArray, contractCalls, asset;\n      return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              if (_this2._state.queryTxResult) {\n                _context20.next = 2;\n                break;\n              }\n\n              throw new Error(\"Unable to submit to Ethereum without signature. Call 'signed' first.\");\n\n            case 2:\n              overrideArray = Object.keys(override || {}).map(function (key) {\n                return {\n                  name: key,\n                  value: (override || {})[key]\n                };\n              }); // Override contract call parameters that have been passed in to\n              // \"mint\".\n\n              contractCalls = overrideContractCalls(_this2.params.contractCalls || [], {\n                contractParams: overrideArray\n              }); // Filter parameters that should be included in the payload hash but\n              // not the contract call.\n\n              contractCalls = contractCalls.map(function (call) {\n                return _objectSpread({}, call, {\n                  contractParams: call.contractParams ? call.contractParams.filter(function (param) {\n                    return !param.onlyInPayload;\n                  }) : call.contractParams\n                });\n              });\n              asset = _this2.params.asset;\n              _context20.next = 8;\n              return _this2.params.to.submitMint(asset, contractCalls, _this2._state.queryTxResult, promiEvent);\n\n            case 8:\n              _this2.mintTransaction = _context20.sent;\n              // Update status.\n              _this2.status = DepositStatus.Submitted;\n              return _context20.abrupt(\"return\", _this2.mintTransaction);\n\n            case 11:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n      }, _callee20);\n    }))().then(promiEvent.resolve).catch(promiEvent.reject);\n\n    return promiEvent;\n  }; // Private methods /////////////////////////////////////////////////////////\n\n  /**\n   * `_submitMintTransaction` will create the RebVN mint transaction and return\n   * its txHash. If `config.submit` is true, it will also submit it to RenVM.\n   *\n   * Note that `_submitMintTransaction`'s return type changes from `string` to\n   * `Promise<string>` if `config.submit` is true. This may be split up into\n   * two methods in the future to avoid this weirdness - likely once the `v1`\n   * RPC format is phased out.\n   *\n   * @param config Set `config.submit` to `true` to submit the transaction.\n   */\n\n\n  this._submitMintTransaction =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee21() {\n    var token, expectedTxHash, encodedHash, returnedTxHash;\n    return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n      while (1) {\n        switch (_context21.prev = _context21.next) {\n          case 0:\n            token = _this2._state.token;\n\n            if (token) {\n              _context21.next = 3;\n              break;\n            }\n\n            throw new Error(\"Deposit object must be initialized.\");\n\n          case 3:\n            expectedTxHash = _this2.txHash(); // Return if the transaction has already been successfully submitted.\n\n            if (!_this2._state.renTxSubmitted) {\n              _context21.next = 6;\n              break;\n            }\n\n            return _context21.abrupt(\"return\", expectedTxHash);\n\n          case 6:\n            if (!_this2._state.renTxSubmitted) {\n              _context21.next = 8;\n              break;\n            }\n\n            return _context21.abrupt(\"return\", expectedTxHash);\n\n          case 8:\n            _context21.next = 10;\n            return _this2.renVM.submitMint(_objectSpread({}, _this2._state, {\n              token: token\n            }));\n\n          case 10:\n            encodedHash = _context21.sent;\n            returnedTxHash = _this2.renVM.version(_this2._state.selector) >= 2 ? toURLBase64(encodedHash) : toBase64(encodedHash); // Indicate that the tx has been submitted successfully.\n\n            _this2._state.renTxSubmitted = true;\n\n            if (returnedTxHash !== expectedTxHash) {\n              _this2._state.logger.warn(\"Unexpected txHash returned from RenVM. Received: \".concat(returnedTxHash, \", expected: \").concat(expectedTxHash));\n            }\n\n            _this2._state.renTxSubmitted = true;\n            return _context21.abrupt(\"return\", returnedTxHash);\n\n          case 16:\n          case \"end\":\n            return _context21.stop();\n        }\n      }\n    }, _callee21);\n  }));\n\n  this.validateParams = function () {\n    assertObject({\n      from: \"object\",\n      to: \"object\",\n      contractCalls: \"any[]\",\n      asset: \"string\",\n      txHash: \"string | undefined\",\n      nonce: \"Buffer | string | undefined\",\n      tags: \"string[] | undefined\"\n    }, {\n      params: _this2.params\n    });\n\n    if (_this2.params.contractCalls) {\n      _this2.params.contractCalls.map(function (contractCall) {\n        assertType(\"string\", {\n          sendTo: contractCall.sendTo,\n          contractFn: contractCall.contractFn\n        });\n      });\n    }\n  };\n\n  assertObject({\n    transaction: \"any\",\n    amount: \"string\"\n  }, {\n    depositDetails: depositDetails\n  });\n  assertObject({\n    selector: \"string\",\n    logger: \"object\",\n    renNetwork: \"object\",\n    gPubKey: \"Buffer\",\n    gHash: \"Buffer\",\n    pHash: \"Buffer\",\n    targetConfirmations: \"number | undefined\",\n    config: \"object\"\n  }, {\n    state: state\n  });\n  this.depositDetails = depositDetails;\n  this.params = params;\n  this.renVM = renVM; // this._state = state;\n  // `processDeposit` will call `refreshStatus` which will set the proper\n  // status.\n\n  this.status = DepositStatus.Detected;\n  var _this$params3 = this.params,\n      txHash = _this$params3.txHash,\n      contractCalls = _this$params3.contractCalls,\n      nonce = _this$params3.nonce;\n\n  if (!nonce) {\n    throw new Error(\"No nonce passed in to LockAndMintDeposit.\");\n  }\n\n  if (!txHash && (!contractCalls || !contractCalls.length)) {\n    throw new Error(\"Must provide Ren transaction hash or contract call details.\");\n  }\n\n  this.validateParams();\n  var deposit = this.depositDetails;\n  var providedTxHash = this.params.txHash ? renVMHashToBase64(this.params.txHash, this.renVM.version(state.selector) >= 2) : undefined;\n\n  if (!nonce) {\n    throw new Error(\"Unable to submit to RenVM without nonce.\");\n  }\n\n  if (!contractCalls || !contractCalls.length) {\n    throw new Error(\"Unable to submit to RenVM without contract call details.\");\n  } // Last contract call\n\n\n  var _contractCalls2 = contractCalls[contractCalls.length - 1],\n      contractParams = _contractCalls2.contractParams,\n      sendTo = _contractCalls2.sendTo,\n      contractFn = _contractCalls2.contractFn;\n  var filteredContractParams = contractParams ? contractParams.filter(function (contractParam) {\n    return !contractParam.notInPayload;\n  }) : contractParams;\n  var encodedParameters = new AbiCoder().encodeParameters((filteredContractParams || []).map(function (i) {\n    return i.type;\n  }), (filteredContractParams || []).map(function (i) {\n    return i.value;\n  }));\n\n  if (this.params.tags && this.params.tags.length > 1) {\n    throw new Error(\"Providing multiple tags is not supported yet.\");\n  }\n\n  var pHash = state.pHash;\n  var transactionDetails = this.params.from.transactionRPCFormat(this.depositDetails.transaction, renVM.version(state.selector) >= 2);\n  var nHash = generateNHash(fromHex(nonce), transactionDetails.txid, transactionDetails.txindex, renVM.version(state.selector) >= 2);\n  var outputHashFormat = renVM.version(state.selector) >= 2 ? \"\" : this.params.from.depositV1HashString(deposit);\n  var fnABI = payloadToMintABI(contractFn, filteredContractParams || []);\n  var tags = this.params.tags && this.params.tags.length ? [this.params.tags[0]] : [];\n  this._state = _objectSpread({}, state, {\n    // gHash\n    // gPubKey\n    nHash: nHash,\n    nonce: fromHex(nonce),\n    output: this.params.from.transactionRPCFormat(deposit.transaction, renVM.version(state.selector) >= 2),\n    amount: deposit.amount,\n    payload: fromHex(encodedParameters),\n    pHash: pHash,\n    to: renVM.version(state.selector) >= 2 ? strip0x(sendTo) : Ox(sendTo),\n    fn: contractFn,\n    fnABI: fnABI,\n    tags: tags,\n    // Will be set in the next statement.\n    txHash: \"\",\n    renTxSubmitted: false\n  });\n  this._state.txHash = (renVM.version(this._state.selector) >= 2 ? toURLBase64 : toBase64)(this.renVM.mintTxHash(_objectSpread({}, this._state, {\n    outputHashFormat: outputHashFormat\n  })));\n\n  if (providedTxHash && !fromBase64(providedTxHash).equals(fromBase64(this.txHash()))) {\n    throw new Error(\"Inconsistent RenVM transaction hash: got \".concat(providedTxHash, \" but expected \").concat(this.txHash(), \".\"));\n  }\n\n  {\n    // Debug log\n    var _this$params4 = this.params,\n        _to = _this$params4.to,\n        _from = _this$params4.from,\n        restOfParams = _objectWithoutProperties(_this$params4, [\"to\", \"from\"]);\n\n    this._state.logger.debug(\"LockAndMintDeposit created\", depositDetails, restOfParams);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}