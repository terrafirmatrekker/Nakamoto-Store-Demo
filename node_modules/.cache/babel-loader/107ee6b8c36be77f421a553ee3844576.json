{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar BlockHeader = require('./blockheader');\n\nvar BufferUtil = require('../util/buffer');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar Hash = require('../crypto/hash');\n\nvar JSUtil = require('../util/js');\n\nvar Transaction = require('../transaction');\n\nvar $ = require('../util/preconditions');\n/**\n * Instantiate a MerkleBlock from a Buffer, JSON object, or Object with\n * the properties of the Block\n *\n * @param {*} - A Buffer, JSON string, or Object representing a MerkleBlock\n * @returns {MerkleBlock}\n * @constructor\n */\n\n\nfunction MerkleBlock(arg) {\n  /* jshint maxstatements: 18 */\n  if (!(this instanceof MerkleBlock)) {\n    return new MerkleBlock(arg);\n  }\n\n  var info = {};\n\n  if (BufferUtil.isBuffer(arg)) {\n    info = MerkleBlock._fromBufferReader(BufferReader(arg));\n  } else if (_.isObject(arg)) {\n    var header;\n\n    if (arg.header instanceof BlockHeader) {\n      header = arg.header;\n    } else {\n      header = BlockHeader.fromObject(arg.header);\n    }\n\n    info = {\n      /**\n       * @name MerkleBlock#header\n       * @type {BlockHeader}\n       */\n      header: header,\n\n      /**\n       * @name MerkleBlock#numTransactions\n       * @type {Number}\n       */\n      numTransactions: arg.numTransactions,\n\n      /**\n       * @name MerkleBlock#hashes\n       * @type {String[]}\n       */\n      hashes: arg.hashes,\n\n      /**\n       * @name MerkleBlock#flags\n       * @type {Number[]}\n       */\n      flags: arg.flags\n    };\n  } else {\n    throw new TypeError('Unrecognized argument for MerkleBlock');\n  }\n\n  _.extend(this, info);\n\n  this._flagBitsUsed = 0;\n  this._hashesUsed = 0;\n  return this;\n}\n/**\n * @param {Buffer} - MerkleBlock data in a Buffer object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\n\n\nMerkleBlock.fromBuffer = function fromBuffer(buf) {\n  return MerkleBlock.fromBufferReader(BufferReader(buf));\n};\n/**\n * @param {BufferReader} - MerkleBlock data in a BufferReader object\n * @returns {MerkleBlock} - A MerkleBlock object\n */\n\n\nMerkleBlock.fromBufferReader = function fromBufferReader(br) {\n  return new MerkleBlock(MerkleBlock._fromBufferReader(br));\n};\n/**\n * @returns {Buffer} - A buffer of the block\n */\n\n\nMerkleBlock.prototype.toBuffer = function toBuffer() {\n  return this.toBufferWriter().concat();\n};\n/**\n * @param {BufferWriter} - An existing instance of BufferWriter\n * @returns {BufferWriter} - An instance of BufferWriter representation of the MerkleBlock\n */\n\n\nMerkleBlock.prototype.toBufferWriter = function toBufferWriter(bw) {\n  if (!bw) {\n    bw = new BufferWriter();\n  }\n\n  bw.write(this.header.toBuffer());\n  bw.writeUInt32LE(this.numTransactions);\n  bw.writeVarintNum(this.hashes.length);\n\n  for (var i = 0; i < this.hashes.length; i++) {\n    bw.write(new Buffer(this.hashes[i], 'hex'));\n  }\n\n  bw.writeVarintNum(this.flags.length);\n\n  for (i = 0; i < this.flags.length; i++) {\n    bw.writeUInt8(this.flags[i]);\n  }\n\n  return bw;\n};\n/**\n * @returns {Object} - A plain object with the MerkleBlock properties\n */\n\n\nMerkleBlock.prototype.toObject = MerkleBlock.prototype.toJSON = function toObject() {\n  return {\n    header: this.header.toObject(),\n    numTransactions: this.numTransactions,\n    hashes: this.hashes,\n    flags: this.flags\n  };\n};\n/**\n * Verify that the MerkleBlock is valid\n * @returns {Boolean} - True/False whether this MerkleBlock is Valid\n */\n\n\nMerkleBlock.prototype.validMerkleTree = function validMerkleTree() {\n  $.checkState(_.isArray(this.flags), 'MerkleBlock flags is not an array');\n  $.checkState(_.isArray(this.hashes), 'MerkleBlock hashes is not an array'); // Can't have more hashes than numTransactions\n\n  if (this.hashes.length > this.numTransactions) {\n    return false;\n  } // Can't have more flag bits than num hashes\n\n\n  if (this.flags.length * 8 < this.hashes.length) {\n    return false;\n  }\n\n  var height = this._calcTreeHeight();\n\n  var opts = {\n    hashesUsed: 0,\n    flagBitsUsed: 0\n  };\n\n  var root = this._traverseMerkleTree(height, 0, opts);\n\n  if (opts.hashesUsed !== this.hashes.length) {\n    return false;\n  }\n\n  return BufferUtil.equals(root, this.header.merkleRoot);\n};\n/**\n * Traverse a the tree in this MerkleBlock, validating it along the way\n * Modeled after Bitcoin Core merkleblock.cpp TraverseAndExtract()\n * @param {Number} - depth - Current height\n * @param {Number} - pos - Current position in the tree\n * @param {Object} - opts - Object with values that need to be mutated throughout the traversal\n * @param {Number} - opts.flagBitsUsed - Number of flag bits used, should start at 0\n * @param {Number} - opts.hashesUsed - Number of hashes used, should start at 0\n * @param {Array} - opts.txs - Will finish populated by transactions found during traversal\n * @returns {Buffer|null} - Buffer containing the Merkle Hash for that height\n * @private\n */\n\n\nMerkleBlock.prototype._traverseMerkleTree = function traverseMerkleTree(depth, pos, opts) {\n  /* jshint maxcomplexity:  12*/\n\n  /* jshint maxstatements: 20 */\n  opts = opts || {};\n  opts.txs = opts.txs || [];\n  opts.flagBitsUsed = opts.flagBitsUsed || 0;\n  opts.hashesUsed = opts.hashesUsed || 0;\n\n  if (opts.flagBitsUsed > this.flags.length * 8) {\n    return null;\n  }\n\n  var isParentOfMatch = this.flags[opts.flagBitsUsed >> 3] >>> (opts.flagBitsUsed++ & 7) & 1;\n\n  if (depth === 0 || !isParentOfMatch) {\n    if (opts.hashesUsed >= this.hashes.length) {\n      return null;\n    }\n\n    var hash = this.hashes[opts.hashesUsed++];\n\n    if (depth === 0 && isParentOfMatch) {\n      opts.txs.push(hash);\n    }\n\n    return new Buffer(hash, 'hex');\n  } else {\n    var left = this._traverseMerkleTree(depth - 1, pos * 2, opts);\n\n    var right = left;\n\n    if (pos * 2 + 1 < this._calcTreeWidth(depth - 1)) {\n      right = this._traverseMerkleTree(depth - 1, pos * 2 + 1, opts);\n    }\n\n    return Hash.sha256sha256(new Buffer.concat([left, right]));\n  }\n};\n/** Calculates the width of a merkle tree at a given height.\n *  Modeled after Bitcoin Core merkleblock.h CalcTreeWidth()\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Width of the tree at a given height\n * @private\n */\n\n\nMerkleBlock.prototype._calcTreeWidth = function calcTreeWidth(height) {\n  return this.numTransactions + (1 << height) - 1 >> height;\n};\n/** Calculates the height of the merkle tree in this MerkleBlock\n * @param {Number} - Height at which we want the tree width\n * @returns {Number} - Height of the merkle tree in this MerkleBlock\n * @private\n */\n\n\nMerkleBlock.prototype._calcTreeHeight = function calcTreeHeight() {\n  var height = 0;\n\n  while (this._calcTreeWidth(height) > 1) {\n    height++;\n  }\n\n  return height;\n};\n/**\n * @param {Transaction|String} - Transaction or Transaction ID Hash\n * @returns {Boolean} - return true/false if this MerkleBlock has the TX or not\n * @private\n */\n\n\nMerkleBlock.prototype.hasTransaction = function hasTransaction(tx) {\n  $.checkArgument(!_.isUndefined(tx), 'tx cannot be undefined');\n  $.checkArgument(tx instanceof Transaction || typeof tx === 'string', 'Invalid tx given, tx must be a \"string\" or \"Transaction\"');\n  var hash = tx;\n\n  if (tx instanceof Transaction) {\n    // We need to reverse the id hash for the lookup\n    hash = BufferUtil.reverse(new Buffer(tx.id, 'hex')).toString('hex');\n  }\n\n  var txs = [];\n\n  var height = this._calcTreeHeight();\n\n  this._traverseMerkleTree(height, 0, {\n    txs: txs\n  });\n\n  return txs.indexOf(hash) !== -1;\n};\n/**\n * @param {Buffer} - MerkleBlock data\n * @returns {Object} - An Object representing merkleblock data\n * @private\n */\n\n\nMerkleBlock._fromBufferReader = function _fromBufferReader(br) {\n  $.checkState(!br.finished(), 'No merkleblock data received');\n  var info = {};\n  info.header = BlockHeader.fromBufferReader(br);\n  info.numTransactions = br.readUInt32LE();\n  var numHashes = br.readVarintNum();\n  info.hashes = [];\n\n  for (var i = 0; i < numHashes; i++) {\n    info.hashes.push(br.read(32).toString('hex'));\n  }\n\n  var numFlags = br.readVarintNum();\n  info.flags = [];\n\n  for (i = 0; i < numFlags; i++) {\n    info.flags.push(br.readUInt8());\n  }\n\n  return info;\n};\n/**\n * @param {Object} - A plain JavaScript object\n * @returns {Block} - An instance of block\n */\n\n\nMerkleBlock.fromObject = function fromObject(obj) {\n  return new MerkleBlock(obj);\n};\n\nmodule.exports = MerkleBlock;","map":null,"metadata":{},"sourceType":"script"}