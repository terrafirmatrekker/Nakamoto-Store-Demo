{"ast":null,"code":"/*\n\tJavaScript BigInteger library version 0.9.1\n\thttp://silentmatt.com/biginteger/\n\tCopyright (c) 2009 Matthew Crumley <email@matthewcrumley.com>\n\tCopyright (c) 2010,2011 by John Tobey <John.Tobey@gmail.com>\n\tLicensed under the MIT license.\n\tSupport for arbitrary internal representation base was added by\n\tVitaly Magerya.\n*/\n\n/*\n\tFile: biginteger.js\n\tExports:\n\t\t<BigInteger>\n*/\n(function (exports) {\n  \"use strict\";\n  /*\n      Class: BigInteger\n      An arbitrarily-large integer.\n      <BigInteger> objects should be considered immutable. None of the \"built-in\"\n      methods modify *this* or their arguments. All properties should be\n      considered private.\n      All the methods of <BigInteger> instances can be called \"statically\". The\n      static versions are convenient if you don't already have a <BigInteger>\n      object.\n      As an example, these calls are equivalent.\n      > BigInteger(4).multiply(5); // returns BigInteger(20);\n      > BigInteger.multiply(4, 5); // returns BigInteger(20);\n      > var a = 42;\n      > var a = BigInteger.toJSValue(\"0b101010\"); // Not completely useless...\n  */\n\n  var CONSTRUCT = {}; // Unique token to call \"private\" version of constructor\n\n  /*\n      Constructor: BigInteger()\n      Convert a value to a <BigInteger>.\n      Although <BigInteger()> is the constructor for <BigInteger> objects, it is\n      best not to call it as a constructor. If *n* is a <BigInteger> object, it is\n      simply returned as-is. Otherwise, <BigInteger()> is equivalent to <parse>\n      without a radix argument.\n      > var n0 = BigInteger();      // Same as <BigInteger.ZERO>\n      > var n1 = BigInteger(\"123\"); // Create a new <BigInteger> with value 123\n      > var n2 = BigInteger(123);   // Create a new <BigInteger> with value 123\n      > var n3 = BigInteger(n2);    // Return n2, unchanged\n      The constructor form only takes an array and a sign. *n* must be an\n      array of numbers in little-endian order, where each digit is between 0\n      and BigInteger.base.  The second parameter sets the sign: -1 for\n      negative, +1 for positive, or 0 for zero. The array is *not copied and\n      may be modified*. If the array contains only zeros, the sign parameter\n      is ignored and is forced to zero.\n      > new BigInteger([5], -1): create a new BigInteger with value -5\n      Parameters:\n          n - Value to convert to a <BigInteger>.\n      Returns:\n          A <BigInteger> value.\n      See Also:\n          <parse>, <BigInteger>\n  */\n\n  function BigInteger(n, s, token) {\n    if (token !== CONSTRUCT) {\n      if (n instanceof BigInteger) {\n        return n;\n      } else if (typeof n === \"undefined\") {\n        return ZERO;\n      }\n\n      return BigInteger.parse(n);\n    }\n\n    n = n || []; // Provide the nullary constructor for subclasses.\n\n    while (n.length && !n[n.length - 1]) {\n      --n.length;\n    }\n\n    this._d = n;\n    this._s = n.length ? s || 1 : 0;\n  }\n\n  BigInteger._construct = function (n, s) {\n    return new BigInteger(n, s, CONSTRUCT);\n  }; // Base-10 speedup hacks in parse, toString, exp10 and log functions\n  // require base to be a power of 10. 10^7 is the largest such power\n  // that won't cause a precision loss when digits are multiplied.\n\n\n  var BigInteger_base = 10000000;\n  var BigInteger_base_log10 = 7;\n  BigInteger.base = BigInteger_base;\n  BigInteger.base_log10 = BigInteger_base_log10;\n  var ZERO = new BigInteger([], 0, CONSTRUCT); // Constant: ZERO\n  // <BigInteger> 0.\n\n  BigInteger.ZERO = ZERO;\n  var ONE = new BigInteger([1], 1, CONSTRUCT); // Constant: ONE\n  // <BigInteger> 1.\n\n  BigInteger.ONE = ONE;\n  var M_ONE = new BigInteger(ONE._d, -1, CONSTRUCT); // Constant: M_ONE\n  // <BigInteger> -1.\n\n  BigInteger.M_ONE = M_ONE; // Constant: _0\n  // Shortcut for <ZERO>.\n\n  BigInteger._0 = ZERO; // Constant: _1\n  // Shortcut for <ONE>.\n\n  BigInteger._1 = ONE;\n  /*\n      Constant: small\n      Array of <BigIntegers> from 0 to 36.\n      These are used internally for parsing, but useful when you need a \"small\"\n      <BigInteger>.\n      See Also:\n          <ZERO>, <ONE>, <_0>, <_1>\n  */\n\n  BigInteger.small = [ZERO, ONE,\n  /* Assuming BigInteger_base > 36 */\n  new BigInteger([2], 1, CONSTRUCT), new BigInteger([3], 1, CONSTRUCT), new BigInteger([4], 1, CONSTRUCT), new BigInteger([5], 1, CONSTRUCT), new BigInteger([6], 1, CONSTRUCT), new BigInteger([7], 1, CONSTRUCT), new BigInteger([8], 1, CONSTRUCT), new BigInteger([9], 1, CONSTRUCT), new BigInteger([10], 1, CONSTRUCT), new BigInteger([11], 1, CONSTRUCT), new BigInteger([12], 1, CONSTRUCT), new BigInteger([13], 1, CONSTRUCT), new BigInteger([14], 1, CONSTRUCT), new BigInteger([15], 1, CONSTRUCT), new BigInteger([16], 1, CONSTRUCT), new BigInteger([17], 1, CONSTRUCT), new BigInteger([18], 1, CONSTRUCT), new BigInteger([19], 1, CONSTRUCT), new BigInteger([20], 1, CONSTRUCT), new BigInteger([21], 1, CONSTRUCT), new BigInteger([22], 1, CONSTRUCT), new BigInteger([23], 1, CONSTRUCT), new BigInteger([24], 1, CONSTRUCT), new BigInteger([25], 1, CONSTRUCT), new BigInteger([26], 1, CONSTRUCT), new BigInteger([27], 1, CONSTRUCT), new BigInteger([28], 1, CONSTRUCT), new BigInteger([29], 1, CONSTRUCT), new BigInteger([30], 1, CONSTRUCT), new BigInteger([31], 1, CONSTRUCT), new BigInteger([32], 1, CONSTRUCT), new BigInteger([33], 1, CONSTRUCT), new BigInteger([34], 1, CONSTRUCT), new BigInteger([35], 1, CONSTRUCT), new BigInteger([36], 1, CONSTRUCT)]; // Used for parsing/radix conversion\n\n  BigInteger.digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\n  /*\n      Method: toString\n      Convert a <BigInteger> to a string.\n      When *base* is greater than 10, letters are upper case.\n      Parameters:\n          base - Optional base to represent the number in (default is base 10).\n                 Must be between 2 and 36 inclusive, or an Error will be thrown.\n      Returns:\n          The string representation of the <BigInteger>.\n  */\n\n  BigInteger.prototype.toString = function (base) {\n    base = +base || 10;\n\n    if (base < 2 || base > 36) {\n      throw new Error(\"illegal radix \" + base + \".\");\n    }\n\n    if (this._s === 0) {\n      return \"0\";\n    }\n\n    if (base === 10) {\n      var str = this._s < 0 ? \"-\" : \"\";\n      str += this._d[this._d.length - 1].toString();\n\n      for (var i = this._d.length - 2; i >= 0; i--) {\n        var group = this._d[i].toString();\n\n        while (group.length < BigInteger_base_log10) {\n          group = '0' + group;\n        }\n\n        str += group;\n      }\n\n      return str;\n    } else {\n      var numerals = BigInteger.digits;\n      base = BigInteger.small[base];\n      var sign = this._s;\n      var n = this.abs();\n      var digits = [];\n      var digit;\n\n      while (n._s !== 0) {\n        var divmod = n.divRem(base);\n        n = divmod[0];\n        digit = divmod[1]; // TODO: This could be changed to unshift instead of reversing at the end.\n        // Benchmark both to compare speeds.\n\n        digits.push(numerals[digit.valueOf()]);\n      }\n\n      return (sign < 0 ? \"-\" : \"\") + digits.reverse().join(\"\");\n    }\n  }; // Verify strings for parsing\n\n\n  BigInteger.radixRegex = [/^$/, /^$/, /^[01]*$/, /^[012]*$/, /^[0-3]*$/, /^[0-4]*$/, /^[0-5]*$/, /^[0-6]*$/, /^[0-7]*$/, /^[0-8]*$/, /^[0-9]*$/, /^[0-9aA]*$/, /^[0-9abAB]*$/, /^[0-9abcABC]*$/, /^[0-9a-dA-D]*$/, /^[0-9a-eA-E]*$/, /^[0-9a-fA-F]*$/, /^[0-9a-gA-G]*$/, /^[0-9a-hA-H]*$/, /^[0-9a-iA-I]*$/, /^[0-9a-jA-J]*$/, /^[0-9a-kA-K]*$/, /^[0-9a-lA-L]*$/, /^[0-9a-mA-M]*$/, /^[0-9a-nA-N]*$/, /^[0-9a-oA-O]*$/, /^[0-9a-pA-P]*$/, /^[0-9a-qA-Q]*$/, /^[0-9a-rA-R]*$/, /^[0-9a-sA-S]*$/, /^[0-9a-tA-T]*$/, /^[0-9a-uA-U]*$/, /^[0-9a-vA-V]*$/, /^[0-9a-wA-W]*$/, /^[0-9a-xA-X]*$/, /^[0-9a-yA-Y]*$/, /^[0-9a-zA-Z]*$/];\n  /*\n      Function: parse\n      Parse a string into a <BigInteger>.\n      *base* is optional but, if provided, must be from 2 to 36 inclusive. If\n      *base* is not provided, it will be guessed based on the leading characters\n      of *s* as follows:\n      - \"0x\" or \"0X\": *base* = 16\n      - \"0c\" or \"0C\": *base* = 8\n      - \"0b\" or \"0B\": *base* = 2\n      - else: *base* = 10\n      If no base is provided, or *base* is 10, the number can be in exponential\n      form. For example, these are all valid:\n      > BigInteger.parse(\"1e9\");              // Same as \"1000000000\"\n      > BigInteger.parse(\"1.234*10^3\");       // Same as 1234\n      > BigInteger.parse(\"56789 * 10 ** -2\"); // Same as 567\n      If any characters fall outside the range defined by the radix, an exception\n      will be thrown.\n      Parameters:\n          s - The string to parse.\n          base - Optional radix (default is to guess based on *s*).\n      Returns:\n          a <BigInteger> instance.\n  */\n\n  BigInteger.parse = function (s, base) {\n    // Expands a number in exponential form to decimal form.\n    // expandExponential(\"-13.441*10^5\") === \"1344100\";\n    // expandExponential(\"1.12300e-1\") === \"0.112300\";\n    // expandExponential(1000000000000000000000000000000) === \"1000000000000000000000000000000\";\n    function expandExponential(str) {\n      str = str.replace(/\\s*[*xX]\\s*10\\s*(\\^|\\*\\*)\\s*/, \"e\");\n      return str.replace(/^([+\\-])?(\\d+)\\.?(\\d*)[eE]([+\\-]?\\d+)$/, function (x, s, n, f, c) {\n        c = +c;\n        var l = c < 0;\n        var i = n.length + c;\n        x = (l ? n : f).length;\n        c = (c = Math.abs(c)) >= x ? c - x + l : 0;\n        var z = new Array(c + 1).join(\"0\");\n        var r = n + f;\n        return (s || \"\") + (l ? r = z + r : r += z).substr(0, i += l ? z.length : 0) + (i < r.length ? \".\" + r.substr(i) : \"\");\n      });\n    }\n\n    s = s.toString();\n\n    if (typeof base === \"undefined\" || +base === 10) {\n      s = expandExponential(s);\n    }\n\n    var prefixRE;\n\n    if (typeof base === \"undefined\") {\n      prefixRE = '0[xcb]';\n    } else if (base == 16) {\n      prefixRE = '0x';\n    } else if (base == 8) {\n      prefixRE = '0c';\n    } else if (base == 2) {\n      prefixRE = '0b';\n    } else {\n      prefixRE = '';\n    }\n\n    var parts = new RegExp('^([+\\\\-]?)(' + prefixRE + ')?([0-9a-z]*)(?:\\\\.\\\\d*)?$', 'i').exec(s);\n\n    if (parts) {\n      var sign = parts[1] || \"+\";\n      var baseSection = parts[2] || \"\";\n      var digits = parts[3] || \"\";\n\n      if (typeof base === \"undefined\") {\n        // Guess base\n        if (baseSection === \"0x\" || baseSection === \"0X\") {\n          // Hex\n          base = 16;\n        } else if (baseSection === \"0c\" || baseSection === \"0C\") {\n          // Octal\n          base = 8;\n        } else if (baseSection === \"0b\" || baseSection === \"0B\") {\n          // Binary\n          base = 2;\n        } else {\n          base = 10;\n        }\n      } else if (base < 2 || base > 36) {\n        throw new Error(\"Illegal radix \" + base + \".\");\n      }\n\n      base = +base; // Check for digits outside the range\n\n      if (!BigInteger.radixRegex[base].test(digits)) {\n        throw new Error(\"Bad digit for radix \" + base);\n      } // Strip leading zeros, and convert to array\n\n\n      digits = digits.replace(/^0+/, \"\").split(\"\");\n\n      if (digits.length === 0) {\n        return ZERO;\n      } // Get the sign (we know it's not zero)\n\n\n      sign = sign === \"-\" ? -1 : 1; // Optimize 10\n\n      if (base == 10) {\n        var d = [];\n\n        while (digits.length >= BigInteger_base_log10) {\n          d.push(parseInt(digits.splice(digits.length - BigInteger.base_log10, BigInteger.base_log10).join(''), 10));\n        }\n\n        d.push(parseInt(digits.join(''), 10));\n        return new BigInteger(d, sign, CONSTRUCT);\n      } // Do the conversion\n\n\n      var d = ZERO;\n      base = BigInteger.small[base];\n      var small = BigInteger.small;\n\n      for (var i = 0; i < digits.length; i++) {\n        d = d.multiply(base).add(small[parseInt(digits[i], 36)]);\n      }\n\n      return new BigInteger(d._d, sign, CONSTRUCT);\n    } else {\n      throw new Error(\"Invalid BigInteger format: \" + s);\n    }\n  };\n  /*\n      Function: add\n      Add two <BigIntegers>.\n      Parameters:\n          n - The number to add to *this*. Will be converted to a <BigInteger>.\n      Returns:\n          The numbers added together.\n      See Also:\n          <subtract>, <multiply>, <quotient>, <next>\n  */\n\n\n  BigInteger.prototype.add = function (n) {\n    if (this._s === 0) {\n      return BigInteger(n);\n    }\n\n    n = BigInteger(n);\n\n    if (n._s === 0) {\n      return this;\n    }\n\n    if (this._s !== n._s) {\n      n = n.negate();\n      return this.subtract(n);\n    }\n\n    var a = this._d;\n    var b = n._d;\n    var al = a.length;\n    var bl = b.length;\n    var sum = new Array(Math.max(al, bl) + 1);\n    var size = Math.min(al, bl);\n    var carry = 0;\n    var digit;\n\n    for (var i = 0; i < size; i++) {\n      digit = a[i] + b[i] + carry;\n      sum[i] = digit % BigInteger_base;\n      carry = digit / BigInteger_base | 0;\n    }\n\n    if (bl > al) {\n      a = b;\n      al = bl;\n    }\n\n    for (i = size; carry && i < al; i++) {\n      digit = a[i] + carry;\n      sum[i] = digit % BigInteger_base;\n      carry = digit / BigInteger_base | 0;\n    }\n\n    if (carry) {\n      sum[i] = carry;\n    }\n\n    for (; i < al; i++) {\n      sum[i] = a[i];\n    }\n\n    return new BigInteger(sum, this._s, CONSTRUCT);\n  };\n  /*\n      Function: negate\n      Get the additive inverse of a <BigInteger>.\n      Returns:\n          A <BigInteger> with the same magnatude, but with the opposite sign.\n      See Also:\n          <abs>\n  */\n\n\n  BigInteger.prototype.negate = function () {\n    return new BigInteger(this._d, -this._s | 0, CONSTRUCT);\n  };\n  /*\n      Function: abs\n      Get the absolute value of a <BigInteger>.\n      Returns:\n          A <BigInteger> with the same magnatude, but always positive (or zero).\n      See Also:\n          <negate>\n  */\n\n\n  BigInteger.prototype.abs = function () {\n    return this._s < 0 ? this.negate() : this;\n  };\n  /*\n      Function: subtract\n      Subtract two <BigIntegers>.\n      Parameters:\n          n - The number to subtract from *this*. Will be converted to a <BigInteger>.\n      Returns:\n          The *n* subtracted from *this*.\n      See Also:\n          <add>, <multiply>, <quotient>, <prev>\n  */\n\n\n  BigInteger.prototype.subtract = function (n) {\n    if (this._s === 0) {\n      return BigInteger(n).negate();\n    }\n\n    n = BigInteger(n);\n\n    if (n._s === 0) {\n      return this;\n    }\n\n    if (this._s !== n._s) {\n      n = n.negate();\n      return this.add(n);\n    }\n\n    var m = this; // negative - negative => -|a| - -|b| => -|a| + |b| => |b| - |a|\n\n    if (this._s < 0) {\n      m = new BigInteger(n._d, 1, CONSTRUCT);\n      n = new BigInteger(this._d, 1, CONSTRUCT);\n    } // Both are positive => a - b\n\n\n    var sign = m.compareAbs(n);\n\n    if (sign === 0) {\n      return ZERO;\n    } else if (sign < 0) {\n      // swap m and n\n      var t = n;\n      n = m;\n      m = t;\n    } // a > b\n\n\n    var a = m._d;\n    var b = n._d;\n    var al = a.length;\n    var bl = b.length;\n    var diff = new Array(al); // al >= bl since a > b\n\n    var borrow = 0;\n    var i;\n    var digit;\n\n    for (i = 0; i < bl; i++) {\n      digit = a[i] - borrow - b[i];\n\n      if (digit < 0) {\n        digit += BigInteger_base;\n        borrow = 1;\n      } else {\n        borrow = 0;\n      }\n\n      diff[i] = digit;\n    }\n\n    for (i = bl; i < al; i++) {\n      digit = a[i] - borrow;\n\n      if (digit < 0) {\n        digit += BigInteger_base;\n      } else {\n        diff[i++] = digit;\n        break;\n      }\n\n      diff[i] = digit;\n    }\n\n    for (; i < al; i++) {\n      diff[i] = a[i];\n    }\n\n    return new BigInteger(diff, sign, CONSTRUCT);\n  };\n\n  (function () {\n    function addOne(n, sign) {\n      var a = n._d;\n      var sum = a.slice();\n      var carry = true;\n      var i = 0;\n\n      while (true) {\n        var digit = (a[i] || 0) + 1;\n        sum[i] = digit % BigInteger_base;\n\n        if (digit <= BigInteger_base - 1) {\n          break;\n        }\n\n        ++i;\n      }\n\n      return new BigInteger(sum, sign, CONSTRUCT);\n    }\n\n    function subtractOne(n, sign) {\n      var a = n._d;\n      var sum = a.slice();\n      var borrow = true;\n      var i = 0;\n\n      while (true) {\n        var digit = (a[i] || 0) - 1;\n\n        if (digit < 0) {\n          sum[i] = digit + BigInteger_base;\n        } else {\n          sum[i] = digit;\n          break;\n        }\n\n        ++i;\n      }\n\n      return new BigInteger(sum, sign, CONSTRUCT);\n    }\n    /*\n        Function: next\n        Get the next <BigInteger> (add one).\n        Returns:\n            *this* + 1.\n        See Also:\n            <add>, <prev>\n    */\n\n\n    BigInteger.prototype.next = function () {\n      switch (this._s) {\n        case 0:\n          return ONE;\n\n        case -1:\n          return subtractOne(this, -1);\n        // case 1:\n\n        default:\n          return addOne(this, 1);\n      }\n    };\n    /*\n        Function: prev\n        Get the previous <BigInteger> (subtract one).\n        Returns:\n            *this* - 1.\n        See Also:\n            <next>, <subtract>\n    */\n\n\n    BigInteger.prototype.prev = function () {\n      switch (this._s) {\n        case 0:\n          return M_ONE;\n\n        case -1:\n          return addOne(this, -1);\n        // case 1:\n\n        default:\n          return subtractOne(this, 1);\n      }\n    };\n  })();\n  /*\n      Function: compareAbs\n      Compare the absolute value of two <BigIntegers>.\n      Calling <compareAbs> is faster than calling <abs> twice, then <compare>.\n      Parameters:\n          n - The number to compare to *this*. Will be converted to a <BigInteger>.\n      Returns:\n          -1, 0, or +1 if *|this|* is less than, equal to, or greater than *|n|*.\n      See Also:\n          <compare>, <abs>\n  */\n\n\n  BigInteger.prototype.compareAbs = function (n) {\n    if (this === n) {\n      return 0;\n    }\n\n    if (!(n instanceof BigInteger)) {\n      if (!isFinite(n)) {\n        return isNaN(n) ? n : -1;\n      }\n\n      n = BigInteger(n);\n    }\n\n    if (this._s === 0) {\n      return n._s !== 0 ? -1 : 0;\n    }\n\n    if (n._s === 0) {\n      return 1;\n    }\n\n    var l = this._d.length;\n    var nl = n._d.length;\n\n    if (l < nl) {\n      return -1;\n    } else if (l > nl) {\n      return 1;\n    }\n\n    var a = this._d;\n    var b = n._d;\n\n    for (var i = l - 1; i >= 0; i--) {\n      if (a[i] !== b[i]) {\n        return a[i] < b[i] ? -1 : 1;\n      }\n    }\n\n    return 0;\n  };\n  /*\n      Function: compare\n      Compare two <BigIntegers>.\n      Parameters:\n          n - The number to compare to *this*. Will be converted to a <BigInteger>.\n      Returns:\n          -1, 0, or +1 if *this* is less than, equal to, or greater than *n*.\n      See Also:\n          <compareAbs>, <isPositive>, <isNegative>, <isUnit>\n  */\n\n\n  BigInteger.prototype.compare = function (n) {\n    if (this === n) {\n      return 0;\n    }\n\n    n = BigInteger(n);\n\n    if (this._s === 0) {\n      return -n._s;\n    }\n\n    if (this._s === n._s) {\n      // both positive or both negative\n      var cmp = this.compareAbs(n);\n      return cmp * this._s;\n    } else {\n      return this._s;\n    }\n  };\n  /*\n      Function: isUnit\n      Return true iff *this* is either 1 or -1.\n      Returns:\n          true if *this* compares equal to <BigInteger.ONE> or <BigInteger.M_ONE>.\n      See Also:\n          <isZero>, <isNegative>, <isPositive>, <compareAbs>, <compare>,\n          <BigInteger.ONE>, <BigInteger.M_ONE>\n  */\n\n\n  BigInteger.prototype.isUnit = function () {\n    return this === ONE || this === M_ONE || this._d.length === 1 && this._d[0] === 1;\n  };\n  /*\n      Function: multiply\n      Multiply two <BigIntegers>.\n      Parameters:\n          n - The number to multiply *this* by. Will be converted to a\n          <BigInteger>.\n      Returns:\n          The numbers multiplied together.\n      See Also:\n          <add>, <subtract>, <quotient>, <square>\n  */\n\n\n  BigInteger.prototype.multiply = function (n) {\n    // TODO: Consider adding Karatsuba multiplication for large numbers\n    if (this._s === 0) {\n      return ZERO;\n    }\n\n    n = BigInteger(n);\n\n    if (n._s === 0) {\n      return ZERO;\n    }\n\n    if (this.isUnit()) {\n      if (this._s < 0) {\n        return n.negate();\n      }\n\n      return n;\n    }\n\n    if (n.isUnit()) {\n      if (n._s < 0) {\n        return this.negate();\n      }\n\n      return this;\n    }\n\n    if (this === n) {\n      return this.square();\n    }\n\n    var r = this._d.length >= n._d.length;\n    var a = (r ? this : n)._d; // a will be longer than b\n\n    var b = (r ? n : this)._d;\n    var al = a.length;\n    var bl = b.length;\n    var pl = al + bl;\n    var partial = new Array(pl);\n    var i;\n\n    for (i = 0; i < pl; i++) {\n      partial[i] = 0;\n    }\n\n    for (i = 0; i < bl; i++) {\n      var carry = 0;\n      var bi = b[i];\n      var jlimit = al + i;\n      var digit;\n\n      for (var j = i; j < jlimit; j++) {\n        digit = partial[j] + bi * a[j - i] + carry;\n        carry = digit / BigInteger_base | 0;\n        partial[j] = digit % BigInteger_base | 0;\n      }\n\n      if (carry) {\n        digit = partial[j] + carry;\n        carry = digit / BigInteger_base | 0;\n        partial[j] = digit % BigInteger_base;\n      }\n    }\n\n    return new BigInteger(partial, this._s * n._s, CONSTRUCT);\n  }; // Multiply a BigInteger by a single-digit native number\n  // Assumes that this and n are >= 0\n  // This is not really intended to be used outside the library itself\n\n\n  BigInteger.prototype.multiplySingleDigit = function (n) {\n    if (n === 0 || this._s === 0) {\n      return ZERO;\n    }\n\n    if (n === 1) {\n      return this;\n    }\n\n    var digit;\n\n    if (this._d.length === 1) {\n      digit = this._d[0] * n;\n\n      if (digit >= BigInteger_base) {\n        return new BigInteger([digit % BigInteger_base | 0, digit / BigInteger_base | 0], 1, CONSTRUCT);\n      }\n\n      return new BigInteger([digit], 1, CONSTRUCT);\n    }\n\n    if (n === 2) {\n      return this.add(this);\n    }\n\n    if (this.isUnit()) {\n      return new BigInteger([n], 1, CONSTRUCT);\n    }\n\n    var a = this._d;\n    var al = a.length;\n    var pl = al + 1;\n    var partial = new Array(pl);\n\n    for (var i = 0; i < pl; i++) {\n      partial[i] = 0;\n    }\n\n    var carry = 0;\n\n    for (var j = 0; j < al; j++) {\n      digit = n * a[j] + carry;\n      carry = digit / BigInteger_base | 0;\n      partial[j] = digit % BigInteger_base | 0;\n    }\n\n    if (carry) {\n      partial[j] = carry;\n    }\n\n    return new BigInteger(partial, 1, CONSTRUCT);\n  };\n  /*\n      Function: square\n      Multiply a <BigInteger> by itself.\n      This is slightly faster than regular multiplication, since it removes the\n      duplicated multiplcations.\n      Returns:\n          > this.multiply(this)\n      See Also:\n          <multiply>\n  */\n\n\n  BigInteger.prototype.square = function () {\n    // Normally, squaring a 10-digit number would take 100 multiplications.\n    // Of these 10 are unique diagonals, of the remaining 90 (100-10), 45 are repeated.\n    // This procedure saves (N*(N-1))/2 multiplications, (e.g., 45 of 100 multiplies).\n    // Based on code by Gary Darby, Intellitech Systems Inc., www.DelphiForFun.org\n    if (this._s === 0) {\n      return ZERO;\n    }\n\n    if (this.isUnit()) {\n      return ONE;\n    }\n\n    var digits = this._d;\n    var length = digits.length;\n    var imult1 = new Array(length + length + 1);\n    var product, carry, k;\n    var i; // Calculate diagonal\n\n    for (i = 0; i < length; i++) {\n      k = i * 2;\n      product = digits[i] * digits[i];\n      carry = product / BigInteger_base | 0;\n      imult1[k] = product % BigInteger_base;\n      imult1[k + 1] = carry;\n    } // Calculate repeating part\n\n\n    for (i = 0; i < length; i++) {\n      carry = 0;\n      k = i * 2 + 1;\n\n      for (var j = i + 1; j < length; j++, k++) {\n        product = digits[j] * digits[i] * 2 + imult1[k] + carry;\n        carry = product / BigInteger_base | 0;\n        imult1[k] = product % BigInteger_base;\n      }\n\n      k = length + i;\n      var digit = carry + imult1[k];\n      carry = digit / BigInteger_base | 0;\n      imult1[k] = digit % BigInteger_base;\n      imult1[k + 1] += carry;\n    }\n\n    return new BigInteger(imult1, 1, CONSTRUCT);\n  };\n  /*\n      Function: quotient\n      Divide two <BigIntegers> and truncate towards zero.\n      <quotient> throws an exception if *n* is zero.\n      Parameters:\n          n - The number to divide *this* by. Will be converted to a <BigInteger>.\n      Returns:\n          The *this* / *n*, truncated to an integer.\n      See Also:\n          <add>, <subtract>, <multiply>, <divRem>, <remainder>\n  */\n\n\n  BigInteger.prototype.quotient = function (n) {\n    return this.divRem(n)[0];\n  };\n  /*\n      Function: divide\n      Deprecated synonym for <quotient>.\n  */\n\n\n  BigInteger.prototype.divide = BigInteger.prototype.quotient;\n  /*\n      Function: remainder\n      Calculate the remainder of two <BigIntegers>.\n      <remainder> throws an exception if *n* is zero.\n      Parameters:\n          n - The remainder after *this* is divided *this* by *n*. Will be\n              converted to a <BigInteger>.\n      Returns:\n          *this* % *n*.\n      See Also:\n          <divRem>, <quotient>\n  */\n\n  BigInteger.prototype.remainder = function (n) {\n    return this.divRem(n)[1];\n  };\n  /*\n      Function: divRem\n      Calculate the integer quotient and remainder of two <BigIntegers>.\n      <divRem> throws an exception if *n* is zero.\n      Parameters:\n          n - The number to divide *this* by. Will be converted to a <BigInteger>.\n      Returns:\n          A two-element array containing the quotient and the remainder.\n          > a.divRem(b)\n          is exactly equivalent to\n          > [a.quotient(b), a.remainder(b)]\n          except it is faster, because they are calculated at the same time.\n      See Also:\n          <quotient>, <remainder>\n  */\n\n\n  BigInteger.prototype.divRem = function (n) {\n    n = BigInteger(n);\n\n    if (n._s === 0) {\n      throw new Error(\"Divide by zero\");\n    }\n\n    if (this._s === 0) {\n      return [ZERO, ZERO];\n    }\n\n    if (n._d.length === 1) {\n      return this.divRemSmall(n._s * n._d[0]);\n    } // Test for easy cases -- |n1| <= |n2|\n\n\n    switch (this.compareAbs(n)) {\n      case 0:\n        // n1 == n2\n        return [this._s === n._s ? ONE : M_ONE, ZERO];\n\n      case -1:\n        // |n1| < |n2|\n        return [ZERO, this];\n    }\n\n    var sign = this._s * n._s;\n    var a = n.abs();\n    var b_digits = this._d;\n    var b_index = b_digits.length;\n    var digits = n._d.length;\n    var quot = [];\n    var guess;\n    var part = new BigInteger([], 0, CONSTRUCT);\n\n    while (b_index) {\n      part._d.unshift(b_digits[--b_index]);\n\n      part = new BigInteger(part._d, 1, CONSTRUCT);\n\n      if (part.compareAbs(n) < 0) {\n        quot.push(0);\n        continue;\n      }\n\n      if (part._s === 0) {\n        guess = 0;\n      } else {\n        var xlen = part._d.length,\n            ylen = a._d.length;\n        var highx = part._d[xlen - 1] * BigInteger_base + part._d[xlen - 2];\n        var highy = a._d[ylen - 1] * BigInteger_base + a._d[ylen - 2];\n\n        if (part._d.length > a._d.length) {\n          // The length of part._d can either match a._d length,\n          // or exceed it by one.\n          highx = (highx + 1) * BigInteger_base;\n        }\n\n        guess = Math.ceil(highx / highy);\n      }\n\n      do {\n        var check = a.multiplySingleDigit(guess);\n\n        if (check.compareAbs(part) <= 0) {\n          break;\n        }\n\n        guess--;\n      } while (guess);\n\n      quot.push(guess);\n\n      if (!guess) {\n        continue;\n      }\n\n      var diff = part.subtract(check);\n      part._d = diff._d.slice();\n    }\n\n    return [new BigInteger(quot.reverse(), sign, CONSTRUCT), new BigInteger(part._d, this._s, CONSTRUCT)];\n  }; // Throws an exception if n is outside of (-BigInteger.base, -1] or\n  // [1, BigInteger.base).  It's not necessary to call this, since the\n  // other division functions will call it if they are able to.\n\n\n  BigInteger.prototype.divRemSmall = function (n) {\n    var r;\n    n = +n;\n\n    if (n === 0) {\n      throw new Error(\"Divide by zero\");\n    }\n\n    var n_s = n < 0 ? -1 : 1;\n    var sign = this._s * n_s;\n    n = Math.abs(n);\n\n    if (n < 1 || n >= BigInteger_base) {\n      throw new Error(\"Argument out of range\");\n    }\n\n    if (this._s === 0) {\n      return [ZERO, ZERO];\n    }\n\n    if (n === 1 || n === -1) {\n      return [sign === 1 ? this.abs() : new BigInteger(this._d, sign, CONSTRUCT), ZERO];\n    } // 2 <= n < BigInteger_base\n    // divide a single digit by a single digit\n\n\n    if (this._d.length === 1) {\n      var q = new BigInteger([this._d[0] / n | 0], 1, CONSTRUCT);\n      r = new BigInteger([this._d[0] % n | 0], 1, CONSTRUCT);\n\n      if (sign < 0) {\n        q = q.negate();\n      }\n\n      if (this._s < 0) {\n        r = r.negate();\n      }\n\n      return [q, r];\n    }\n\n    var digits = this._d.slice();\n\n    var quot = new Array(digits.length);\n    var part = 0;\n    var diff = 0;\n    var i = 0;\n    var guess;\n\n    while (digits.length) {\n      part = part * BigInteger_base + digits[digits.length - 1];\n\n      if (part < n) {\n        quot[i++] = 0;\n        digits.pop();\n        diff = BigInteger_base * diff + part;\n        continue;\n      }\n\n      if (part === 0) {\n        guess = 0;\n      } else {\n        guess = part / n | 0;\n      }\n\n      var check = n * guess;\n      diff = part - check;\n      quot[i++] = guess;\n\n      if (!guess) {\n        digits.pop();\n        continue;\n      }\n\n      digits.pop();\n      part = diff;\n    }\n\n    r = new BigInteger([diff], 1, CONSTRUCT);\n\n    if (this._s < 0) {\n      r = r.negate();\n    }\n\n    return [new BigInteger(quot.reverse(), sign, CONSTRUCT), r];\n  };\n  /*\n      Function: isEven\n      Return true iff *this* is divisible by two.\n      Note that <BigInteger.ZERO> is even.\n      Returns:\n          true if *this* is even, false otherwise.\n      See Also:\n          <isOdd>\n  */\n\n\n  BigInteger.prototype.isEven = function () {\n    var digits = this._d;\n    return this._s === 0 || digits.length === 0 || digits[0] % 2 === 0;\n  };\n  /*\n      Function: isOdd\n      Return true iff *this* is not divisible by two.\n      Returns:\n          true if *this* is odd, false otherwise.\n      See Also:\n          <isEven>\n  */\n\n\n  BigInteger.prototype.isOdd = function () {\n    return !this.isEven();\n  };\n  /*\n      Function: sign\n      Get the sign of a <BigInteger>.\n      Returns:\n          * -1 if *this* < 0\n          * 0 if *this* == 0\n          * +1 if *this* > 0\n      See Also:\n          <isZero>, <isPositive>, <isNegative>, <compare>, <BigInteger.ZERO>\n  */\n\n\n  BigInteger.prototype.sign = function () {\n    return this._s;\n  };\n  /*\n      Function: isPositive\n      Return true iff *this* > 0.\n      Returns:\n          true if *this*.compare(<BigInteger.ZERO>) == 1.\n      See Also:\n          <sign>, <isZero>, <isNegative>, <isUnit>, <compare>, <BigInteger.ZERO>\n  */\n\n\n  BigInteger.prototype.isPositive = function () {\n    return this._s > 0;\n  };\n  /*\n      Function: isNegative\n      Return true iff *this* < 0.\n      Returns:\n          true if *this*.compare(<BigInteger.ZERO>) == -1.\n      See Also:\n          <sign>, <isPositive>, <isZero>, <isUnit>, <compare>, <BigInteger.ZERO>\n  */\n\n\n  BigInteger.prototype.isNegative = function () {\n    return this._s < 0;\n  };\n  /*\n      Function: isZero\n      Return true iff *this* == 0.\n      Returns:\n          true if *this*.compare(<BigInteger.ZERO>) == 0.\n      See Also:\n          <sign>, <isPositive>, <isNegative>, <isUnit>, <BigInteger.ZERO>\n  */\n\n\n  BigInteger.prototype.isZero = function () {\n    return this._s === 0;\n  };\n  /*\n      Function: exp10\n      Multiply a <BigInteger> by a power of 10.\n      This is equivalent to, but faster than\n      > if (n >= 0) {\n      >     return this.multiply(BigInteger(\"1e\" + n));\n      > }\n      > else { // n <= 0\n      >     return this.quotient(BigInteger(\"1e\" + -n));\n      > }\n      Parameters:\n          n - The power of 10 to multiply *this* by. *n* is converted to a\n          javascipt number and must be no greater than <BigInteger.MAX_EXP>\n          (0x7FFFFFFF), or an exception will be thrown.\n      Returns:\n          *this* * (10 ** *n*), truncated to an integer if necessary.\n      See Also:\n          <pow>, <multiply>\n  */\n\n\n  BigInteger.prototype.exp10 = function (n) {\n    n = +n;\n\n    if (n === 0) {\n      return this;\n    }\n\n    if (Math.abs(n) > Number(MAX_EXP)) {\n      throw new Error(\"exponent too large in BigInteger.exp10\");\n    } // Optimization for this == 0. This also keeps us from having to trim zeros in the positive n case\n\n\n    if (this._s === 0) {\n      return ZERO;\n    }\n\n    if (n > 0) {\n      var k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);\n\n      for (; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {\n        k._d.unshift(0);\n      }\n\n      if (n == 0) return k;\n      k._s = 1;\n      k = k.multiplySingleDigit(Math.pow(10, n));\n      return this._s < 0 ? k.negate() : k;\n    } else if (-n >= this._d.length * BigInteger_base_log10) {\n      return ZERO;\n    } else {\n      var k = new BigInteger(this._d.slice(), this._s, CONSTRUCT);\n\n      for (n = -n; n >= BigInteger_base_log10; n -= BigInteger_base_log10) {\n        k._d.shift();\n      }\n\n      return n == 0 ? k : k.divRemSmall(Math.pow(10, n))[0];\n    }\n  };\n  /*\n      Function: pow\n      Raise a <BigInteger> to a power.\n      In this implementation, 0**0 is 1.\n      Parameters:\n          n - The exponent to raise *this* by. *n* must be no greater than\n          <BigInteger.MAX_EXP> (0x7FFFFFFF), or an exception will be thrown.\n      Returns:\n          *this* raised to the *nth* power.\n      See Also:\n          <modPow>\n  */\n\n\n  BigInteger.prototype.pow = function (n) {\n    if (this.isUnit()) {\n      if (this._s > 0) {\n        return this;\n      } else {\n        return BigInteger(n).isOdd() ? this : this.negate();\n      }\n    }\n\n    n = BigInteger(n);\n\n    if (n._s === 0) {\n      return ONE;\n    } else if (n._s < 0) {\n      if (this._s === 0) {\n        throw new Error(\"Divide by zero\");\n      } else {\n        return ZERO;\n      }\n    }\n\n    if (this._s === 0) {\n      return ZERO;\n    }\n\n    if (n.isUnit()) {\n      return this;\n    }\n\n    if (n.compareAbs(MAX_EXP) > 0) {\n      throw new Error(\"exponent too large in BigInteger.pow\");\n    }\n\n    var x = this;\n    var aux = ONE;\n    var two = BigInteger.small[2];\n\n    while (n.isPositive()) {\n      if (n.isOdd()) {\n        aux = aux.multiply(x);\n\n        if (n.isUnit()) {\n          return aux;\n        }\n      }\n\n      x = x.square();\n      n = n.quotient(two);\n    }\n\n    return aux;\n  };\n  /*\n      Function: modPow\n      Raise a <BigInteger> to a power (mod m).\n      Because it is reduced by a modulus, <modPow> is not limited by\n      <BigInteger.MAX_EXP> like <pow>.\n      Parameters:\n          exponent - The exponent to raise *this* by. Must be positive.\n          modulus - The modulus.\n      Returns:\n          *this* ^ *exponent* (mod *modulus*).\n      See Also:\n          <pow>, <mod>\n  */\n\n\n  BigInteger.prototype.modPow = function (exponent, modulus) {\n    var result = ONE;\n    var base = this;\n\n    while (exponent.isPositive()) {\n      if (exponent.isOdd()) {\n        result = result.multiply(base).remainder(modulus);\n      }\n\n      exponent = exponent.quotient(BigInteger.small[2]);\n\n      if (exponent.isPositive()) {\n        base = base.square().remainder(modulus);\n      }\n    }\n\n    return result;\n  };\n  /*\n      Function: log\n      Get the natural logarithm of a <BigInteger> as a native JavaScript number.\n      This is equivalent to\n      > Math.log(this.toJSValue())\n      but handles values outside of the native number range.\n      Returns:\n          log( *this* )\n      See Also:\n          <toJSValue>\n  */\n\n\n  BigInteger.prototype.log = function () {\n    switch (this._s) {\n      case 0:\n        return -Infinity;\n\n      case -1:\n        return NaN;\n\n      default: // Fall through.\n\n    }\n\n    var l = this._d.length;\n\n    if (l * BigInteger_base_log10 < 30) {\n      return Math.log(this.valueOf());\n    }\n\n    var N = Math.ceil(30 / BigInteger_base_log10);\n\n    var firstNdigits = this._d.slice(l - N);\n\n    return Math.log(new BigInteger(firstNdigits, 1, CONSTRUCT).valueOf()) + (l - N) * Math.log(BigInteger_base);\n  };\n  /*\n      Function: valueOf\n      Convert a <BigInteger> to a native JavaScript integer.\n      This is called automatically by JavaScipt to convert a <BigInteger> to a\n      native value.\n      Returns:\n          > parseInt(this.toString(), 10)\n      See Also:\n          <toString>, <toJSValue>\n  */\n\n\n  BigInteger.prototype.valueOf = function () {\n    return parseInt(this.toString(), 10);\n  };\n  /*\n      Function: toJSValue\n      Convert a <BigInteger> to a native JavaScript integer.\n      This is the same as valueOf, but more explicitly named.\n      Returns:\n          > parseInt(this.toString(), 10)\n      See Also:\n          <toString>, <valueOf>\n  */\n\n\n  BigInteger.prototype.toJSValue = function () {\n    return parseInt(this.toString(), 10);\n  };\n  /*\n   Function: lowVal\n   Author: Lucas Jones\n   */\n\n\n  BigInteger.prototype.lowVal = function () {\n    return this._d[0] || 0;\n  };\n\n  var MAX_EXP = BigInteger(0x7FFFFFFF); // Constant: MAX_EXP\n  // The largest exponent allowed in <pow> and <exp10> (0x7FFFFFFF or 2147483647).\n\n  BigInteger.MAX_EXP = MAX_EXP;\n\n  (function () {\n    function makeUnary(fn) {\n      return function (a) {\n        return fn.call(BigInteger(a));\n      };\n    }\n\n    function makeBinary(fn) {\n      return function (a, b) {\n        return fn.call(BigInteger(a), BigInteger(b));\n      };\n    }\n\n    function makeTrinary(fn) {\n      return function (a, b, c) {\n        return fn.call(BigInteger(a), BigInteger(b), BigInteger(c));\n      };\n    }\n\n    (function () {\n      var i, fn;\n      var unary = \"toJSValue,isEven,isOdd,sign,isZero,isNegative,abs,isUnit,square,negate,isPositive,toString,next,prev,log\".split(\",\");\n      var binary = \"compare,remainder,divRem,subtract,add,quotient,divide,multiply,pow,compareAbs\".split(\",\");\n      var trinary = [\"modPow\"];\n\n      for (i = 0; i < unary.length; i++) {\n        fn = unary[i];\n        BigInteger[fn] = makeUnary(BigInteger.prototype[fn]);\n      }\n\n      for (i = 0; i < binary.length; i++) {\n        fn = binary[i];\n        BigInteger[fn] = makeBinary(BigInteger.prototype[fn]);\n      }\n\n      for (i = 0; i < trinary.length; i++) {\n        fn = trinary[i];\n        BigInteger[fn] = makeTrinary(BigInteger.prototype[fn]);\n      }\n\n      BigInteger.exp10 = function (x, n) {\n        return BigInteger(x).exp10(n);\n      };\n    })();\n  })();\n\n  exports.JSBigInt = BigInteger; // exports.BigInteger changed to exports.JSBigInt\n})(typeof exports !== 'undefined' ? exports : this);","map":null,"metadata":{},"sourceType":"script"}