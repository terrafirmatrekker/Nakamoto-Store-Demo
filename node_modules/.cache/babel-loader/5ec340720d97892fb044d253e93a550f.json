{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar defaults = require(\"lodash.defaults\");\n\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nvar SturdyWebSocket =\n/** @class */\nfunction () {\n  function SturdyWebSocket(url, protocolsOrOptions, options) {\n    this.url = url;\n    this.onclose = null;\n    this.onerror = null;\n    this.onmessage = null;\n    this.onopen = null;\n    this.ondown = null;\n    this.onreopen = null;\n    this.CONNECTING = SturdyWebSocket.CONNECTING;\n    this.OPEN = SturdyWebSocket.OPEN;\n    this.CLOSING = SturdyWebSocket.CLOSING;\n    this.CLOSED = SturdyWebSocket.CLOSED;\n    this.hasBeenOpened = false;\n    this.isClosed = false;\n    this.messageBuffer = [];\n    this.nextRetryTime = 0;\n    this.reconnectCount = 0;\n    this.lastKnownExtensions = \"\";\n    this.lastKnownProtocol = \"\";\n    this.listeners = {};\n\n    if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) {\n      this.protocols = protocolsOrOptions;\n    } else {\n      options = protocolsOrOptions;\n    }\n\n    this.options = defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);\n\n    if (!this.options.wsConstructor) {\n      if (typeof WebSocket !== \"undefined\") {\n        this.options.wsConstructor = WebSocket;\n      } else {\n        throw new Error(\"WebSocket not present in global scope and no \" + \"wsConstructor option was provided.\");\n      }\n    }\n\n    this.openNewWebSocket();\n  }\n\n  Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n    get: function get() {\n      return this.binaryTypeInternal || \"blob\";\n    },\n    set: function set(binaryType) {\n      this.binaryTypeInternal = binaryType;\n\n      if (this.ws) {\n        this.ws.binaryType = binaryType;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n    get: function get() {\n      var sum = this.ws ? this.ws.bufferedAmount : 0;\n      var hasUnknownAmount = false;\n      this.messageBuffer.forEach(function (data) {\n        var byteLength = getDataByteLength(data);\n\n        if (byteLength != null) {\n          sum += byteLength;\n        } else {\n          hasUnknownAmount = true;\n        }\n      });\n\n      if (hasUnknownAmount) {\n        this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" + \" return value may be below the correct amount.\");\n      }\n\n      return sum;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n    get: function get() {\n      return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n    get: function get() {\n      return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n    get: function get() {\n      return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SturdyWebSocket.prototype.close = function (code, reason) {\n    if (this.ws) {\n      this.ws.close(code, reason);\n    }\n\n    this.shutdown();\n    this.debugLog(\"WebSocket permanently closed by client.\");\n  };\n\n  SturdyWebSocket.prototype.send = function (data) {\n    if (this.ws && this.ws.readyState === this.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.messageBuffer.push(data);\n    }\n  };\n\n  SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  };\n\n  SturdyWebSocket.prototype.dispatchEvent = function (event) {\n    return this.dispatchEventOfType(event.type, event);\n  };\n\n  SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n    if (this.listeners[type]) {\n      this.listeners[type] = this.listeners[type].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  };\n\n  SturdyWebSocket.prototype.openNewWebSocket = function () {\n    var _this = this;\n\n    if (this.isClosed) {\n      return;\n    }\n\n    var _a = this.options,\n        connectTimeout = _a.connectTimeout,\n        wsConstructor = _a.wsConstructor;\n    this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n    var ws = new wsConstructor(this.url, this.protocols);\n\n    ws.onclose = function (event) {\n      return _this.handleClose(event);\n    };\n\n    ws.onerror = function (event) {\n      return _this.handleError(event);\n    };\n\n    ws.onmessage = function (event) {\n      return _this.handleMessage(event);\n    };\n\n    ws.onopen = function (event) {\n      return _this.handleOpen(event);\n    };\n\n    this.connectTimeoutId = setTimeout(function () {\n      // If this is running, we still haven't opened the websocket.\n      // Kill it so we can try again.\n      _this.clearConnectTimeout();\n\n      ws.close();\n    }, connectTimeout);\n    this.ws = ws;\n  };\n\n  SturdyWebSocket.prototype.handleOpen = function (event) {\n    var _this = this;\n\n    if (!this.ws || this.isClosed) {\n      return;\n    }\n\n    var allClearResetTime = this.options.allClearResetTime;\n    this.debugLog(\"WebSocket opened.\");\n\n    if (this.binaryTypeInternal != null) {\n      this.ws.binaryType = this.binaryTypeInternal;\n    } else {\n      this.binaryTypeInternal = this.ws.binaryType;\n    }\n\n    this.clearConnectTimeout();\n\n    if (this.hasBeenOpened) {\n      this.dispatchEventOfType(\"reopen\", event);\n    } else {\n      this.dispatchEventOfType(\"open\", event);\n      this.hasBeenOpened = true;\n    }\n\n    this.messageBuffer.forEach(function (message) {\n      return _this.send(message);\n    });\n    this.messageBuffer = [];\n    this.allClearTimeoutId = setTimeout(function () {\n      _this.clearAllClearTimeout();\n\n      _this.nextRetryTime = 0;\n      _this.reconnectCount = 0;\n      var openTime = allClearResetTime / 1000 | 0;\n\n      _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n    }, allClearResetTime);\n  };\n\n  SturdyWebSocket.prototype.handleMessage = function (event) {\n    if (this.isClosed) {\n      return;\n    }\n\n    this.dispatchEventOfType(\"message\", event);\n  };\n\n  SturdyWebSocket.prototype.handleClose = function (event) {\n    var _this = this;\n\n    if (this.isClosed) {\n      return;\n    }\n\n    var _a = this.options,\n        maxReconnectAttempts = _a.maxReconnectAttempts,\n        shouldReconnect = _a.shouldReconnect;\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n\n    if (this.ws) {\n      this.lastKnownExtensions = this.ws.extensions;\n      this.lastKnownProtocol = this.ws.protocol;\n      this.ws = undefined;\n    }\n\n    this.dispatchEventOfType(\"down\", event);\n\n    if (this.reconnectCount >= maxReconnectAttempts) {\n      this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n      return;\n    }\n\n    var willReconnect = shouldReconnect(event);\n\n    if (typeof willReconnect === \"boolean\") {\n      this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n    } else {\n      willReconnect.then(function (willReconnectResolved) {\n        if (_this.isClosed) {\n          return;\n        }\n\n        _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n      });\n    }\n  };\n\n  SturdyWebSocket.prototype.handleError = function (event) {\n    this.dispatchEventOfType(\"error\", event);\n    this.debugLog(\"WebSocket encountered an error.\");\n  };\n\n  SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n    if (willReconnect) {\n      this.reconnect();\n    } else {\n      this.stopReconnecting(event, denialReason);\n    }\n  };\n\n  SturdyWebSocket.prototype.reconnect = function () {\n    var _this = this;\n\n    var _a = this.options,\n        minReconnectDelay = _a.minReconnectDelay,\n        maxReconnectDelay = _a.maxReconnectDelay,\n        reconnectBackoffFactor = _a.reconnectBackoffFactor;\n    this.reconnectCount++;\n    var retryTime = this.nextRetryTime;\n    this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n    setTimeout(function () {\n      return _this.openNewWebSocket();\n    }, retryTime);\n    var retryTimeSeconds = retryTime / 1000 | 0;\n    this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n  };\n\n  SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n    this.debugLog(debugReason);\n    this.shutdown();\n    this.dispatchEventOfType(\"close\", event);\n  };\n\n  SturdyWebSocket.prototype.shutdown = function () {\n    this.isClosed = true;\n    this.clearAllTimeouts();\n    this.messageBuffer = [];\n  };\n\n  SturdyWebSocket.prototype.clearAllTimeouts = function () {\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n  };\n\n  SturdyWebSocket.prototype.clearConnectTimeout = function () {\n    if (this.connectTimeoutId != null) {\n      clearTimeout(this.connectTimeoutId);\n      this.connectTimeoutId = undefined;\n    }\n  };\n\n  SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n    if (this.allClearTimeoutId != null) {\n      clearTimeout(this.allClearTimeoutId);\n      this.allClearTimeoutId = undefined;\n    }\n  };\n\n  SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n    var _this = this;\n\n    switch (type) {\n      case \"close\":\n        if (this.onclose) {\n          this.onclose(event);\n        }\n\n        break;\n\n      case \"error\":\n        if (this.onerror) {\n          this.onerror(event);\n        }\n\n        break;\n\n      case \"message\":\n        if (this.onmessage) {\n          this.onmessage(event);\n        }\n\n        break;\n\n      case \"open\":\n        if (this.onopen) {\n          this.onopen(event);\n        }\n\n        break;\n\n      case \"down\":\n        if (this.ondown) {\n          this.ondown(event);\n        }\n\n        break;\n\n      case \"reopen\":\n        if (this.onreopen) {\n          this.onreopen(event);\n        }\n\n        break;\n    }\n\n    if (type in this.listeners) {\n      this.listeners[type].slice().forEach(function (listener) {\n        return _this.callListener(listener, event);\n      });\n    }\n\n    return !event || !event.defaultPrevented;\n  };\n\n  SturdyWebSocket.prototype.callListener = function (listener, event) {\n    if (typeof listener === \"function\") {\n      listener.call(this, event);\n    } else {\n      listener.handleEvent.call(this, event);\n    }\n  };\n\n  SturdyWebSocket.prototype.debugLog = function (message) {\n    if (this.options.debug) {\n      // tslint:disable-next-line:no-console\n      console.log(message);\n    }\n  };\n\n  SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n    var maxReconnectAttempts = this.options.maxReconnectAttempts;\n    return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n  };\n\n  SturdyWebSocket.DEFAULT_OPTIONS = {\n    allClearResetTime: 5000,\n    connectTimeout: 5000,\n    debug: false,\n    minReconnectDelay: 1000,\n    maxReconnectDelay: 30000,\n    maxReconnectAttempts: Number.POSITIVE_INFINITY,\n    reconnectBackoffFactor: 1.5,\n    shouldReconnect: function shouldReconnect() {\n      return true;\n    },\n    wsConstructor: undefined\n  };\n  SturdyWebSocket.CONNECTING = 0;\n  SturdyWebSocket.OPEN = 1;\n  SturdyWebSocket.CLOSING = 2;\n  SturdyWebSocket.CLOSED = 3;\n  return SturdyWebSocket;\n}();\n\nexports.default = SturdyWebSocket;\n\nfunction getDataByteLength(data) {\n  if (typeof data === \"string\") {\n    // UTF-16 strings use two bytes per character.\n    return 2 * data.length;\n  } else if (data instanceof ArrayBuffer) {\n    return data.byteLength;\n  } else if (data instanceof Blob) {\n    return data.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction pluralize(s, n) {\n  return n === 1 ? s : s + \"s\";\n}","map":null,"metadata":{},"sourceType":"script"}