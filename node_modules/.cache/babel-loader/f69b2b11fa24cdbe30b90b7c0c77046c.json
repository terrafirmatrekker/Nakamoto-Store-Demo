{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { getRenNetworkDetails, NullLogger, RenJSErrors, TxStatus } from \"@renproject/interfaces\";\nimport { HttpProvider } from \"@renproject/provider\";\nimport { assertType, extractError, fromBase64, isDefined, keccak256, parseV1Selector, SECONDS, sleep, strip0x, toBase64 } from \"@renproject/utils\";\nimport { List } from \"immutable\";\nimport { RPCMethod } from \"./methods\";\nimport { unmarshalBurnTx, unmarshalFees, unmarshalMintTx } from \"./unmarshal\";\nimport { RenVMType } from \"./value\";\nexport var generateMintTxHash = function generateMintTxHash(selector, encodedID, deposit) {\n  var logger = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NullLogger;\n  // Type validation\n  assertType(\"string\", {\n    encodedID: encodedID,\n    deposit: deposit\n  });\n  var message = \"txHash_\".concat(selector, \"_\").concat(encodedID, \"_\").concat(deposit);\n  var digest = keccak256(Buffer.from(message));\n  logger.debug(\"Mint txHash\", toBase64(digest), message);\n  return digest;\n};\nexport var RenVMProvider = function RenVMProvider(network, provider) {\n  var _this = this;\n\n  var logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NullLogger;\n\n  _classCallCheck(this, RenVMProvider);\n\n  this.version = function () {\n    return 1;\n  };\n\n  this.selector = function (_ref) {\n    var asset = _ref.asset,\n        from = _ref.from,\n        to = _ref.to;\n    return \"\".concat(asset, \"0\").concat(from.legacyName || from.name, \"2\").concat(to.legacyName || from.name);\n  };\n\n  this.queryBlock =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(blockHeight, retry) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryBlock, {\n                blockHeight: blockHeight\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  this.queryBlocks =\n  /*#__PURE__*/\n  function () {\n    var _ref3 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(blockHeight, n, retry) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryBlocks, {\n                blockHeight: blockHeight,\n                n: n\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x3, _x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  this.submitTx =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(tx, retry) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodSubmitTx, {\n                tx: tx\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x6, _x7) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  this.queryTx =\n  /*#__PURE__*/\n  function () {\n    var _ref5 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(txHash, retry) {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryTx, {\n                txHash: txHash\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x8, _x9) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  this.queryTxs =\n  /*#__PURE__*/\n  function () {\n    var _ref6 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5(tags, page, pageSize, txStatus, retry) {\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryTxs, {\n                tags: tags,\n                page: (page || 0).toString(),\n                pageSize: (pageSize || 0).toString(),\n                txStatus: txStatus\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x10, _x11, _x12, _x13, _x14) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n\n  this.queryNumPeers =\n  /*#__PURE__*/\n  function () {\n    var _ref7 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee6(retry) {\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryNumPeers, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x15) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n\n  this.queryPeers =\n  /*#__PURE__*/\n  function () {\n    var _ref8 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7(retry) {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryPeers, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function (_x16) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n\n  this.queryShards =\n  /*#__PURE__*/\n  function () {\n    var _ref9 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8(retry) {\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              return _context8.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryShards, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    return function (_x17) {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n\n  this.queryStat =\n  /*#__PURE__*/\n  function () {\n    var _ref10 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee9(retry) {\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryStat, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n\n    return function (_x18) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n\n  this.queryFees =\n  /*#__PURE__*/\n  function () {\n    var _ref11 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee10(retry) {\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              return _context10.abrupt(\"return\", _this.sendMessage(RPCMethod.MethodQueryFees, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    }));\n\n    return function (_x19) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n\n  this.getFees =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee11() {\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.t0 = unmarshalFees;\n            _context11.next = 3;\n            return _this.queryFees();\n\n          case 3:\n            _context11.t1 = _context11.sent;\n            return _context11.abrupt(\"return\", (0, _context11.t0)(_context11.t1));\n\n          case 5:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n\n  this.mintTxHash = function (_ref13) {\n    var selector = _ref13.selector,\n        gHash = _ref13.gHash,\n        outputHashFormat = _ref13.outputHashFormat;\n    assertType(\"Buffer\", {\n      gHash: gHash\n    });\n    assertType(\"string\", {\n      outputHashFormat: outputHashFormat\n    });\n    return generateMintTxHash(selector, toBase64(gHash), outputHashFormat, _this.logger);\n  };\n\n  this.submitMint =\n  /*#__PURE__*/\n  function () {\n    var _ref15 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee12(_ref14) {\n      var selector, nonce, output, payload, to, token, fn, fnABI, tags, txindex, txid, response;\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              selector = _ref14.selector, nonce = _ref14.nonce, output = _ref14.output, payload = _ref14.payload, to = _ref14.to, token = _ref14.token, fn = _ref14.fn, fnABI = _ref14.fnABI, tags = _ref14.tags;\n              txindex = output.txindex, txid = output.txid;\n              assertType(\"Buffer\", {\n                nonce: nonce,\n                payload: payload,\n                txid: txid\n              });\n              assertType(\"string\", {\n                to: to,\n                token: token,\n                fn: fn,\n                txindex: txindex\n              });\n              _context12.next = 6;\n              return _this.sendMessage(RPCMethod.MethodSubmitTx, {\n                tx: {\n                  to: selector,\n                  in: [//\n                  {\n                    name: \"p\",\n                    type: RenVMType.ExtEthCompatPayload,\n                    value: {\n                      abi: toBase64(Buffer.from(JSON.stringify(fnABI))),\n                      value: toBase64(payload),\n                      fn: toBase64(Buffer.from(fn))\n                    }\n                  }, // The hash of the payload data\n                  // { name: \"phash\" as const, type: RenVMType.B32 as const, value: toBase64(pHash) },\n                  // The amount of BTC (in SATs) that has be transferred to the gateway\n                  // { name: \"amount\" as const, type: \"u64\", as const value: amount },\n                  // The ERC20 contract address on Ethereum for BTC\n                  {\n                    name: \"token\",\n                    type: RenVMType.ExtTypeEthCompatAddress,\n                    value: strip0x(token)\n                  }, // The address on the Ethereum blockchain to which BTC will be transferred\n                  {\n                    name: \"to\",\n                    type: RenVMType.ExtTypeEthCompatAddress,\n                    value: strip0x(to)\n                  }, // The nonce is used to randomize the gateway\n                  {\n                    name: \"n\",\n                    type: RenVMType.B32,\n                    value: toBase64(nonce)\n                  }, // UTXO\n                  {\n                    name: \"utxo\",\n                    type: RenVMType.ExtTypeBtcCompatUTXO,\n                    value: {\n                      txHash: toBase64(txid),\n                      vOut: txindex\n                    }\n                  }]\n                },\n                tags: tags\n              });\n\n            case 6:\n              response = _context12.sent;\n              return _context12.abrupt(\"return\", fromBase64(response.tx.hash));\n\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, _callee12);\n    }));\n\n    return function (_x20) {\n      return _ref15.apply(this, arguments);\n    };\n  }();\n\n  this.submitBurn =\n  /*#__PURE__*/\n  function () {\n    var _ref16 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee13(params) {\n      var selector, burnNonce, tags, response;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              selector = params.selector, burnNonce = params.burnNonce, tags = params.tags;\n              _context13.next = 3;\n              return _this.sendMessage(RPCMethod.MethodSubmitTx, {\n                tx: {\n                  to: selector,\n                  in: [{\n                    name: \"ref\",\n                    type: RenVMType.U64,\n                    value: burnNonce.decimalPlaces(0).toFixed()\n                  }]\n                },\n                tags: tags\n              });\n\n            case 3:\n              response = _context13.sent;\n              return _context13.abrupt(\"return\", fromBase64(response.tx.hash));\n\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee13);\n    }));\n\n    return function (_x21) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n\n  this.queryMintOrBurn =\n  /*#__PURE__*/\n  function () {\n    var _ref17 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee14(_selector, utxoTxHash) {\n      var response, _parseV1Selector, asset, from;\n\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return _this.queryTx(toBase64(utxoTxHash));\n\n            case 2:\n              response = _context14.sent;\n              // Unmarshal transaction.\n              _parseV1Selector = parseV1Selector(response.tx.to), asset = _parseV1Selector.asset, from = _parseV1Selector.from;\n\n              if (!(asset.toUpperCase() === from.toUpperCase())) {\n                _context14.next = 8;\n                break;\n              }\n\n              return _context14.abrupt(\"return\", unmarshalMintTx(response));\n\n            case 8:\n              return _context14.abrupt(\"return\", unmarshalBurnTx(response));\n\n            case 9:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, _callee14);\n    }));\n\n    return function (_x22, _x23) {\n      return _ref17.apply(this, arguments);\n    };\n  }();\n\n  this.waitForTX =\n  /*#__PURE__*/\n  function () {\n    var _ref18 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee15(selector, utxoTxHash, onStatus, _cancelRequested, timeout) {\n      var rawResponse, result;\n      return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              assertType(\"Buffer\", {\n                utxoTxHash: utxoTxHash\n              });\n\n            case 1:\n              if (!true) {\n                _context15.next = 23;\n                break;\n              }\n\n              if (!(_cancelRequested && _cancelRequested())) {\n                _context15.next = 4;\n                break;\n              }\n\n              throw new Error(\"waitForTX cancelled\");\n\n            case 4:\n              _context15.prev = 4;\n              _context15.next = 7;\n              return _this.queryMintOrBurn(selector, utxoTxHash);\n\n            case 7:\n              result = _context15.sent;\n\n              if (!(result && result.txStatus === TxStatus.TxStatusDone)) {\n                _context15.next = 13;\n                break;\n              }\n\n              rawResponse = result;\n              return _context15.abrupt(\"break\", 23);\n\n            case 13:\n              if (onStatus && result && result.txStatus) {\n                onStatus(result.txStatus);\n              }\n\n            case 14:\n              _context15.next = 19;\n              break;\n\n            case 16:\n              _context15.prev = 16;\n              _context15.t0 = _context15[\"catch\"](4);\n\n              if (/(not found)|(not available)/.exec(String((_context15.t0 || {}).message))) {// ignore\n              } else {\n                _this.logger.error(String(_context15.t0)); // TODO: throw unexpected errors\n\n              }\n\n            case 19:\n              _context15.next = 21;\n              return sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n\n            case 21:\n              _context15.next = 1;\n              break;\n\n            case 23:\n              return _context15.abrupt(\"return\", rawResponse);\n\n            case 24:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, _callee15, null, [[4, 16]]);\n    }));\n\n    return function (_x24, _x25, _x26, _x27, _x28) {\n      return _ref18.apply(this, arguments);\n    };\n  }();\n  /**\n   * selectPublicKey fetches the public key for the RenVM shard handling\n   * the provided contract.\n   *\n   * @param asset The asset for which the public key should be fetched.\n   * @returns The public key hash (20 bytes) as a string.\n   */\n\n\n  this.selectPublicKey =\n  /*#__PURE__*/\n  function () {\n    var _ref19 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee16(_selector, asset) {\n      var response, chosenShard, tokenGateway;\n      return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return _this.queryShards(5);\n\n            case 2:\n              response = _context16.sent;\n              // Prioritize primary shards.\n              chosenShard = response.shards.sort(function (a, b) {\n                return a.primary && b.primary ? -1 : a.primary ? -1 : b.primary ? 1 : 0;\n              })[0];\n\n              if (chosenShard) {\n                _context16.next = 6;\n                break;\n              }\n\n              throw new Error(\"Unable to load public key from RenVM: no shards found\");\n\n            case 6:\n              // Get the gateway pubKey from the gateway with the right asset within\n              // the shard with the lowest total value locked.\n              tokenGateway = List(chosenShard.gateways).filter(function (gateway) {\n                return gateway.asset === asset;\n              }).first(undefined);\n\n              if (tokenGateway) {\n                _context16.next = 9;\n                break;\n              }\n\n              throw new Error(\"Unable to load public key from RenVM: no gateway for the asset \".concat(asset));\n\n            case 9:\n              return _context16.abrupt(\"return\", fromBase64(tokenGateway.pubKey));\n\n            case 10:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, _callee16);\n    }));\n\n    return function (_x29, _x30) {\n      return _ref19.apply(this, arguments);\n    };\n  }(); // In the future, this will be asynchronous. It returns a promise for\n  // compatibility.\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  this.getNetwork =\n  /*#__PURE__*/\n  function () {\n    var _ref20 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee17(_selector) {\n      return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              return _context17.abrupt(\"return\", _this.network);\n\n            case 1:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n      }, _callee17);\n    }));\n\n    return function (_x31) {\n      return _ref20.apply(this, arguments);\n    };\n  }();\n\n  this.getConfirmationTarget =\n  /*#__PURE__*/\n  function () {\n    var _ref21 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee18(selector, _chain) {\n      var _parseV1Selector2, asset;\n\n      return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              _parseV1Selector2 = parseV1Selector(selector), asset = _parseV1Selector2.asset;\n              _context18.t0 = _this.network;\n              _context18.next = _context18.t0 === \"mainnet\" ? 4 : _context18.t0 === \"testnet\" ? 12 : 20;\n              break;\n\n            case 4:\n              _context18.t1 = asset;\n              _context18.next = _context18.t1 === \"BTC\" ? 7 : _context18.t1 === \"ZEC\" ? 8 : _context18.t1 === \"BCH\" ? 9 : _context18.t1 === \"ETH\" ? 10 : 11;\n              break;\n\n            case 7:\n              return _context18.abrupt(\"return\", 6);\n\n            case 8:\n              return _context18.abrupt(\"return\", 24);\n\n            case 9:\n              return _context18.abrupt(\"return\", 15);\n\n            case 10:\n              return _context18.abrupt(\"return\", 30);\n\n            case 11:\n              return _context18.abrupt(\"break\", 20);\n\n            case 12:\n              _context18.t2 = asset;\n              _context18.next = _context18.t2 === \"BTC\" ? 15 : _context18.t2 === \"ZEC\" ? 16 : _context18.t2 === \"BCH\" ? 17 : _context18.t2 === \"ETH\" ? 18 : 19;\n              break;\n\n            case 15:\n              return _context18.abrupt(\"return\", 2);\n\n            case 16:\n              return _context18.abrupt(\"return\", 6);\n\n            case 17:\n              return _context18.abrupt(\"return\", 2);\n\n            case 18:\n              return _context18.abrupt(\"return\", 12);\n\n            case 19:\n              return _context18.abrupt(\"break\", 20);\n\n            case 20:\n              return _context18.abrupt(\"return\", undefined);\n\n            case 21:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, _callee18);\n    }));\n\n    return function (_x32, _x33) {\n      return _ref21.apply(this, arguments);\n    };\n  }();\n\n  this.estimateTransactionFee =\n  /*#__PURE__*/\n  function () {\n    var _ref22 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee19(_selector, chain) {\n      var fees;\n      return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return _this.getFees();\n\n            case 2:\n              fees = _context19.sent;\n              return _context19.abrupt(\"return\", fees[chain.legacyName ? chain.legacyName.toLowerCase() : chain.name.toLowerCase()]);\n\n            case 4:\n            case \"end\":\n              return _context19.stop();\n          }\n        }\n      }, _callee19);\n    }));\n\n    return function (_x34, _x35) {\n      return _ref22.apply(this, arguments);\n    };\n  }();\n\n  if (!provider) {\n    var rpcUrl = (getRenNetworkDetails(network) || {}).lightnode;\n\n    try {\n      provider = new HttpProvider(rpcUrl, logger);\n    } catch (error) {\n      if (/Invalid node URL/.exec(String(error && error.message))) {\n        throw new Error(\"Invalid network or provider URL: \\\"\".concat((getRenNetworkDetails(network) || {}).name || String(network), \"\\\"\"));\n      }\n\n      throw error;\n    }\n  }\n\n  this.network = network;\n  this.logger = logger;\n  this.provider = provider;\n\n  this.sendMessage =\n  /*#__PURE__*/\n  function () {\n    var _ref23 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee20(method, request) {\n      var retry,\n          timeout,\n          errorString,\n          _args20 = arguments;\n      return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              retry = _args20.length > 2 && _args20[2] !== undefined ? _args20[2] : 2;\n              timeout = _args20.length > 3 && _args20[3] !== undefined ? _args20[3] : 120 * SECONDS;\n              _context20.prev = 2;\n              _context20.next = 5;\n              return _this.provider.sendMessage(method, request, retry, timeout);\n\n            case 5:\n              return _context20.abrupt(\"return\", _context20.sent);\n\n            case 8:\n              _context20.prev = 8;\n              _context20.t0 = _context20[\"catch\"](2);\n              errorString = extractError(_context20.t0);\n\n              if (/(tx hash=[a-zA-Z0-9+\\/=]+ not found)/.exec(errorString)) {\n                _context20.t0.code = RenJSErrors.RenVMTransactionNotFound;\n              }\n\n              if (/(insufficient funds)/.exec(errorString)) {\n                _context20.t0.code = RenJSErrors.AmountTooSmall;\n              }\n\n              if (/(utxo spent or invalid index)/.exec(errorString)) {\n                _context20.t0.code = RenJSErrors.DepositSpentOrNotFound;\n              }\n\n              throw _context20.t0;\n\n            case 15:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n      }, _callee20, null, [[2, 8]]);\n    }));\n\n    return function (_x36, _x37) {\n      return _ref23.apply(this, arguments);\n    };\n  }();\n};","map":null,"metadata":{},"sourceType":"module"}