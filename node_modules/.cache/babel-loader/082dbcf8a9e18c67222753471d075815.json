{"ast":null,"code":"'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\n\nvar Script = require('../script');\n\nvar Output = require('./output');\n\nvar BufferReader = require('../encoding/bufferreader');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar Schnorr = require('../crypto/schnorr');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar Interpreter = require('../script/interpreter');\n\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff'; // By default, we sign with sighash_forkid\n\nvar DEFAULT_SIGN_FLAGS = Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID;\n\nvar sighashForForkId = function sighashForForkId(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(satoshisBN instanceof BN, 'For ForkId=0 signatures, satoshis or complete input must be provided');\n\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  }\n\n  ;\n\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter();\n\n    _.each(tx.inputs, function (input) {\n      writer.writeReverse(input.prevTxId);\n      writer.writeUInt32LE(input.outputIndex);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter();\n\n    _.each(tx.inputs, function (input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter();\n\n    if (_.isUndefined(n)) {\n      _.each(tx.outputs, function (output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n\n  function getHash(w) {\n    var buf = w.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n\n  ;\n  var writer = new BufferWriter(); // Version\n\n  writer.writeInt32LE(transaction.version); // Input prevouts/nSequence (none/all, depending on flags)\n\n  writer.write(hashPrevouts);\n  writer.write(hashSequence); //  outpoint (32-byte hash + 4-byte little endian)\n\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex); // scriptCode of the input (serialized as scripts inside CTxOuts)\n\n  writer.writeVarintNum(subscript.toBuffer().length);\n  writer.write(subscript.toBuffer()); // value of the output spent by this input (8-byte little endian)\n\n  writer.writeUInt64LEBN(satoshisBN); // nSequence of the input (4-byte little endian) \n\n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber); // Outputs (none/one/all, depending on flags)\n\n  writer.write(hashOutputs); // Locktime\n\n  writer.writeUInt32LE(transaction.nLockTime); // sighashType \n\n  writer.writeUInt32LE(sighashType >>> 0);\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} input's amount (for  ForkId signatures)\n *\n */\n\n\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN, flags) {\n  var Transaction = require('./transaction');\n\n  var Input = require('./input');\n\n  if (_.isUndefined(flags)) {\n    flags = DEFAULT_SIGN_FLAGS;\n  } // Copy transaction\n\n\n  var txcopy = Transaction.shallowCopy(transaction); // Copy script\n\n  subscript = new Script(subscript);\n\n  if (flags & Interpreter.SCRIPT_ENABLE_REPLAY_PROTECTION) {\n    // Legacy chain's value for fork id must be of the form 0xffxxxx.\n    // By xoring with 0xdead, we ensure that the value will be different\n    // from the original one, even if it already starts with 0xff.\n    var forkValue = sighashType >> 8;\n    var newForkValue = 0xff0000 | forkValue ^ 0xdead;\n    sighashType = newForkValue << 8 | sighashType & 0xff;\n  }\n\n  if (sighashType & Signature.SIGHASH_FORKID && flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  } // For no ForkId sighash, separators need to be removed.\n\n\n  subscript.removeCodeseparators();\n  var i;\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return Buffer.from(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(Buffer.from(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @param {signingMethod} signingMethod \"ecdsa\" or \"schnorr\" to sign a tx\n * @return {Signature}\n */\n\n\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN, flags, signingMethod) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN, flags);\n  signingMethod = signingMethod || \"ecdsa\";\n  var sig;\n\n  if (signingMethod === \"schnorr\") {\n    sig = Schnorr.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  } else if (signingMethod === \"ecdsa\") {\n    sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n      nhashtype: sighashType\n    });\n    return sig;\n  }\n}\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @param {flags} verification flags\n * @param {signingMethod} signingMethod \"ecdsa\" or \"schnorr\" to sign a tx\n * @return {boolean}\n */\n\n\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN, flags, signingMethod) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN, flags);\n  signingMethod = signingMethod || \"ecdsa\";\n\n  if (signingMethod === \"schnorr\") {\n    return Schnorr.verify(hashbuf, signature, publicKey, 'little');\n  } else if (signingMethod === \"ecdsa\") {\n    return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n  }\n}\n/**\n * @namespace Signing\n */\n\n\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":null,"metadata":{},"sourceType":"script"}