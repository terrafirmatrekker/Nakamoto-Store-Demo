{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar createHmac = require('create-hmac');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nvar ECSignature = require('./ecsignature');\n\nvar ZERO = Buffer.alloc(1, 0);\nvar ONE = Buffer.alloc(1, 1);\n\nvar ecurve = require('ecurve');\n\nvar secp256k1 = ecurve.getCurveByName('secp256k1'); // https://tools.ietf.org/html/rfc6979#section-3.2\n\nfunction deterministicGenerateK(hash, x, checkSig) {\n  typeforce(types.tuple(types.Hash256bit, types.Buffer256bit, types.Function), arguments); // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n\n  var k = Buffer.alloc(32, 0);\n  var v = Buffer.alloc(32, 1); // Step D\n\n  k = createHmac('sha256', k).update(v).update(ZERO).update(x).update(hash).digest(); // Step E\n\n  v = createHmac('sha256', k).update(v).digest(); // Step F\n\n  k = createHmac('sha256', k).update(v).update(ONE).update(x).update(hash).digest(); // Step G\n\n  v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n\n  v = createHmac('sha256', k).update(v).digest();\n  var T = BigInteger.fromBuffer(v); // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n\n  while (T.signum() <= 0 || T.compareTo(secp256k1.n) >= 0 || !checkSig(T)) {\n    k = createHmac('sha256', k).update(v).update(ZERO).digest();\n    v = createHmac('sha256', k).update(v).digest(); // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n\n    v = createHmac('sha256', k).update(v).digest();\n    T = BigInteger.fromBuffer(v);\n  }\n\n  return T;\n}\n\nvar N_OVER_TWO = secp256k1.n.shiftRight(1);\n\nfunction sign(hash, d) {\n  typeforce(types.tuple(types.Hash256bit, types.BigInt), arguments);\n  var x = d.toBuffer(32);\n  var e = BigInteger.fromBuffer(hash);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r, s;\n  deterministicGenerateK(hash, x, function (k) {\n    var Q = G.multiply(k);\n    if (secp256k1.isInfinity(Q)) return false;\n    r = Q.affineX.mod(n);\n    if (r.signum() === 0) return false;\n    s = k.modInverse(n).multiply(e.add(d.multiply(r))).mod(n);\n    if (s.signum() === 0) return false;\n    return true;\n  }); // enforce low S values, see bip62: 'low s values in signatures'\n\n  if (s.compareTo(N_OVER_TWO) > 0) {\n    s = n.subtract(s);\n  }\n\n  return new ECSignature(r, s);\n}\n\nfunction verify(hash, signature, Q) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature, types.ECPoint), arguments);\n  var n = secp256k1.n;\n  var G = secp256k1.G;\n  var r = signature.r;\n  var s = signature.s; // 1.4.1 Enforce r and s are both integers in the interval [1, n − 1]\n\n  if (r.signum() <= 0 || r.compareTo(n) >= 0) return false;\n  if (s.signum() <= 0 || s.compareTo(n) >= 0) return false; // 1.4.2 H = Hash(M), already done by the user\n  // 1.4.3 e = H\n\n  var e = BigInteger.fromBuffer(hash); // Compute s^-1\n\n  var sInv = s.modInverse(n); // 1.4.4 Compute u1 = es^−1 mod n\n  //               u2 = rs^−1 mod n\n\n  var u1 = e.multiply(sInv).mod(n);\n  var u2 = r.multiply(sInv).mod(n); // 1.4.5 Compute R = (xR, yR)\n  //               R = u1G + u2Q\n\n  var R = G.multiplyTwo(u1, Q, u2); // 1.4.5 (cont.) Enforce R is not at infinity\n\n  if (secp256k1.isInfinity(R)) return false; // 1.4.6 Convert the field element R.x to an integer\n\n  var xR = R.affineX; // 1.4.7 Set v = xR mod n\n\n  var v = xR.mod(n); // 1.4.8 If v = r, output \"valid\", and if v != r, output \"invalid\"\n\n  return v.equals(r);\n}\n\nmodule.exports = {\n  deterministicGenerateK: deterministicGenerateK,\n  sign: sign,\n  verify: verify,\n  // TODO: remove\n  __curve: secp256k1\n};","map":null,"metadata":{},"sourceType":"script"}