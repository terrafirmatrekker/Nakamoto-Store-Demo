{"ast":null,"code":"'use strict'; // Important references for schnorr implementation\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-05-15-schnorr.md\n// https://github.com/bitcoincashorg/bitcoincash.org/blob/master/spec/2019-11-15-schnorrmultisig.md#wallet-implementation-guidelines\n\nvar BN = require('./bn');\n\nvar Point = require('./point');\n\nvar Signature = require('./signature');\n\nvar PublicKey = require('../publickey');\n\nvar Random = require('./random');\n\nvar Hash = require('./hash');\n\nvar BufferUtil = require('../util/buffer');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar Schnorr = function Schnorr(obj) {\n  if (!(this instanceof Schnorr)) {\n    return new Schnorr(obj);\n  }\n\n  if (obj) {\n    this.set(obj);\n  }\n};\n/**\n   * Function written to ensure r part of signature is at least 32 bytes, when converting \n   * from a BN to type Buffer.\n   * The BN type naturally cuts off leading zeros, e.g.\n   * <BN: 4f92d8094f710bc11b93935ac157730dda26c5c2a856650dbd8ebcd730d2d4> 31 bytes\n   * Buffer <00 4f 92 d8 09 4f 71 0b c1 1b 93 93 5a c1 57 73 0d da 26 c5 c2 a8 56 65 0d bd 8e bc d7 30 d2 d4> 32 bytes\n   * Both types are equal, however Schnorr signatures must be a minimum of 64 bytes.\n   * In a previous implementation of this schnorr module, was resulting in 63 byte signatures. \n   * (Although it would have been verified, it's proper to ensure the min requirement)\n   * @param {*} s BN\n   * @return {Buffer}\n   */\n\n\nfunction getrBuffer(r) {\n  var rNaturalLength = r.toBuffer().length;\n\n  if (rNaturalLength < 32) {\n    return r.toBuffer({\n      size: 32\n    });\n  }\n\n  return r.toBuffer();\n}\n/**\n * Function written to ensure s part of signature is at least 32 bytes, when converting \n * from a BN to type Buffer.\n * The BN type naturally cuts off leading zeros, e.g.\n * <BN: 4f92d8094f710bc11b93935ac157730dda26c5c2a856650dbd8ebcd730d2d4> 31 bytes\n * Buffer <00 4f 92 d8 09 4f 71 0b c1 1b 93 93 5a c1 57 73 0d da 26 c5 c2 a8 56 65 0d bd 8e bc d7 30 d2 d4> 32 bytes\n * Both types are equal, however Schnorr signatures must be a minimum of 64 bytes.\n * In a previous implementation of this schnorr module, was resulting in 63 byte signatures. \n * (Although it would have been verified, it's proper to ensure the min requirement)\n * @param {*} s BN\n * @return {Buffer}\n */\n\n\nfunction getsBuffer(s) {\n  var sNaturalLength = s.toBuffer().length;\n\n  if (sNaturalLength < 32) {\n    return s.toBuffer({\n      size: 32\n    });\n  }\n\n  return s.toBuffer();\n}\n/* jshint maxcomplexity: 9 */\n\n\nSchnorr.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; // the endianness of hashbuf\n\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nSchnorr.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nSchnorr.prototype.toPublicKey = function () {\n  return this.privkey.toPublicKey();\n};\n\nSchnorr.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n\n  obj.compressed = this.pubkey.compressed;\n  obj.isSchnorr = true;\n  this.sig = new Signature(obj);\n  return this;\n};\n/**\n * Schnorr implementation used from bitcoinabc at https://reviews.bitcoinabc.org/D2501\n */\n\n\nSchnorr.prototype._findSignature = function (d, e) {\n  // d is the private key;\n  // e is the message to be signed\n  var n = Point.getN();\n  var G = Point.getG();\n  $.checkState(!d.lte(new BN(0)), new Error('privkey out of field of curve'));\n  $.checkState(!d.gte(n), new Error('privkey out of field of curve'));\n  var k = this.nonceFunctionRFC6979(d.toBuffer({\n    size: 32\n  }), e.toBuffer({\n    size: 32\n  }));\n  var P = G.mul(d);\n  var R = G.mul(k); // Find deterministic k\n\n  if (R.hasSquare()) {\n    k = k;\n  } else {\n    k = n.sub(k);\n  }\n\n  var r = R.getX();\n  var e0 = BN.fromBuffer(Hash.sha256(Buffer.concat([getrBuffer(r), Point.pointToCompressed(P), e.toBuffer({\n    size: 32\n  })])));\n  var s = e0.mul(d).add(k).mod(n);\n  return {\n    r: r,\n    s: s\n  };\n};\n\nSchnorr.prototype.sigError = function () {\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var sigLength = getrBuffer(this.sig.r).length + getsBuffer(this.sig.s).length;\n\n  if (!(sigLength === 64 || sigLength === 65)) {\n    return 'signature must be a 64 byte or 65 byte array';\n  }\n\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  var P = this.pubkey.point;\n  var G = Point.getG();\n  if (P.isInfinity()) return true;\n  var r = this.sig.r;\n  var s = this.sig.s;\n  var p = new BN('FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F', 'hex');\n  var n = Point.getN();\n\n  if (r.gte(p) || s.gte(n)) {\n    // (\"Failed >= condition\") \n    return true;\n  }\n\n  var Br = getrBuffer(this.sig.r);\n  var Bp = Point.pointToCompressed(P);\n  var hash = Hash.sha256(Buffer.concat([Br, Bp, hashbuf]));\n  var e = BN.fromBuffer(hash, 'big').umod(n);\n  var sG = G.mul(s);\n  var eP = P.mul(n.sub(e));\n  var R = sG.add(eP);\n\n  if (R.isInfinity() || !R.hasSquare() || !R.getX().eq(r)) {\n    return true;\n  }\n\n  return false;\n};\n\nSchnorr.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n\n  return this;\n};\n/**\n * RFC6979 deterministic nonce generation used from https://reviews.bitcoinabc.org/D2501\n * @param {Buffer} privkeybuf \n * @param {Buffer} msgbuf \n * @return k {BN}\n */\n\n\nSchnorr.prototype.nonceFunctionRFC6979 = function (privkey, msgbuf) {\n  var V = Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\", \"hex\");\n  var K = Buffer.from(\"0000000000000000000000000000000000000000000000000000000000000000\", \"hex\");\n  var blob = Buffer.concat([privkey, msgbuf, Buffer.from(\"\", \"ascii\"), Buffer.from(\"Schnorr+SHA256  \", \"ascii\")]);\n  K = Hash.sha256hmac(Buffer.concat([V, Buffer.from('00', 'hex'), blob]), K);\n  V = Hash.sha256hmac(V, K);\n  K = Hash.sha256hmac(Buffer.concat([V, Buffer.from('01', 'hex'), blob]), K);\n  V = Hash.sha256hmac(V, K);\n  var k = new BN(0);\n  var T;\n\n  while (true) {\n    V = Hash.sha256hmac(V, K);\n    T = BN.fromBuffer(V);\n    k = T;\n    $.checkState(V.length >= 32, \"V length should be >= 32\");\n\n    if (k.gt(new BN(0)) && k.lt(Point.getN())) {\n      break;\n    }\n\n    K = Hash.sha256hmac(Buffer.concat([V, Buffer.from(\"00\", 'hex')]), K);\n    V = Hash.hmac(Hash.sha256, V, K);\n  }\n\n  return k;\n};\n\nSchnorr.sign = function (hashbuf, privkey, endian) {\n  return Schnorr().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\n\nSchnorr.verify = function (hashbuf, sig, pubkey, endian) {\n  return Schnorr().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\n\nmodule.exports = Schnorr;","map":null,"metadata":{},"sourceType":"script"}