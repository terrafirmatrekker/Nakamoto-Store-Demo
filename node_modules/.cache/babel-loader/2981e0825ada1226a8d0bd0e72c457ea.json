{"ast":null,"code":"import _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { BlockCipher } from './cipher-core.js'; // Lookup tables\n\nvar _SBOX = [];\nvar INV_SBOX = [];\nvar _SUB_MIX_0 = [];\nvar _SUB_MIX_1 = [];\nvar _SUB_MIX_2 = [];\nvar _SUB_MIX_3 = [];\nvar INV_SUB_MIX_0 = [];\nvar INV_SUB_MIX_1 = [];\nvar INV_SUB_MIX_2 = [];\nvar INV_SUB_MIX_3 = []; // Compute lookup tables\n// Compute double table\n\nvar d = [];\n\nfor (var i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = i << 1 ^ 0x11b;\n  }\n} // Walk GF(2^8)\n\n\nvar x = 0;\nvar xi = 0;\n\nfor (var _i = 0; _i < 256; _i += 1) {\n  // Compute sbox\n  var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n  sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x; // Compute multiplication\n\n  var x2 = d[x];\n  var x4 = d[x2];\n  var x8 = d[x4]; // Compute sub bytes, mix columns tables\n\n  var t = d[sx] * 0x101 ^ sx * 0x1010100;\n  _SUB_MIX_0[x] = t << 24 | t >>> 8;\n  _SUB_MIX_1[x] = t << 16 | t >>> 16;\n  _SUB_MIX_2[x] = t << 8 | t >>> 24;\n  _SUB_MIX_3[x] = t; // Compute inv sub bytes, inv mix columns tables\n\n  t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n  INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;\n  INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;\n  INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;\n  INV_SUB_MIX_3[sx] = t; // Compute next counter\n\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n} // Precomputed Rcon lookup\n\n\nvar RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n/**\n * AES block cipher algorithm.\n */\n\nexport var AESAlgo =\n/*#__PURE__*/\nfunction (_BlockCipher) {\n  _inherits(AESAlgo, _BlockCipher);\n\n  function AESAlgo() {\n    _classCallCheck(this, AESAlgo);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AESAlgo).apply(this, arguments));\n  }\n\n  _createClass(AESAlgo, [{\n    key: \"_doReset\",\n    value: function _doReset() {\n      var t; // Skip reset of nRounds has been set before and key did not change\n\n      if (this._nRounds && this._keyPriorReset === this._key) {\n        return;\n      } // Shortcuts\n\n\n      this._keyPriorReset = this._key;\n      var key = this._keyPriorReset;\n      var keyWords = key.words;\n      var keySize = key.sigBytes / 4; // Compute number of rounds\n\n      this._nRounds = keySize + 6;\n      var nRounds = this._nRounds; // Compute number of key schedule rows\n\n      var ksRows = (nRounds + 1) * 4; // Compute key schedule\n\n      this._keySchedule = [];\n      var keySchedule = this._keySchedule;\n\n      for (var ksRow = 0; ksRow < ksRows; ksRow += 1) {\n        if (ksRow < keySize) {\n          keySchedule[ksRow] = keyWords[ksRow];\n        } else {\n          t = keySchedule[ksRow - 1];\n\n          if (!(ksRow % keySize)) {\n            // Rot word\n            t = t << 8 | t >>> 24; // Sub word\n\n            t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 0xff] << 16 | _SBOX[t >>> 8 & 0xff] << 8 | _SBOX[t & 0xff]; // Mix Rcon\n\n            t ^= RCON[ksRow / keySize | 0] << 24;\n          } else if (keySize > 6 && ksRow % keySize === 4) {\n            // Sub word\n            t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 0xff] << 16 | _SBOX[t >>> 8 & 0xff] << 8 | _SBOX[t & 0xff];\n          }\n\n          keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n        }\n      } // Compute inv key schedule\n\n\n      this._invKeySchedule = [];\n      var invKeySchedule = this._invKeySchedule;\n\n      for (var invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n        var _ksRow = ksRows - invKsRow;\n\n        if (invKsRow % 4) {\n          t = keySchedule[_ksRow];\n        } else {\n          t = keySchedule[_ksRow - 4];\n        }\n\n        if (invKsRow < 4 || _ksRow <= 4) {\n          invKeySchedule[invKsRow] = t;\n        } else {\n          invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]] ^ INV_SUB_MIX_1[_SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[_SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n        }\n      }\n    }\n  }, {\n    key: \"encryptBlock\",\n    value: function encryptBlock(M, offset) {\n      this._doCryptBlock(M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX);\n    }\n  }, {\n    key: \"decryptBlock\",\n    value: function decryptBlock(M, offset) {\n      var _M = M; // Swap 2nd and 4th rows\n\n      var t = _M[offset + 1];\n      _M[offset + 1] = _M[offset + 3];\n      _M[offset + 3] = t;\n\n      this._doCryptBlock(_M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); // Inv swap 2nd and 4th rows\n\n\n      t = _M[offset + 1];\n      _M[offset + 1] = _M[offset + 3];\n      _M[offset + 3] = t;\n    }\n  }, {\n    key: \"_doCryptBlock\",\n    value: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n      var _M = M; // Shortcut\n\n      var nRounds = this._nRounds; // Get input, add round key\n\n      var s0 = _M[offset] ^ keySchedule[0];\n      var s1 = _M[offset + 1] ^ keySchedule[1];\n      var s2 = _M[offset + 2] ^ keySchedule[2];\n      var s3 = _M[offset + 3] ^ keySchedule[3]; // Key schedule row counter\n\n      var ksRow = 4; // Rounds\n\n      for (var round = 1; round < nRounds; round += 1) {\n        // Shift rows, sub bytes, mix columns, add round key\n        var _t = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1;\n\n        var _t2 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1;\n\n        var _t3 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1;\n\n        var _t4 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow];\n\n        ksRow += 1; // Update state\n\n        s0 = _t;\n        s1 = _t2;\n        s2 = _t3;\n        s3 = _t4;\n      } // Shift rows, sub bytes, add round key\n\n\n      var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1;\n      var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1;\n      var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1;\n      var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow];\n      ksRow += 1; // Set output\n\n      _M[offset] = t0;\n      _M[offset + 1] = t1;\n      _M[offset + 2] = t2;\n      _M[offset + 3] = t3;\n    }\n  }]);\n\n  return AESAlgo;\n}(BlockCipher);\nAESAlgo.keySize = 256 / 32;\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\n\nexport var AES = BlockCipher._createHelper(AESAlgo);","map":null,"metadata":{},"sourceType":"module"}