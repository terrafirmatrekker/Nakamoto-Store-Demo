{"ast":null,"code":"import _defineProperty from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/* eslint-disable security/detect-object-injection */\nimport BigNumber from \"bignumber.js\";\nexport var assert = function assert(assertion, sentence) {\n  if (!assertion) {\n    throw new Error(\"Failed assertion\".concat(sentence ? \": \".concat(sentence) : \"\"));\n  }\n\n  return true;\n};\n/**\n * The following is a set of rudimentary type validation functions.\n *\n * The main function is `assertType`, which accepts a type and a dictionary of\n * values.\n *\n * The type must be a string that matches the following pattern:\n *\n * ```\n * TYPE:\n *   | TYPE '|' TYPE\n *   | Array<TYPE>\n *   | TYPE[]\n *   | PRIMITIVE_TYPE\n *\n * PRIMITIVE_TYPE:\n *   | \"string\"\n *   | \"number\"\n *   | \"bigint\"\n *   | \"boolean\"\n *   | \"symbol\"\n *   | \"undefined\"\n *   | \"object\"\n *   | \"function\"\n *   | \"null\"\n *   | \"any\"\n *   | \"Buffer\"\n *   | \"BigNumber\"\n * ```\n *\n * Types are matched by a regex so '|' can't be used at multiple levels, e.g.\n * `string | Array<string | number>`.\n */\n\nexport var assertType = function assertType(type, objects) {\n  if (isArrayType(type)) {\n    return assertArray(type, objects);\n  }\n\n  if (isUnionType(type)) {\n    return assertTypeUnion(type, objects);\n  }\n\n  return assertTypeCheck(is(type), objects, type);\n};\n\nvar typeOf = function typeOf(v) {\n  return v === null ? \"null\" : BigNumber.isBigNumber(v) ? \"BigNumber\" : Buffer.isBuffer(v) ? \"Buffer\" : typeof v;\n};\n\nvar assertTypeCheck = function assertTypeCheck(type, objects, typeDescription) {\n  for (var _i = 0, _Object$keys = Object.keys(objects); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    // eslint-disable-next-line security/detect-object-injection\n    var value = objects[key];\n\n    if (!type(value, key)) {\n      var readableType = Array.isArray(value) ? \"any[]\" : typeOf(value);\n      throw new Error(\"Expected \".concat(key, \" to be of type '\").concat(typeDescription, \"', instead got '\").concat(readableType, \"'.\"));\n    }\n  }\n\n  return true;\n};\n\nvar is = function is(type) {\n  return function (v) {\n    return type === \"any\" ? true : typeOf(v) === type;\n  };\n};\n\nvar isUnionType = function isUnionType(unionType) {\n  var types = unionType.split(\" | \");\n  return types.length > 1 ? types : false;\n};\n\nvar isArrayType = function isArrayType(arrayType) {\n  // Check with simple string operations to avoid running slow RegExs if there\n  // isn't a match.\n  var isArray = arrayType.slice(0, 6) === \"Array<\" && arrayType.slice(-1) === \">\";\n\n  if (isArray) {\n    var arrayMatch = /^Array<(.*)>$/.exec(arrayType);\n\n    if (arrayMatch) {\n      var _arrayMatch = _slicedToArray(arrayMatch, 2),\n          type = _arrayMatch[1];\n\n      return type;\n    }\n  }\n\n  var isBracketArray = arrayType.indexOf(\" \") === -1 && arrayType.slice(-2) === \"[]\";\n\n  if (isBracketArray) {\n    var bracketMatch = /^([^ ]*)\\[\\]$/.exec(arrayType);\n\n    if (bracketMatch) {\n      var _bracketMatch = _slicedToArray(bracketMatch, 2),\n          _type = _bracketMatch[1];\n\n      return _type;\n    }\n  }\n\n  return false;\n};\n\nvar assertTypeUnion = function assertTypeUnion(unionType, objects) {\n  var types = unionType.split(\" | \");\n  return assertTypeCheck(function (v, key) {\n    return types.reduce(function (acc, type) {\n      if (acc) {\n        return acc;\n      }\n\n      if (isArrayType(type)) {\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          assertArray(type, _defineProperty({}, key, v));\n          return true;\n        } catch (error) {\n          return false;\n        }\n      }\n\n      return is(type)(v);\n    }, false);\n  }, objects, unionType);\n};\n\nvar assertArray = function assertArray(arrayType, objects) {\n  var type = isArrayType(arrayType);\n\n  if (!type) {\n    throw new Error(\"Invalid array type \".concat(arrayType));\n  }\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(objects); _i2 < _Object$keys2.length; _i2++) {\n    var key = _Object$keys2[_i2];\n    var value = objects[key];\n    assertTypeCheck(function (v) {\n      return Array.isArray(v);\n    }, {\n      value: value\n    }, \"any[]\");\n\n    for (var i = 0; i < value.length; i++) {\n      assertType(type, _defineProperty({}, \"\".concat(key, \"[\").concat(i, \"]\"), value[i]));\n    }\n  }\n\n  return true;\n};\n\nexport var assertObject = function assertObject(fieldTypes, objects) {\n  for (var _i3 = 0, _Object$keys3 = Object.keys(objects); _i3 < _Object$keys3.length; _i3++) {\n    var key = _Object$keys3[_i3];\n    var value = objects[key];\n\n    for (var _i4 = 0, _Object$keys4 = Object.keys(fieldTypes); _i4 < _Object$keys4.length; _i4++) {\n      var field = _Object$keys4[_i4];\n\n      if (typeof fieldTypes[field] === \"object\") {\n        assertObject(fieldTypes[field], _defineProperty({}, \"\".concat(key, \"[\\\"\").concat(field, \"\\\"]\"), value[field]));\n      } else if (typeof fieldTypes[field] === \"string\") {\n        assertType(fieldTypes[field], _defineProperty({}, \"\".concat(key, \"[\\\"\").concat(field, \"\\\"]\"), value[field]));\n      } else {\n        throw new Error(\"Invalid object type definition \".concat(typeof fieldTypes[field]));\n      }\n    }\n  }\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"module"}