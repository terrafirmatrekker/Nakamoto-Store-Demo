{"ast":null,"code":"import { assert, fixSignatureSimple, signatureToBuffer } from \"@renproject/utils\";\nimport { unmarshalTypedPackValue } from \"./pack/pack\";\nexport var unmarshalMintTx = function unmarshalMintTx(response) {\n  // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.\n  assert(/\\/to/.exec(response.tx.selector) !== null, \"Expected mint details but got back burn details (\".concat(response.tx.hash, \" - \").concat(response.tx.selector, \")\"));\n  var out;\n  var inValue = unmarshalTypedPackValue(response.tx.in);\n\n  if (response.tx.out) {\n    out = unmarshalTypedPackValue(response.tx.out); // Temporary fix to support v0.4.\n\n    if (out.revert && out.revert.length === 0) {\n      out.revert = undefined;\n    }\n\n    if (out.sig) {\n      var _ref = [out.sig.slice(0, 32), out.sig.slice(32, 64), out.sig[64] % 27],\n          r = _ref[0],\n          s = _ref[1],\n          v = _ref[2];\n      out.signature = signatureToBuffer(fixSignatureSimple(r, s, v));\n      out.nhash = inValue.nhash;\n    }\n  }\n\n  return {\n    hash: response.tx.hash,\n    txStatus: response.txStatus,\n    to: response.tx.selector,\n    in: inValue,\n    out: out\n  };\n};\nexport var unmarshalBurnTx = function unmarshalBurnTx(response) {\n  assert(/\\/from/.exec(response.tx.selector) !== null, \"Expected burn details but got back mint details (\".concat(response.tx.hash, \" - \").concat(response.tx.selector, \")\"));\n  var out;\n\n  if (response.tx.out) {\n    out = unmarshalTypedPackValue(response.tx.out);\n  }\n\n  return {\n    hash: response.tx.hash,\n    to: response.tx.selector,\n    in: unmarshalTypedPackValue(response.tx.in),\n    txStatus: response.txStatus,\n    out: out\n  };\n}; // const unmarshalAssetFees = (fees: Fees): RenVMAssetFees => {\n//     const { lock, release, ...tokens } = fees;\n//     // TODO: Fix type errors.\n//     return ({\n//         lock: decodeNumber(lock).toNumber(),\n//         release: decodeNumber(release).toNumber(),\n//         ...Object.keys(tokens).reduce(\n//             (acc, token) => ({\n//                 ...acc,\n//                 [token]: {\n//                     mint: decodeNumber(fees[token].mint).toNumber(),\n//                     burn: decodeNumber(fees[token].burn).toNumber(),\n//                 },\n//             }),\n//             {},\n//         ),\n//     } as unknown) as RenVMAssetFees;\n// };\n// export const unmarshalFees = (response: ResponseQueryFees): RenVMFees => {\n//     const fees = {};\n//     for (const key of Object.keys(response)) {\n//         fees[key] = unmarshalAssetFees(response[key]);\n//     }\n//     return fees;\n// };","map":null,"metadata":{},"sourceType":"module"}