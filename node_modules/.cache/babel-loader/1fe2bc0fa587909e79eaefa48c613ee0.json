{"ast":null,"code":"var base58 = require('./crypto/base58');\n\nvar segwit = require('./crypto/segwit_addr');\n\nvar cryptoUtils = require('./crypto/utils');\n\nvar DEFAULT_NETWORK_TYPE = 'prod';\n\nfunction getDecoded(address) {\n  try {\n    return base58.decode(address);\n  } catch (e) {\n    // if decoding fails, assume invalid address\n    return null;\n  }\n}\n\nfunction getChecksum(hashFunction, payload) {\n  // Each currency may implement different hashing algorithm\n  switch (hashFunction) {\n    case 'blake256':\n      return cryptoUtils.blake256Checksum(payload);\n      break;\n\n    case 'sha256':\n    default:\n      return cryptoUtils.sha256Checksum(payload);\n  }\n}\n\nfunction getAddressType(address, currency) {\n  currency = currency || {}; // should be 25 bytes per btc address spec and 26 decred\n\n  var expectedLength = currency.expectedLength || 25;\n  var hashFunction = currency.hashFunction || 'sha256';\n  var decoded = getDecoded(address);\n\n  if (decoded) {\n    var length = decoded.length;\n\n    if (length !== expectedLength) {\n      return null;\n    }\n\n    var checksum = cryptoUtils.toHex(decoded.slice(length - 4, length)),\n        body = cryptoUtils.toHex(decoded.slice(0, length - 4)),\n        goodChecksum = getChecksum(hashFunction, body);\n    return checksum === goodChecksum ? cryptoUtils.toHex(decoded.slice(0, expectedLength - 24)) : null;\n  }\n\n  return null;\n}\n\nfunction isValidP2PKHandP2SHAddress(address, currency, networkType) {\n  networkType = networkType || DEFAULT_NETWORK_TYPE;\n  var correctAddressTypes;\n  var addressType = getAddressType(address, currency);\n\n  if (addressType) {\n    if (networkType === 'prod' || networkType === 'testnet') {\n      correctAddressTypes = currency.addressTypes[networkType];\n    } else {\n      correctAddressTypes = currency.addressTypes.prod.concat(currency.addressTypes.testnet);\n    }\n\n    return correctAddressTypes.indexOf(addressType) >= 0;\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  isValidAddress: function isValidAddress(address, currency, networkType) {\n    return isValidP2PKHandP2SHAddress(address, currency, networkType) || segwit.isValidAddress(address, currency.segwitHrp);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}