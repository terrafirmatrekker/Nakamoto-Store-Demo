{"ast":null,"code":"var _classCallCheck = require(\"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\n/* eslint-disable */\nvar types = require('./types');\n\nvar typeforce = require('typeforce');\n\nvar varuint = require('varuint-bitcoin'); // https://github.com/feross/buffer/blob/master/index.js#L1127\n\n\nfunction verifuint(value, max) {\n  if (typeof value !== 'number') throw new Error('cannot write a non-number as a number');\n  if (value < 0) throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value) throw new Error('value has a fractional component');\n}\n\nfunction readUInt64LE(buffer, offset) {\n  var a = buffer.readUInt32LE(offset);\n  var b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\n\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\n\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  var j = buffer.length - 1;\n  var tmp = 0;\n\n  for (var i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n\n  return buffer;\n}\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\n\n\nvar BufferWriter =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function BufferWriter(buffer) {\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, BufferWriter);\n\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n\n  _createClass(BufferWriter, [{\n    key: \"writeUInt8\",\n    value: function writeUInt8(i) {\n      this.offset = this.buffer.writeUInt8(i, this.offset);\n    }\n  }, {\n    key: \"writeInt32\",\n    value: function writeInt32(i) {\n      this.offset = this.buffer.writeInt32LE(i, this.offset);\n    }\n  }, {\n    key: \"writeUInt32\",\n    value: function writeUInt32(i) {\n      this.offset = this.buffer.writeUInt32LE(i, this.offset);\n    }\n  }, {\n    key: \"writeUInt64\",\n    value: function writeUInt64(i) {\n      this.offset = writeUInt64LE(this.buffer, i, this.offset);\n    }\n  }, {\n    key: \"writeVarInt\",\n    value: function writeVarInt(i) {\n      varuint.encode(i, this.buffer, this.offset);\n      this.offset += varuint.encode.bytes;\n    }\n  }, {\n    key: \"writeSlice\",\n    value: function writeSlice(slice) {\n      if (this.buffer.length < this.offset + slice.length) {\n        throw new Error('Cannot write slice out of bounds');\n      }\n\n      this.offset += slice.copy(this.buffer, this.offset);\n    }\n  }, {\n    key: \"writeVarSlice\",\n    value: function writeVarSlice(slice) {\n      this.writeVarInt(slice.length);\n      this.writeSlice(slice);\n    }\n  }, {\n    key: \"writeVector\",\n    value: function writeVector(vector) {\n      var _this = this;\n\n      this.writeVarInt(vector.length);\n      vector.forEach(function (buf) {\n        return _this.writeVarSlice(buf);\n      });\n    }\n  }]);\n\n  return BufferWriter;\n}();\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\n\n\nvar BufferReader =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function BufferReader(buffer) {\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, BufferReader);\n\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n\n  _createClass(BufferReader, [{\n    key: \"readUInt8\",\n    value: function readUInt8() {\n      var result = this.buffer.readUInt8(this.offset);\n      this.offset++;\n      return result;\n    }\n  }, {\n    key: \"readInt32\",\n    value: function readInt32() {\n      var result = this.buffer.readInt32LE(this.offset);\n      this.offset += 4;\n      return result;\n    }\n  }, {\n    key: \"readUInt32\",\n    value: function readUInt32() {\n      var result = this.buffer.readUInt32LE(this.offset);\n      this.offset += 4;\n      return result;\n    }\n  }, {\n    key: \"readUInt64\",\n    value: function readUInt64() {\n      var result = readUInt64LE(this.buffer, this.offset);\n      this.offset += 8;\n      return result;\n    }\n  }, {\n    key: \"readVarInt\",\n    value: function readVarInt() {\n      var vi = varuint.decode(this.buffer, this.offset);\n      this.offset += varuint.decode.bytes;\n      return vi;\n    }\n  }, {\n    key: \"readSlice\",\n    value: function readSlice(n) {\n      if (this.buffer.length < this.offset + n) {\n        throw new Error('Cannot read slice out of bounds');\n      }\n\n      var result = this.buffer.slice(this.offset, this.offset + n);\n      this.offset += n;\n      return result;\n    }\n  }, {\n    key: \"readVarSlice\",\n    value: function readVarSlice() {\n      return this.readSlice(this.readVarInt());\n    }\n  }, {\n    key: \"readVector\",\n    value: function readVector() {\n      var count = this.readVarInt();\n      var vector = [];\n\n      for (var i = 0; i < count; i++) {\n        vector.push(this.readVarSlice());\n      }\n\n      return vector;\n    }\n  }]);\n\n  return BufferReader;\n}();\n\nmodule.exports = {\n  readUInt64LE: readUInt64LE,\n  writeUInt64LE: writeUInt64LE,\n  reverseBuffer: reverseBuffer,\n  BufferWriter: BufferWriter,\n  BufferReader: BufferReader\n};","map":null,"metadata":{},"sourceType":"script"}