{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Callable, isDefined } from \"@renproject/utils\";\nimport axios from \"axios\";\nimport https from \"https\";\nimport { fixUTXO, fixValue, sortUTXOs, DEFAULT_TIMEOUT } from \"./API\";\nexport var InsightClass = function InsightClass(url) {\n  var _this = this;\n\n  _classCallCheck(this, InsightClass);\n\n  this.fetchUTXOs =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(address) {\n      var confirmations,\n          url,\n          response,\n          data,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              confirmations = _args.length > 1 && _args[1] !== undefined ? _args[1] : 0;\n              url = \"\".concat(_this.url, \"/addr/\").concat(address, \"/utxo\");\n              _context.next = 4;\n              return axios.get(url, {\n                // TODO: Remove when certificate is fixed.\n                httpsAgent: new https.Agent({\n                  rejectUnauthorized: false\n                }),\n                timeout: DEFAULT_TIMEOUT\n              });\n\n            case 4:\n              response = _context.sent;\n              data = typeof response.data === \"string\" ? JSON.parse(response.data) : response.data;\n              _context.next = 8;\n              return Promise.all(data.filter(function (utxo) {\n                return confirmations === 0 || utxo.confirmations >= confirmations;\n              }).map(function (utxo) {\n                return {\n                  txHash: utxo.txid,\n                  amount: isDefined(utxo.satoshis) ? utxo.satoshis.toString() : isDefined(utxo.amount) ? fixValue(utxo.amount, 8).toFixed() : undefined,\n                  // script_hex: utxo.scriptPubKey,\n                  vOut: utxo.vout,\n                  confirmations: utxo.confirmations || 0\n                };\n              }) // If the amount is undefined, fetch the UTXO again.\n              // This is due to the Digibyte explorer not returning\n              // amounts correctly when fetching UTXOs.\n              .map(function (utxo) {\n                return isDefined(utxo.amount) ? utxo : _this.fetchUTXO(utxo.txHash, utxo.vOut);\n              }));\n\n            case 8:\n              _context.t0 = sortUTXOs;\n              return _context.abrupt(\"return\", _context.sent.sort(_context.t0));\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this.fetchTXs =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(address) {\n      var confirmations,\n          url,\n          response,\n          data,\n          received,\n          _iteratorNormalCompletion,\n          _didIteratorError,\n          _iteratorError,\n          _iterator,\n          _step,\n          tx,\n          i,\n          vout,\n          _args2 = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              confirmations = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 0;\n              url = \"\".concat(_this.url, \"/txs/?address=\").concat(address);\n              _context2.next = 4;\n              return axios.get(url, {\n                // TODO: Remove when certificate is fixed.\n                httpsAgent: new https.Agent({\n                  rejectUnauthorized: false\n                }),\n                timeout: DEFAULT_TIMEOUT\n              });\n\n            case 4:\n              response = _context2.sent;\n              data = typeof response.data === \"string\" ? JSON.parse(response.data) : response.data;\n              received = [];\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context2.prev = 10;\n\n              for (_iterator = data.txs[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                tx = _step.value;\n\n                for (i = 0; i < tx.vout.length; i++) {\n                  vout = tx.vout[i];\n\n                  if (vout.scriptPubKey.addresses.indexOf(address) >= 0) {\n                    received.push({\n                      txHash: tx.txid,\n                      amount: fixValue(parseFloat(vout.value), 8).toFixed(),\n                      vOut: i,\n                      confirmations: tx.confirmations || 0\n                    });\n                  }\n                }\n              }\n\n              _context2.next = 18;\n              break;\n\n            case 14:\n              _context2.prev = 14;\n              _context2.t0 = _context2[\"catch\"](10);\n              _didIteratorError = true;\n              _iteratorError = _context2.t0;\n\n            case 18:\n              _context2.prev = 18;\n              _context2.prev = 19;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 21:\n              _context2.prev = 21;\n\n              if (!_didIteratorError) {\n                _context2.next = 24;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 24:\n              return _context2.finish(21);\n\n            case 25:\n              return _context2.finish(18);\n\n            case 26:\n              return _context2.abrupt(\"return\", received.filter(function (utxo) {\n                return confirmations === 0 || utxo.confirmations >= confirmations;\n              }).sort(sortUTXOs));\n\n            case 27:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[10, 14, 18, 26], [19,, 21, 25]]);\n    }));\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  this.fetchUTXO =\n  /*#__PURE__*/\n  function () {\n    var _ref3 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(txHash, vOut) {\n      var url, tx;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              url = \"\".concat(_this.url, \"/tx/\").concat(txHash);\n              _context3.next = 3;\n              return axios.get(url, {\n                timeout: DEFAULT_TIMEOUT\n              });\n\n            case 3:\n              tx = _context3.sent.data;\n              return _context3.abrupt(\"return\", fixUTXO({\n                txHash: txHash,\n                amount: tx.vout[vOut].value.toString(),\n                vOut: vOut,\n                confirmations: tx.confirmations\n              }, 8));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  this.broadcastTransaction =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(txHex) {\n      var url, response;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              url = \"\".concat(_this.url, \"/tx/send\");\n              _context4.next = 3;\n              return axios.post(url, {\n                rawtx: txHex\n              }, {\n                timeout: DEFAULT_TIMEOUT\n              });\n\n            case 3:\n              response = _context4.sent;\n\n              if (!response.data.error) {\n                _context4.next = 6;\n                break;\n              }\n\n              throw new Error(response.data.error);\n\n            case 6:\n              return _context4.abrupt(\"return\", response.data.txid);\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  this.url = url.replace(/\\/$/, \"\");\n};\nexport var Insight = Callable(InsightClass);","map":null,"metadata":{},"sourceType":"module"}