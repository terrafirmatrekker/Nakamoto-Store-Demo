{"ast":null,"code":"import _objectSpread from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _defineProperty from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _EthereumConfigMap;\n\nimport { getRenNetworkDetails, RenNetwork } from \"@renproject/interfaces\";\nimport { assertType, extractError, fromHex, Ox, payloadToABI, utilsWithChainNetwork } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport Web3 from \"web3\";\nimport { renDevnetVDot3, renMainnet, renMainnetVDot3, renTestnet, renTestnetVDot3 } from \"./networks\";\nimport { addressIsValid, extractBurnDetails, findBurnByNonce, findTransactionBySigHash, forwardWeb3Events, getGatewayAddress, getTokenAddress, ignorePromiEventError, manualPromiEvent, submitToEthereum, withDefaultAccount } from \"./utils\";\nexport var EthereumConfigMap = (_EthereumConfigMap = {}, _defineProperty(_EthereumConfigMap, RenNetwork.Mainnet, renMainnet), _defineProperty(_EthereumConfigMap, RenNetwork.Testnet, renTestnet), _defineProperty(_EthereumConfigMap, RenNetwork.MainnetVDot3, renMainnetVDot3), _defineProperty(_EthereumConfigMap, RenNetwork.TestnetVDot3, renTestnetVDot3), _defineProperty(_EthereumConfigMap, RenNetwork.DevnetVDot3, renDevnetVDot3), _EthereumConfigMap);\n\nvar isEthereumConfig = function isEthereumConfig(renNetwork) {\n  return !!renNetwork.addresses;\n};\n\nvar resolveNetwork = function resolveNetwork(renNetwork) {\n  if (!renNetwork) {\n    return EthereumConfigMap[RenNetwork.Mainnet];\n  }\n\n  var networkConfig;\n\n  if (renNetwork && isEthereumConfig(renNetwork)) {\n    networkConfig = renNetwork;\n  } else if (renNetwork) {\n    var networkDetails = getRenNetworkDetails(renNetwork);\n\n    if (EthereumConfigMap[networkDetails.name]) {\n      networkConfig = EthereumConfigMap[networkDetails.name];\n    }\n  }\n\n  if (!networkConfig) {\n    throw new Error(\"Unrecognized network \".concat(renNetwork, \".\"));\n  }\n\n  return networkConfig;\n};\n\nexport var EthereumBaseChain = function EthereumBaseChain(web3Provider, renNetwork) {\n  var _this = this;\n\n  _classCallCheck(this, EthereumBaseChain);\n\n  this.chain = EthereumBaseChain.chain;\n  this.name = EthereumBaseChain.chain;\n  this.legacyName = \"Eth\";\n  this.logRequestLimit = undefined;\n  this.utils = utilsWithChainNetwork(EthereumBaseChain.utils, function () {\n    return _this.renNetworkDetails;\n  });\n\n  this.getTokenContractAddress =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(asset) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!_this.web3 || !_this.renNetworkDetails)) {\n                _context.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              return _context.abrupt(\"return\", getTokenAddress(_this.renNetworkDetails, _this.web3, asset));\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this.getGatewayContractAddress =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(token) {\n      var gatewayAddress;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!_this.web3 || !_this.renNetworkDetails)) {\n                _context2.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              _context2.next = 4;\n              return getGatewayAddress(_this.renNetworkDetails, _this.web3, token);\n\n            case 4:\n              gatewayAddress = _context2.sent;\n\n              if (!(gatewayAddress === \"0x0000000000000000000000000000000000000000\")) {\n                _context2.next = 7;\n                break;\n              }\n\n              throw new Error(\"Asset not supported on mint-chain.\");\n\n            case 7:\n              return _context2.abrupt(\"return\", gatewayAddress);\n\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  this.withProvider = function (web3Provider) {\n    _this.web3 = new Web3(web3Provider);\n    return _this;\n  };\n  /**\n   * See [LockChain.initialize].\n   */\n\n\n  this.initialize = function (renNetwork) {\n    _this.renNetworkDetails = _this.renNetworkDetails || EthereumConfigMap[getRenNetworkDetails(renNetwork).name];\n\n    if (!_this.renNetworkDetails) {\n      throw new Error(\"Unable to set \".concat(_this.name, \" network for RenVM network \").concat(getRenNetworkDetails(renNetwork).name, \". Please provide \").concat(_this.name, \" network details to \").concat(_this.name, \" constructor.\"));\n    }\n\n    return _this;\n  }; // Supported assets\n\n\n  this.assetIsNative = function (asset) {\n    return asset === \"ETH\";\n  };\n  /**\n   * `assetIsSupported` should return true if the asset is native to the\n   * MintChain.\n   *\n   * ```ts\n   * ethereum.assetIsSupported = asset => asset === \"ETH\";\n   * ```\n   */\n\n\n  this.assetIsSupported =\n  /*#__PURE__*/\n  function () {\n    var _ref3 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(asset) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!_this.assetIsNative(asset)) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", true);\n\n            case 2:\n              if (!(!_this.web3 || !_this.renNetworkDetails)) {\n                _context3.next = 4;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 4:\n              _context3.prev = 4;\n              _context3.next = 7;\n              return _this.getGatewayContractAddress(asset);\n\n            case 7:\n              return _context3.abrupt(\"return\", !!_context3.sent);\n\n            case 10:\n              _context3.prev = 10;\n              _context3.t0 = _context3[\"catch\"](4);\n\n              if (/(Empty address returned)|(Asset not supported on mint-chain)/.exec(String((_context3.t0 || {}).message))) {// Ignore\n              } else {\n                console.warn(_context3.t0);\n              }\n\n              return _context3.abrupt(\"return\", false);\n\n            case 14:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[4, 10]]);\n    }));\n\n    return function (_x3) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * `assetDecimals` should return the number of decimals of the asset.\n   *\n   * If the asset is not supported, an error should be thrown.\n   *\n   \n   */\n\n\n  this.assetDecimals = function (asset) {\n    if (asset === \"ETH\") {\n      return 18;\n    }\n\n    throw new Error(\"Unsupported asset \".concat(asset, \".\"));\n  };\n\n  this.transactionID = function (transaction) {\n    return transaction || \"\";\n  };\n\n  this.transactionFromID = function (txid, _txindex) {\n    return Ox(txid);\n  };\n\n  this.transactionConfidence =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(transaction) {\n      var currentBlock, receipt, current, transactionBlock;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(!_this.web3 || !_this.renNetworkDetails)) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              if (!(transaction === null)) {\n                _context4.next = 4;\n                break;\n              }\n\n              throw new Error(\"Unable to fetch transaction confidence, transaction hash: \".concat(transaction));\n\n            case 4:\n              _context4.t0 = BigNumber;\n              _context4.next = 7;\n              return _this.web3.eth.getBlockNumber();\n\n            case 7:\n              _context4.t1 = _context4.sent.toString();\n              currentBlock = new _context4.t0(_context4.t1);\n              _context4.next = 11;\n              return _this.web3.eth.getTransactionReceipt(transaction);\n\n            case 11:\n              receipt = _context4.sent;\n              current = 0;\n\n              if (receipt.blockNumber) {\n                transactionBlock = new BigNumber(receipt.blockNumber.toString());\n                current = currentBlock.minus(transactionBlock).plus(1).toNumber();\n              }\n\n              return _context4.abrupt(\"return\", {\n                current: current,\n                target: _this.renNetworkDetails.isTestnet ? 15 : 30\n              });\n\n            case 15:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  this.submitMint =\n  /*#__PURE__*/\n  function () {\n    var _ref5 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5(asset, contractCalls, mintTx, eventEmitter) {\n      var existingTransaction;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (mintTx.out) {\n                _context5.next = 2;\n                break;\n              }\n\n              throw new Error(\"No signature passed to mint submission.\");\n\n            case 2:\n              if (!(mintTx.out.revert !== undefined)) {\n                _context5.next = 4;\n                break;\n              }\n\n              throw new Error(\"Unable to submit reverted RenVM transaction.\");\n\n            case 4:\n              if (_this.web3) {\n                _context5.next = 6;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 6:\n              _context5.next = 8;\n              return _this.findTransaction(asset, mintTx.out.nhash, mintTx.out.sighash);\n\n            case 8:\n              existingTransaction = _context5.sent;\n\n              if (!existingTransaction) {\n                _context5.next = 13;\n                break;\n              }\n\n              _context5.next = 12;\n              return manualPromiEvent(_this.web3, existingTransaction, eventEmitter);\n\n            case 12:\n              return _context5.abrupt(\"return\", existingTransaction);\n\n            case 13:\n              _context5.next = 15;\n              return submitToEthereum(_this.web3, contractCalls, mintTx, eventEmitter);\n\n            case 15:\n              return _context5.abrupt(\"return\", _context5.sent);\n\n            case 16:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x5, _x6, _x7, _x8) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  this.findTransaction =\n  /*#__PURE__*/\n  function () {\n    var _ref6 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee6(asset, nHash, sigHash) {\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(!_this.renNetworkDetails || !_this.web3)) {\n                _context6.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              return _context6.abrupt(\"return\", findTransactionBySigHash(_this.renNetworkDetails, _this.web3, asset, nHash, sigHash, _this.logRequestLimit));\n\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x9, _x10, _x11) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n\n  this.resolveTokenGatewayContract =\n  /*#__PURE__*/\n  function () {\n    var _ref7 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7(asset) {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(!_this.renNetworkDetails || !_this.web3)) {\n                _context7.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              _context7.t0 = Ox;\n              _context7.next = 5;\n              return getTokenAddress(_this.renNetworkDetails, _this.web3, asset);\n\n            case 5:\n              _context7.t1 = _context7.sent;\n              return _context7.abrupt(\"return\", (0, _context7.t0)(_context7.t1));\n\n            case 7:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function (_x12) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  /**\n   * Read a burn reference from an Ethereum transaction - or submit a\n   * transaction first if the transaction details have been provided.\n   */\n\n\n  this.findBurnTransaction =\n  /*#__PURE__*/\n  function () {\n    var _ref8 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8(asset, // Once of the following should not be undefined.\n    burn, eventEmitter, logger, timeout) {\n      var burnNonce, contractCalls, transaction, _loop, i;\n\n      return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(!_this.renNetworkDetails || !_this.web3)) {\n                _context9.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              burnNonce = burn.burnNonce, contractCalls = burn.contractCalls;\n              transaction = burn.transaction;\n\n              if (!(!transaction && burnNonce)) {\n                _context9.next = 6;\n                break;\n              }\n\n              return _context9.abrupt(\"return\", findBurnByNonce(_this.renNetworkDetails, _this.web3, asset, burnNonce.toString()));\n\n            case 6:\n              if (!(!transaction && contractCalls)) {\n                _context9.next = 14;\n                break;\n              }\n\n              _loop =\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _loop(i) {\n                var _contract$methods;\n\n                var contractCall, last, contractParams, contractFn, sendTo, callParams, ABI, contract, txConfig, config, tx;\n                return _regeneratorRuntime.wrap(function _loop$(_context8) {\n                  while (1) {\n                    switch (_context8.prev = _context8.next) {\n                      case 0:\n                        contractCall = contractCalls[i];\n                        last = i === contractCalls.length - 1;\n                        contractParams = contractCall.contractParams, contractFn = contractCall.contractFn, sendTo = contractCall.sendTo;\n                        callParams = _toConsumableArray((contractParams || []).map(function (value) {\n                          return value.value;\n                        }));\n                        ABI = payloadToABI(contractFn, contractParams);\n                        contract = new _this.web3.eth.Contract(ABI, sendTo);\n                        txConfig = typeof contractCall === \"object\" ? contractCall.txConfig : {};\n                        _context8.next = 9;\n                        return withDefaultAccount(_this.web3, _objectSpread({}, txConfig, {\n                          value: txConfig && txConfig.value ? txConfig.value.toString() : undefined,\n                          gasPrice: txConfig && txConfig.gasPrice ? txConfig.gasPrice.toString() : undefined\n                        }));\n\n                      case 9:\n                        config = _context8.sent;\n                        logger.debug.apply(logger, [\"Calling Ethereum contract\", contractFn, sendTo].concat(_toConsumableArray(callParams), [config]));\n                        tx = (_contract$methods = contract.methods)[contractFn].apply(_contract$methods, _toConsumableArray(callParams)).send(config);\n\n                        if (last) {\n                          forwardWeb3Events(tx, eventEmitter);\n                        }\n\n                        _context8.next = 15;\n                        return new Promise(function (resolve, reject) {\n                          return tx.on(\"transactionHash\", resolve).catch(function (error) {\n                            try {\n                              if (ignorePromiEventError(error)) {\n                                logger.error(extractError(error));\n                                return;\n                              }\n                            } catch (_error) {\n                              /* Ignore _error */\n                            }\n\n                            reject(error);\n                          });\n                        });\n\n                      case 15:\n                        transaction = _context8.sent;\n                        logger.debug(\"Transaction hash\", transaction);\n\n                      case 17:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }\n                }, _loop);\n              });\n              i = 0;\n\n            case 9:\n              if (!(i < contractCalls.length)) {\n                _context9.next = 14;\n                break;\n              }\n\n              return _context9.delegateYield(_loop(i), \"t0\", 11);\n\n            case 11:\n              i++;\n              _context9.next = 9;\n              break;\n\n            case 14:\n              if (transaction) {\n                _context9.next = 16;\n                break;\n              }\n\n              throw new Error(\"Unable to find burn from provided parameters.\");\n\n            case 16:\n              return _context9.abrupt(\"return\", extractBurnDetails(_this.web3, transaction, logger, timeout));\n\n            case 17:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    return function (_x13, _x14, _x15, _x16, _x17) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n\n  this.getFees =\n  /*#__PURE__*/\n  function () {\n    var _ref9 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee9(asset) {\n      var gatewayAddress, mintFeeABI, burnFeeABI, gatewayContract, mintFee, burnFee;\n      return _regeneratorRuntime.wrap(function _callee9$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (_this.web3) {\n                _context10.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 2:\n              _context10.next = 4;\n              return _this.getGatewayContractAddress(asset);\n\n            case 4:\n              gatewayAddress = _context10.sent;\n              mintFeeABI = {\n                constant: true,\n                inputs: [],\n                name: \"mintFee\",\n                outputs: [{\n                  internalType: \"uint16\",\n                  name: \"\",\n                  type: \"uint16\"\n                }],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\"\n              };\n              burnFeeABI = {\n                constant: true,\n                inputs: [],\n                name: \"burnFee\",\n                outputs: [{\n                  internalType: \"uint16\",\n                  name: \"\",\n                  type: \"uint16\"\n                }],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\"\n              };\n              gatewayContract = new _this.web3.eth.Contract([mintFeeABI, burnFeeABI], gatewayAddress);\n              _context10.next = 10;\n              return gatewayContract.methods.mintFee().call();\n\n            case 10:\n              mintFee = _context10.sent;\n              _context10.next = 13;\n              return gatewayContract.methods.burnFee().call();\n\n            case 13:\n              burnFee = _context10.sent;\n              return _context10.abrupt(\"return\", {\n                mint: new BigNumber(mintFee.toString()).toNumber(),\n                burn: new BigNumber(burnFee.toString()).toNumber()\n              });\n\n            case 15:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee9);\n    }));\n\n    return function (_x18) {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n\n  this.getBalance =\n  /*#__PURE__*/\n  function () {\n    var _ref10 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee10(asset, address) {\n      var balanceOfABI, tokenAddress, tokenContract, balanceRaw;\n      return _regeneratorRuntime.wrap(function _callee10$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              balanceOfABI = {\n                constant: true,\n                inputs: [{\n                  internalType: \"address\",\n                  name: \"account\",\n                  type: \"address\"\n                }],\n                name: \"balanceOf\",\n                outputs: [{\n                  internalType: \"uint256\",\n                  name: \"\",\n                  type: \"uint256\"\n                }],\n                payable: false,\n                stateMutability: \"view\",\n                type: \"function\"\n              };\n\n              if (_this.web3) {\n                _context11.next = 3;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized - must provide network to constructor.\"));\n\n            case 3:\n              _context11.next = 5;\n              return _this.getTokenContractAddress(asset);\n\n            case 5:\n              tokenAddress = _context11.sent;\n              tokenContract = new _this.web3.eth.Contract([balanceOfABI], tokenAddress);\n              _context11.next = 9;\n              return tokenContract.methods.balanceOf(address).call();\n\n            case 9:\n              balanceRaw = _context11.sent;\n              return _context11.abrupt(\"return\", new BigNumber(balanceRaw.toString()));\n\n            case 11:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, _callee10);\n    }));\n\n    return function (_x19, _x20) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n\n  this.transactionRPCFormat = function (transaction, _v2) {\n    assertType(\"string | null\", {\n      transaction: transaction\n    });\n\n    if (transaction === null) {\n      throw new Error(\"Unable to encode transaction, transaction hash: \".concat(transaction));\n    }\n\n    return {\n      txid: fromHex(transaction),\n      txindex: \"0\"\n    };\n  };\n\n  this.web3 = new Web3(web3Provider);\n\n  if (renNetwork) {\n    this.renNetworkDetails = resolveNetwork(renNetwork);\n  }\n};\nEthereumBaseChain.chain = \"Ethereum\";\nEthereumBaseChain.utils = {\n  resolveChainNetwork: resolveNetwork,\n  addressIsValid: addressIsValid,\n  addressExplorerLink: function addressExplorerLink(address, network) {\n    return \"\".concat((EthereumBaseChain.utils.resolveChainNetwork(network) || renMainnet).etherscan, \"/address/\").concat(address);\n  },\n  transactionExplorerLink: function transactionExplorerLink(transaction, network) {\n    return \"\".concat((EthereumBaseChain.utils.resolveChainNetwork(network) || renMainnet).etherscan, \"/tx/\").concat(transaction);\n  }\n};\nvar _ = EthereumBaseChain;","map":null,"metadata":{},"sourceType":"module"}