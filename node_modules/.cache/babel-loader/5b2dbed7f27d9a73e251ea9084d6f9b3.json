{"ast":null,"code":"import _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\n\n/* eslint-disable no-use-before-define */\nimport { Base, WordArray, BufferedBlockAlgorithm } from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\n\nexport var Cipher =\n/*#__PURE__*/\nfunction (_BufferedBlockAlgorit) {\n  _inherits(Cipher, _BufferedBlockAlgorit);\n\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  function Cipher(xformMode, key, cfg) {\n    var _this;\n\n    _classCallCheck(this, Cipher);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Cipher).call(this));\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n\n    _this.cfg = Object.assign(new Base(), cfg); // Store transform mode and key\n\n    _this._xformMode = xformMode;\n    _this._key = key; // Set initial values\n\n    _this.reset();\n\n    return _this;\n  }\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n\n\n  _createClass(Cipher, [{\n    key: \"reset\",\n\n    /**\n     * Resets this cipher to its initial state.\n     *\n     * @example\n     *\n     *     cipher.reset();\n     */\n    value: function reset() {\n      // Reset data buffer\n      _get(_getPrototypeOf(Cipher.prototype), \"reset\", this).call(this); // Perform concrete-cipher logic\n\n\n      this._doReset();\n    }\n    /**\n     * Adds data to be encrypted or decrypted.\n     *\n     * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n     *\n     * @return {WordArray} The data after processing.\n     *\n     * @example\n     *\n     *     const encrypted = cipher.process('data');\n     *     const encrypted = cipher.process(wordArray);\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(dataUpdate) {\n      // Append\n      this._append(dataUpdate); // Process available blocks\n\n\n      return this._process();\n    }\n    /**\n     * Finalizes the encryption or decryption process.\n     * Note that the finalize operation is effectively a destructive, read-once operation.\n     *\n     * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n     *\n     * @return {WordArray} The data after final processing.\n     *\n     * @example\n     *\n     *     const encrypted = cipher.finalize();\n     *     const encrypted = cipher.finalize('data');\n     *     const encrypted = cipher.finalize(wordArray);\n     */\n\n  }, {\n    key: \"finalize\",\n    value: function finalize(dataUpdate) {\n      // Final data update\n      if (dataUpdate) {\n        this._append(dataUpdate);\n      } // Perform concrete-cipher logic\n\n\n      var finalProcessedData = this._doFinalize();\n\n      return finalProcessedData;\n    }\n  }], [{\n    key: \"createEncryptor\",\n    value: function createEncryptor(key, cfg) {\n      return this.create(this._ENC_XFORM_MODE, key, cfg);\n    }\n    /**\n     * Creates this cipher in decryption mode.\n     *\n     * @param {WordArray} key The key.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {Cipher} A cipher instance.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n     */\n\n  }, {\n    key: \"createDecryptor\",\n    value: function createDecryptor(key, cfg) {\n      return this.create(this._DEC_XFORM_MODE, key, cfg);\n    }\n    /**\n     * Creates shortcut functions to a cipher's object interface.\n     *\n     * @param {Cipher} cipher The cipher to create a helper for.\n     *\n     * @return {Object} An object with encrypt and decrypt shortcut functions.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n     */\n\n  }, {\n    key: \"_createHelper\",\n    value: function _createHelper(SubCipher) {\n      var selectCipherStrategy = function selectCipherStrategy(key) {\n        if (typeof key === 'string') {\n          return PasswordBasedCipher;\n        }\n\n        return SerializableCipher;\n      };\n\n      return {\n        encrypt: function encrypt(message, key, cfg) {\n          return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n        },\n        decrypt: function decrypt(ciphertext, key, cfg) {\n          return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n        }\n      };\n    }\n  }]);\n\n  return Cipher;\n}(BufferedBlockAlgorithm);\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\n\nexport var StreamCipher =\n/*#__PURE__*/\nfunction (_Cipher) {\n  _inherits(StreamCipher, _Cipher);\n\n  function StreamCipher() {\n    var _getPrototypeOf2;\n\n    var _this2;\n\n    _classCallCheck(this, StreamCipher);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this2 = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(StreamCipher)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this2.blockSize = 1;\n    return _this2;\n  }\n\n  _createClass(StreamCipher, [{\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      // Process partial blocks\n      var finalProcessedBlocks = this._process(!!'flush');\n\n      return finalProcessedBlocks;\n    }\n  }]);\n\n  return StreamCipher;\n}(Cipher);\n/**\n * Abstract base block cipher mode template.\n */\n\nexport var BlockCipherMode =\n/*#__PURE__*/\nfunction (_Base) {\n  _inherits(BlockCipherMode, _Base);\n\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  function BlockCipherMode(cipher, iv) {\n    var _this3;\n\n    _classCallCheck(this, BlockCipherMode);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(BlockCipherMode).call(this));\n    _this3._cipher = cipher;\n    _this3._iv = iv;\n    return _this3;\n  }\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n\n\n  _createClass(BlockCipherMode, null, [{\n    key: \"createEncryptor\",\n    value: function createEncryptor(cipher, iv) {\n      return this.Encryptor.create(cipher, iv);\n    }\n    /**\n     * Creates this mode for decryption.\n     *\n     * @param {Cipher} cipher A block cipher instance.\n     * @param {Array} iv The IV words.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n     */\n\n  }, {\n    key: \"createDecryptor\",\n    value: function createDecryptor(cipher, iv) {\n      return this.Decryptor.create(cipher, iv);\n    }\n  }]);\n\n  return BlockCipherMode;\n}(Base);\n\nfunction xorBlock(words, offset, blockSize) {\n  var _words = words;\n  var block; // Shortcut\n\n  var iv = this._iv; // Choose mixing block\n\n  if (iv) {\n    block = iv; // Remove IV for subsequent blocks\n\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  } // XOR blocks\n\n\n  for (var i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\n\n\nexport var CBC =\n/*#__PURE__*/\nfunction (_BlockCipherMode) {\n  _inherits(CBC, _BlockCipherMode);\n\n  function CBC() {\n    _classCallCheck(this, CBC);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(CBC).apply(this, arguments));\n  }\n\n  return CBC;\n}(BlockCipherMode);\n/**\n * CBC encryptor.\n */\n\nCBC.Encryptor =\n/*#__PURE__*/\nfunction (_CBC) {\n  _inherits(_class, _CBC);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class).apply(this, arguments));\n  }\n\n  _createClass(_class, [{\n    key: \"processBlock\",\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {Array} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    value: function processBlock(words, offset) {\n      // Shortcuts\n      var cipher = this._cipher;\n      var blockSize = cipher.blockSize; // XOR and encrypt\n\n      xorBlock.call(this, words, offset, blockSize);\n      cipher.encryptBlock(words, offset); // Remember this block to use with next block\n\n      this._prevBlock = words.slice(offset, offset + blockSize);\n    }\n  }]);\n\n  return _class;\n}(CBC);\n/**\n * CBC decryptor.\n */\n\n\nCBC.Decryptor =\n/*#__PURE__*/\nfunction (_CBC2) {\n  _inherits(_class2, _CBC2);\n\n  function _class2() {\n    _classCallCheck(this, _class2);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class2).apply(this, arguments));\n  }\n\n  _createClass(_class2, [{\n    key: \"processBlock\",\n\n    /**\n     * Processes the data block at offset.\n     *\n     * @param {Array} words The data words to operate on.\n     * @param {number} offset The offset where the block starts.\n     *\n     * @example\n     *\n     *     mode.processBlock(data.words, offset);\n     */\n    value: function processBlock(words, offset) {\n      // Shortcuts\n      var cipher = this._cipher;\n      var blockSize = cipher.blockSize; // Remember this block to use with next block\n\n      var thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR\n\n      cipher.decryptBlock(words, offset);\n      xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block\n\n      this._prevBlock = thisBlock;\n    }\n  }]);\n\n  return _class2;\n}(CBC);\n/**\n * PKCS #5/7 padding strategy.\n */\n\n\nexport var Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad: function pad(data, blockSize) {\n    // Shortcut\n    var blockSizeBytes = blockSize * 4; // Count padding bytes\n\n    var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word\n\n    var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding\n\n    var paddingWords = [];\n\n    for (var i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n\n    var padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding\n\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad: function unpad(data) {\n    var _data = data; // Get number of padding bytes from last byte\n\n    var nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 0xff; // Remove padding\n\n    _data.sigBytes -= nPaddingBytes;\n  }\n};\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\n\nexport var BlockCipher =\n/*#__PURE__*/\nfunction (_Cipher2) {\n  _inherits(BlockCipher, _Cipher2);\n\n  function BlockCipher(xformMode, key, cfg) {\n    var _this4;\n\n    _classCallCheck(this, BlockCipher);\n\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(BlockCipher).call(this, xformMode, key, Object.assign({\n      mode: CBC,\n      padding: Pkcs7\n    }, cfg)));\n    _this4.blockSize = 128 / 32;\n    return _this4;\n  }\n\n  _createClass(BlockCipher, [{\n    key: \"reset\",\n    value: function reset() {\n      var modeCreator; // Reset cipher\n\n      _get(_getPrototypeOf(BlockCipher.prototype), \"reset\", this).call(this); // Shortcuts\n\n\n      var cfg = this.cfg;\n      var iv = cfg.iv,\n          mode = cfg.mode; // Reset block mode\n\n      if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n        modeCreator = mode.createEncryptor;\n      } else\n        /* if (this._xformMode == this._DEC_XFORM_MODE) */\n        {\n          modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding\n\n          this._minBufferSize = 1;\n        }\n\n      this._mode = modeCreator.call(mode, this, iv && iv.words);\n      this._mode.__creator = modeCreator;\n    }\n  }, {\n    key: \"_doProcessBlock\",\n    value: function _doProcessBlock(words, offset) {\n      this._mode.processBlock(words, offset);\n    }\n  }, {\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      var finalProcessedBlocks; // Shortcut\n\n      var padding = this.cfg.padding; // Finalize\n\n      if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n        // Pad data\n        padding.pad(this._data, this.blockSize); // Process final blocks\n\n        finalProcessedBlocks = this._process(!!'flush');\n      } else\n        /* if (this._xformMode == this._DEC_XFORM_MODE) */\n        {\n          // Process final blocks\n          finalProcessedBlocks = this._process(!!'flush'); // Unpad data\n\n          padding.unpad(finalProcessedBlocks);\n        }\n\n      return finalProcessedBlocks;\n    }\n  }]);\n\n  return BlockCipher;\n}(Cipher);\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\n\nexport var CipherParams =\n/*#__PURE__*/\nfunction (_Base2) {\n  _inherits(CipherParams, _Base2);\n\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  function CipherParams(cipherParams) {\n    var _this5;\n\n    _classCallCheck(this, CipherParams);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(CipherParams).call(this));\n\n    _this5.mixIn(cipherParams);\n\n    return _this5;\n  }\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n\n\n  _createClass(CipherParams, [{\n    key: \"toString\",\n    value: function toString(formatter) {\n      return (formatter || this.formatter).stringify(this);\n    }\n  }]);\n\n  return CipherParams;\n}(Base);\n/**\n * OpenSSL formatting strategy.\n */\n\nexport var OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify: function stringify(cipherParams) {\n    var wordArray; // Shortcuts\n\n    var ciphertext = cipherParams.ciphertext,\n        salt = cipherParams.salt; // Format\n\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse: function parse(openSSLStr) {\n    var salt; // Parse base64\n\n    var ciphertext = Base64.parse(openSSLStr); // Shortcut\n\n    var ciphertextWords = ciphertext.words; // Test for salt\n\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext\n\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({\n      ciphertext: ciphertext,\n      salt: salt\n    });\n  }\n};\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\n\nexport var SerializableCipher =\n/*#__PURE__*/\nfunction (_Base3) {\n  _inherits(SerializableCipher, _Base3);\n\n  function SerializableCipher() {\n    _classCallCheck(this, SerializableCipher);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SerializableCipher).apply(this, arguments));\n  }\n\n  _createClass(SerializableCipher, null, [{\n    key: \"encrypt\",\n\n    /**\n     * Encrypts a message.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {WordArray|string} message The message to encrypt.\n     * @param {WordArray} key The key.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {CipherParams} A cipher params object.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       .encrypt(CryptoJS.algo.AES, message, key);\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n     */\n    value: function encrypt(cipher, message, key, cfg) {\n      // Apply config defaults\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Encrypt\n\n\n      var encryptor = cipher.createEncryptor(key, _cfg);\n      var ciphertext = encryptor.finalize(message); // Shortcut\n\n      var cipherCfg = encryptor.cfg; // Create and return serializable cipher params\n\n      return CipherParams.create({\n        ciphertext: ciphertext,\n        key: key,\n        iv: cipherCfg.iv,\n        algorithm: cipher,\n        mode: cipherCfg.mode,\n        padding: cipherCfg.padding,\n        blockSize: encryptor.blockSize,\n        formatter: _cfg.format\n      });\n    }\n    /**\n     * Decrypts serialized ciphertext.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n     * @param {WordArray} key The key.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {WordArray} The plaintext.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var plaintext = CryptoJS.lib.SerializableCipher\n     *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n     *         { iv: iv, format: CryptoJS.format.OpenSSL });\n     *     var plaintext = CryptoJS.lib.SerializableCipher\n     *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n     *         { iv: iv, format: CryptoJS.format.OpenSSL });\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(cipher, ciphertext, key, cfg) {\n      var _ciphertext = ciphertext; // Apply config defaults\n\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n      _ciphertext = this._parse(_ciphertext, _cfg.format); // Decrypt\n\n      var plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n      return plaintext;\n    }\n    /**\n     * Converts serialized ciphertext to CipherParams,\n     * else assumed CipherParams already and returns ciphertext unchanged.\n     *\n     * @param {CipherParams|string} ciphertext The ciphertext.\n     * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n     *\n     * @return {CipherParams} The unserialized ciphertext.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n     *       ._parse(ciphertextStringOrParams, format);\n     */\n\n  }, {\n    key: \"_parse\",\n    value: function _parse(ciphertext, format) {\n      if (typeof ciphertext === 'string') {\n        return format.parse(ciphertext, this);\n      }\n\n      return ciphertext;\n    }\n  }]);\n\n  return SerializableCipher;\n}(Base);\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\n\nSerializableCipher.cfg = Object.assign(new Base(), {\n  format: OpenSSLFormatter\n});\n/**\n * OpenSSL key derivation function.\n */\n\nexport var OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute: function execute(password, keySize, ivSize, salt) {\n    var _salt = salt; // Generate random salt\n\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    } // Derive key and IV\n\n\n    var key = EvpKDFAlgo.create({\n      keySize: keySize + ivSize\n    }).compute(password, _salt); // Separate key and IV\n\n    var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4; // Return params\n\n    return CipherParams.create({\n      key: key,\n      iv: iv,\n      salt: _salt\n    });\n  }\n};\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\n\nexport var PasswordBasedCipher =\n/*#__PURE__*/\nfunction (_SerializableCipher) {\n  _inherits(PasswordBasedCipher, _SerializableCipher);\n\n  function PasswordBasedCipher() {\n    _classCallCheck(this, PasswordBasedCipher);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PasswordBasedCipher).apply(this, arguments));\n  }\n\n  _createClass(PasswordBasedCipher, null, [{\n    key: \"encrypt\",\n\n    /**\n     * Encrypts a message using a password.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {WordArray|string} message The message to encrypt.\n     * @param {string} password The password.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {CipherParams} A cipher params object.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n     *       .encrypt(CryptoJS.algo.AES, message, 'password');\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n     *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n     */\n    value: function encrypt(cipher, message, password, cfg) {\n      // Apply config defaults\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Derive key and other params\n\n\n      var derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config\n\n\n      _cfg.iv = derivedParams.iv; // Encrypt\n\n      var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg); // Mix in derived params\n\n      ciphertext.mixIn(derivedParams);\n      return ciphertext;\n    }\n    /**\n     * Decrypts serialized ciphertext using a password.\n     *\n     * @param {Cipher} cipher The cipher algorithm to use.\n     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n     * @param {string} password The password.\n     * @param {Object} cfg (Optional) The configuration options to use for this operation.\n     *\n     * @return {WordArray} The plaintext.\n     *\n     * @static\n     *\n     * @example\n     *\n     *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n     *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n     *         { format: CryptoJS.format.OpenSSL });\n     *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n     *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n     *         { format: CryptoJS.format.OpenSSL });\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(cipher, ciphertext, password, cfg) {\n      var _ciphertext = ciphertext; // Apply config defaults\n\n      var _cfg = Object.assign(new Base(), this.cfg, cfg); // Convert string to CipherParams\n\n\n      _ciphertext = this._parse(_ciphertext, _cfg.format); // Derive key and other params\n\n      var derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt); // Add IV to config\n\n\n      _cfg.iv = derivedParams.iv; // Decrypt\n\n      var plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n      return plaintext;\n    }\n  }]);\n\n  return PasswordBasedCipher;\n}(SerializableCipher);\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\n\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, {\n  kdf: OpenSSLKdf\n});","map":null,"metadata":{},"sourceType":"module"}