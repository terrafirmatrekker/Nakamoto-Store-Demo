{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Transaction = require('../transaction');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar Sighash = require('../sighash');\n\nvar PublicKey = require('../../publickey');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar TransactionSignature = require('../signature');\n/**\n * @constructor\n */\n\n\nfunction MultiSigInput(input, pubkeys, threshold, signatures) {\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n    return publicKey.toString('hex');\n  });\n  $.checkState(Script.buildMultisigOut(this.publicKeys, threshold).equals(this.output.script), 'Provided public keys don\\'t match to the provided output script');\n  this.publicKeyIndex = {};\n\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n\n  this.threshold = threshold; // Empty array of signatures\n\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\n\ninherits(MultiSigInput, Input);\n\nMultiSigInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return signature.toObject();\n  });\n};\n\nMultiSigInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  var self = this;\n  var results = [];\n\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.output.script),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigInput.prototype.addSignature = function (transaction, signature) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n  this._updateScript();\n\n  return this;\n};\n\nMultiSigInput.prototype._updateScript = function () {\n  this.setScript(Script.buildMultisigIn(this.publicKeys, this.threshold, this._createSignatures()));\n  return this;\n};\n\nMultiSigInput.prototype._createSignatures = function () {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\n\nMultiSigInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n\n  this._updateScript();\n};\n\nMultiSigInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\n\nMultiSigInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\n\nMultiSigInput.prototype.isValidSignature = function (transaction, signature) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script);\n};\n/**\n *\n * @param {Buffer[]} signatures\n * @param {PublicKey[]} publicKeys\n * @param {Transaction} transaction\n * @param {Integer} inputIndex\n * @param {Input} input\n * @returns {TransactionSignature[]}\n */\n\n\nMultiSigInput.normalizeSignatures = function (transaction, input, inputIndex, signatures, publicKeys) {\n  return publicKeys.map(function (pubKey) {\n    var signatureMatch = null;\n    signatures = signatures.filter(function (signatureBuffer) {\n      if (signatureMatch) {\n        return true;\n      }\n\n      var signature = new TransactionSignature({\n        signature: Signature.fromTxFormat(signatureBuffer),\n        publicKey: pubKey,\n        prevTxId: input.prevTxId,\n        outputIndex: input.outputIndex,\n        inputIndex: inputIndex,\n        sigtype: Signature.SIGHASH_ALL\n      });\n      signature.signature.nhashtype = signature.sigtype;\n      var isMatch = Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, input.output.script);\n\n      if (isMatch) {\n        signatureMatch = signature;\n        return false;\n      }\n\n      return true;\n    });\n    return signatureMatch ? signatureMatch : null;\n  });\n};\n\nMultiSigInput.OPCODES_SIZE = 1; // 0\n\nMultiSigInput.SIGNATURE_SIZE = 73; // size (1) + DER (<=72)\n\nMultiSigInput.prototype._estimateSize = function () {\n  return MultiSigInput.OPCODES_SIZE + this.threshold * MultiSigInput.SIGNATURE_SIZE;\n};\n\nmodule.exports = MultiSigInput;","map":null,"metadata":{},"sourceType":"script"}