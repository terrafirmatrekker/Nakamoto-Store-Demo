{"ast":null,"code":"import _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { WordArray, Hasher } from './core.js';\nimport { X64Word } from './x64-core.js'; // Constants tables\n\nvar RHO_OFFSETS = [];\nvar PI_INDEXES = [];\nvar ROUND_CONSTANTS = []; // Compute Constants\n// Compute rho offset constants\n\nvar _x = 1;\nvar _y = 0;\n\nfor (var t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = (t + 1) * (t + 2) / 2 % 64;\n  var newX = _y % 5;\n  var newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n} // Compute pi index constants\n\n\nfor (var x = 0; x < 5; x += 1) {\n  for (var y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;\n  }\n} // Compute round constants\n\n\nvar LFSR = 0x01;\n\nfor (var i = 0; i < 24; i += 1) {\n  var roundConstantMsw = 0;\n  var roundConstantLsw = 0;\n\n  for (var j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      var bitPosition = (1 << j) - 1;\n\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else\n        /* if (bitPosition >= 32) */\n        {\n          roundConstantMsw ^= 1 << bitPosition - 32;\n        }\n    } // Compute next LFSR\n\n\n    if (LFSR & 0x80) {\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n      LFSR = LFSR << 1 ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n\n  ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);\n} // Reusable objects for temporary values\n\n\nvar T = [];\n\nfor (var _i = 0; _i < 25; _i += 1) {\n  T[_i] = X64Word.create();\n}\n/**\n * SHA-3 hash algorithm.\n */\n\n\nexport var SHA3Algo =\n/*#__PURE__*/\nfunction (_Hasher) {\n  _inherits(SHA3Algo, _Hasher);\n\n  function SHA3Algo(cfg) {\n    _classCallCheck(this, SHA3Algo);\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} outputLength\n     *   The desired number of bits in the output hash.\n     *   Only values permitted are: 224, 256, 384, 512.\n     *   Default: 512\n     */\n    return _possibleConstructorReturn(this, _getPrototypeOf(SHA3Algo).call(this, Object.assign({\n      outputLength: 512\n    }, cfg)));\n  }\n\n  _createClass(SHA3Algo, [{\n    key: \"_doReset\",\n    value: function _doReset() {\n      this._state = [];\n      var state = this._state;\n\n      for (var _i2 = 0; _i2 < 25; _i2 += 1) {\n        state[_i2] = new X64Word();\n      }\n\n      this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n    }\n  }, {\n    key: \"_doProcessBlock\",\n    value: function _doProcessBlock(M, offset) {\n      // Shortcuts\n      var state = this._state;\n      var nBlockSizeLanes = this.blockSize / 2; // Absorb\n\n      for (var _i3 = 0; _i3 < nBlockSizeLanes; _i3 += 1) {\n        // Shortcuts\n        var M2i = M[offset + 2 * _i3];\n        var M2i1 = M[offset + 2 * _i3 + 1]; // Swap endian\n\n        M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;\n        M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00; // Absorb message into state\n\n        var lane = state[_i3];\n        lane.high ^= M2i1;\n        lane.low ^= M2i;\n      } // Rounds\n\n\n      for (var round = 0; round < 24; round += 1) {\n        // Theta\n        for (var _x2 = 0; _x2 < 5; _x2 += 1) {\n          // Mix column lanes\n          var tMsw = 0;\n          var tLsw = 0;\n\n          for (var _y2 = 0; _y2 < 5; _y2 += 1) {\n            var _lane2 = state[_x2 + 5 * _y2];\n            tMsw ^= _lane2.high;\n            tLsw ^= _lane2.low;\n          } // Temporary values\n\n\n          var Tx = T[_x2];\n          Tx.high = tMsw;\n          Tx.low = tLsw;\n        }\n\n        for (var _x3 = 0; _x3 < 5; _x3 += 1) {\n          // Shortcuts\n          var Tx4 = T[(_x3 + 4) % 5];\n          var Tx1 = T[(_x3 + 1) % 5];\n          var Tx1Msw = Tx1.high;\n          var Tx1Lsw = Tx1.low; // Mix surrounding columns\n\n          var _tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);\n\n          var _tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);\n\n          for (var _y3 = 0; _y3 < 5; _y3 += 1) {\n            var _lane3 = state[_x3 + 5 * _y3];\n            _lane3.high ^= _tMsw;\n            _lane3.low ^= _tLsw;\n          }\n        } // Rho Pi\n\n\n        for (var laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n          var _tMsw2 = void 0;\n\n          var _tLsw2 = void 0; // Shortcuts\n\n\n          var _lane4 = state[laneIndex];\n          var laneMsw = _lane4.high;\n          var laneLsw = _lane4.low;\n          var rhoOffset = RHO_OFFSETS[laneIndex]; // Rotate lanes\n\n          if (rhoOffset < 32) {\n            _tMsw2 = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;\n            _tLsw2 = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;\n          } else\n            /* if (rhoOffset >= 32) */\n            {\n              _tMsw2 = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;\n              _tLsw2 = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;\n            } // Transpose lanes\n\n\n          var TPiLane = T[PI_INDEXES[laneIndex]];\n          TPiLane.high = _tMsw2;\n          TPiLane.low = _tLsw2;\n        } // Rho pi at x = y = 0\n\n\n        var T0 = T[0];\n        var state0 = state[0];\n        T0.high = state0.high;\n        T0.low = state0.low; // Chi\n\n        for (var _x4 = 0; _x4 < 5; _x4 += 1) {\n          for (var _y4 = 0; _y4 < 5; _y4 += 1) {\n            // Shortcuts\n            var _laneIndex = _x4 + 5 * _y4;\n\n            var _lane5 = state[_laneIndex];\n            var TLane = T[_laneIndex];\n            var Tx1Lane = T[(_x4 + 1) % 5 + 5 * _y4];\n            var Tx2Lane = T[(_x4 + 2) % 5 + 5 * _y4]; // Mix rows\n\n            _lane5.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;\n            _lane5.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;\n          }\n        } // Iota\n\n\n        var _lane = state[0];\n        var roundConstant = ROUND_CONSTANTS[round];\n        _lane.high ^= roundConstant.high;\n        _lane.low ^= roundConstant.low;\n      }\n    }\n  }, {\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      // Shortcuts\n      var data = this._data;\n      var dataWords = data.words;\n      var nBitsLeft = data.sigBytes * 8;\n      var blockSizeBits = this.blockSize * 32; // Add padding\n\n      dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;\n      dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;\n      data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n      this._process(); // Shortcuts\n\n\n      var state = this._state;\n      var outputLengthBytes = this.cfg.outputLength / 8;\n      var outputLengthLanes = outputLengthBytes / 8; // Squeeze\n\n      var hashWords = [];\n\n      for (var _i4 = 0; _i4 < outputLengthLanes; _i4 += 1) {\n        // Shortcuts\n        var lane = state[_i4];\n        var laneMsw = lane.high;\n        var laneLsw = lane.low; // Swap endian\n\n        laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;\n        laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00; // Squeeze state to retrieve hash\n\n        hashWords.push(laneLsw);\n        hashWords.push(laneMsw);\n      } // Return final computed hash\n\n\n      return new WordArray(hashWords, outputLengthBytes);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = _get(_getPrototypeOf(SHA3Algo.prototype), \"clone\", this).call(this);\n\n      clone._state = this._state.slice(0);\n      var state = clone._state;\n\n      for (var _i5 = 0; _i5 < 25; _i5 += 1) {\n        state[_i5] = state[_i5].clone();\n      }\n\n      return clone;\n    }\n  }]);\n\n  return SHA3Algo;\n}(Hasher);\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA3('message');\n *     var hash = CryptoJS.SHA3(wordArray);\n */\n\nexport var SHA3 = Hasher._createHelper(SHA3Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA3(message, key);\n */\n\nexport var HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);","map":null,"metadata":{},"sourceType":"module"}