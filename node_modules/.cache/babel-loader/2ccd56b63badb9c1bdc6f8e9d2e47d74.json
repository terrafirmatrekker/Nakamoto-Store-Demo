{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// TODO: Improve typings.\nimport { DepositStatus } from \"@renproject/ren/build/main/lockAndMint\";\nimport { assign, spawn, send, actions } from \"xstate\";\nimport { buildDepositMachine } from \"../machines/deposit\";\nimport { isConfirming, isOpen } from \"../types/mint\"; // Recursively cast all buffers in an object to hex\n\nvar hexify = function hexify(obj) {\n  if (!obj) return;\n  var entries = Object.entries(obj);\n\n  for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {\n    var _entries$_i = _slicedToArray(_entries[_i], 2),\n        k = _entries$_i[0],\n        v = _entries$_i[1];\n\n    if (Buffer.isBuffer(v)) {\n      obj[k] = v.toString(\"hex\");\n    }\n  }\n\n  return obj;\n}; // Create a LockAndMint instance from a RenTX context\n\n\nexport var renLockAndMint =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(context) {\n    var _context$tx, nonce, sourceAsset, sdk, to, from, mint;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context$tx = context.tx, nonce = _context$tx.nonce, sourceAsset = _context$tx.sourceAsset;\n            sdk = context.sdk, to = context.to, from = context.from;\n            _context.next = 4;\n            return sdk.lockAndMint({\n              asset: sourceAsset.toUpperCase(),\n              from: from(context),\n              to: to(context),\n              nonce: nonce\n            });\n\n          case 4:\n            mint = _context.sent;\n            return _context.abrupt(\"return\", mint);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function renLockAndMint(_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // FIXME: These should exist at the RenJS level (gateway validity estimate)\n\nvar getSessionDay = function getSessionDay() {\n  return Math.floor(Date.now() / 1000 / 60 / 60 / 24);\n}; // const getSessionExpiry = () => (getSessionDay() + 3) * 60 * 60 * 24 * 1000;\n// Format a transaction and get the gateway address\n\n\nvar txCreator =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(context) {\n    var nonce, minter, gatewayAddress, newTx;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // If no nonce is provided, mock the behavior of a new gateway every day\n            if (!context.tx.nonce) {\n              nonce = getSessionDay();\n              context.tx.nonce = Buffer.from(nonce.toString(16).padStart(32)).toString(\"hex\");\n            }\n\n            _context2.next = 3;\n            return renLockAndMint(context);\n\n          case 3:\n            minter = _context2.sent;\n            gatewayAddress = minter === null || minter === void 0 ? void 0 : minter.gatewayAddress;\n            newTx = Object.assign(Object.assign({}, context.tx), {\n              gatewayAddress: gatewayAddress\n            });\n            return _context2.abrupt(\"return\", newTx);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function txCreator(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar initMinter =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(context, callback) {\n    var minter;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return renLockAndMint(context);\n\n          case 2:\n            minter = _context3.sent;\n\n            if (isOpen(context.tx) && minter.gatewayAddress != context.tx.gatewayAddress) {\n              callback({\n                type: \"ERROR_LISTENING\",\n                data: new Error(\"Incorrect gateway address \".concat(String(minter.gatewayAddress), \" != \").concat(context.tx.gatewayAddress))\n              });\n            }\n\n            return _context3.abrupt(\"return\", minter);\n\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function initMinter(_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar handleSettle =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(sourceTxHash, deposit, callback) {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return deposit.confirmed().on(\"target\", function (targetConfs) {\n              var confirmedTx = {\n                sourceTxHash: sourceTxHash,\n                sourceTxConfs: 0,\n                sourceTxConfTarget: targetConfs\n              };\n              callback({\n                type: \"CONFIRMATION\",\n                data: confirmedTx\n              });\n            }).on(\"confirmation\", function (confs, targetConfs) {\n              var confirmedTx = {\n                sourceTxHash: sourceTxHash,\n                sourceTxConfs: confs,\n                sourceTxConfTarget: targetConfs\n              };\n              callback({\n                type: \"CONFIRMATION\",\n                data: confirmedTx\n              });\n            });\n\n          case 3:\n            res = _context4.sent;\n            callback({\n              type: \"CONFIRMED\",\n              data: {\n                sourceTxConfTarget: res._state.targetConfirmations,\n                sourceTxConfs: res._state.targetConfirmations,\n                sourceTxHash: sourceTxHash\n              }\n            });\n            _context4.next = 10;\n            break;\n\n          case 7:\n            _context4.prev = 7;\n            _context4.t0 = _context4[\"catch\"](0);\n            callback({\n              type: \"ERROR\",\n              data: {\n                sourceTxHash: sourceTxHash\n              },\n              error: _context4.t0\n            });\n\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 7]]);\n  }));\n\n  return function handleSettle(_x5, _x6, _x7) {\n    return _ref4.apply(this, arguments);\n  };\n}(); // Handle signing on RenVM\n\n\nvar handleSign =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5(tx, deposit, callback) {\n    var _a, _b, v, data;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _context5.next = 3;\n            return deposit.signed();\n\n          case 3:\n            v = _context5.sent;\n\n            if (!(!v._state.queryTxResult || !v._state.queryTxResult.out)) {\n              _context5.next = 7;\n              break;\n            }\n\n            callback({\n              type: \"SIGN_ERROR\",\n              data: Object.assign({}, tx),\n              error: new Error(\"No signature!\")\n            });\n            return _context5.abrupt(\"return\");\n\n          case 7:\n            if (!(v._state.queryTxResult.out && v._state.queryTxResult.out.revert !== undefined || v.revertReason)) {\n              _context5.next = 12;\n              break;\n            }\n\n            callback({\n              type: \"REVERTED\",\n              data: Object.assign({}, tx),\n              error: new Error(((_a = v._state.queryTxResult.out.revert) === null || _a === void 0 ? void 0 : _a.toString()) || v.revertReason || \"unknown\")\n            });\n            return _context5.abrupt(\"return\");\n\n          case 12:\n            data = Object.assign(Object.assign({}, tx), {\n              renResponse: hexify(v._state.queryTxResult.out),\n              renSignature: (_b = v._state.queryTxResult.out.signature) === null || _b === void 0 ? void 0 : _b.toString(\"hex\")\n            });\n            callback({\n              type: \"SIGNED\",\n              data: data\n            });\n\n          case 14:\n            _context5.next = 22;\n            break;\n\n          case 16:\n            _context5.prev = 16;\n            _context5.t0 = _context5[\"catch\"](0);\n\n            if (!deposit.revertReason) {\n              _context5.next = 21;\n              break;\n            }\n\n            callback({\n              type: \"REVERTED\",\n              data: Object.assign({}, tx),\n              error: new Error(deposit.revertReason)\n            });\n            return _context5.abrupt(\"return\");\n\n          case 21:\n            // If a tx has already been minted, we will get an error at this step\n            // We can assume that a \"utxo spent\" error implies that the asset has been minted\n            callback({\n              type: \"SIGN_ERROR\",\n              data: tx,\n              // Error must be stringified because full log breaks xstate serialization\n              error: _context5.t0\n            });\n\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[0, 16]]);\n  }));\n\n  return function handleSign(_x8, _x9, _x10) {\n    return _ref5.apply(this, arguments);\n  };\n}(); // Handle minting on destination chain\n\n\nvar handleMint =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6(sourceTxHash, deposit, callback, params) {\n    var minter, onConfirmation;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.prev = 0;\n            minter = deposit.mint(params);\n\n            onConfirmation = function onConfirmation(_, receipt) {\n              var submittedTx = {\n                sourceTxHash: sourceTxHash\n              };\n\n              if (receipt.status == false) {\n                callback({\n                  type: \"SUBMIT_ERROR\",\n                  data: {\n                    sourceTxHash: sourceTxHash\n                  },\n                  error: new Error(\"Transaction was reverted\")\n                });\n              } else {\n                callback({\n                  type: \"ACKNOWLEDGE\",\n                  data: submittedTx\n                });\n              } // only acknowledge once\n\n\n              minter.removeListener(\"confirmation\", onConfirmation);\n            };\n\n            _context6.next = 5;\n            return minter.on(\"transactionHash\", function (transactionHash) {\n              var submittedTx = {\n                sourceTxHash: sourceTxHash,\n                destTxHash: transactionHash\n              };\n              callback({\n                type: \"SUBMITTED\",\n                data: submittedTx\n              });\n            });\n\n          case 5:\n            _context6.next = 7;\n            return minter.on(\"confirmation\", onConfirmation);\n\n          case 7:\n            _context6.next = 9;\n            return minter;\n\n          case 9:\n            _context6.next = 14;\n            break;\n\n          case 11:\n            _context6.prev = 11;\n            _context6.t0 = _context6[\"catch\"](0);\n            callback({\n              type: \"SUBMIT_ERROR\",\n              data: {\n                sourceTxHash: sourceTxHash\n              },\n              error: _context6.t0\n            });\n\n          case 14:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[0, 11]]);\n  }));\n\n  return function handleMint(_x11, _x12, _x13, _x14) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar resolveDeposit = function resolveDeposit(hash, deposit) {\n  var _a, _b, _c, _d, _f;\n\n  var rawSourceTx = deposit.depositDetails; // as DepositCommon<>;\n\n  var newDepositState = {\n    sourceTxHash: hash,\n    renVMHash: deposit.txHash(),\n    sourceTxAmount: rawSourceTx.amount,\n    sourceTxConfs: parseInt(rawSourceTx.transaction.confirmations || \"0\"),\n    rawSourceTx: rawSourceTx,\n    detectedAt: new Date().getTime()\n  };\n\n  if (!deposit._state.queryTxResult || !deposit._state.queryTxResult.out) {\n    return newDepositState;\n  } else {\n    if ((_a = deposit._state.queryTxResult.out) === null || _a === void 0 ? void 0 : _a.revert) {\n      newDepositState.error = new Error((_b = deposit._state.queryTxResult.out) === null || _b === void 0 ? void 0 : _b.revert.toString());\n      return newDepositState;\n    } else {\n      // only accepted if the queryTxResult has an \"out\" field\n      var acceptedData = Object.assign(Object.assign({}, newDepositState), {\n        sourceTxConfTarget: (_c = deposit._state.targetConfirmations) !== null && _c !== void 0 ? _c : newDepositState.sourceTxConfs,\n        renResponse: hexify(deposit._state.queryTxResult || {}),\n        renSignature: (_d = deposit._state.queryTxResult.out) === null || _d === void 0 ? void 0 : _d.signature\n      });\n\n      if (deposit.status === DepositStatus.Submitted) {\n        var data = Object.assign(Object.assign({}, acceptedData), {\n          destTxAmount: ((_f = deposit._state.queryTxResult.out) === null || _f === void 0 ? void 0 : _f.amount) || \"0\",\n          rawDestTx: {},\n          contractParams: {},\n          // we don't actually know when the tx completed,\n          // so assume it is now\n          completedAt: Date.now(),\n          destTxHash: deposit.mintTransaction\n        });\n        return data;\n      } else {\n        return acceptedData;\n      }\n    }\n  }\n};\n\nvar mintFlow = function mintFlow(context, callback, receive, minter) {\n  // Transactions that we have resolved\n  var detectedTransactions = new Map();\n  var restoredDeposits = new Map();\n\n  var depositHandler = function depositHandler(deposit) {\n    var txHash = deposit.params.from.transactionID(deposit.depositDetails.transaction);\n    var restored = restoredDeposits.get(txHash); // if we have previously restored the deposit,\n    // don't emit an event\n\n    if (restored) {\n      return;\n    }\n\n    var persistedTx = context.tx.transactions[txHash] || detectedTransactions.get(txHash);\n\n    if (persistedTx) {\n      restoredDeposits.set(txHash, deposit);\n      detectedTransactions.set(txHash, persistedTx);\n      var data = persistedTx;\n\n      if (deposit.status === DepositStatus.Submitted) {\n        var completedTx = Object.assign(Object.assign({}, persistedTx), {\n          destTxHash: deposit.mintTransaction,\n          completedAt: Date.now()\n        });\n        data = completedTx;\n      }\n\n      return callback({\n        type: \"RESTORED\",\n        data: data\n      });\n    }\n\n    var resolved = resolveDeposit(txHash, deposit);\n    detectedTransactions.set(txHash, resolved);\n    callback({\n      type: \"DEPOSIT\",\n      data: resolved\n    });\n  };\n\n  minter.on(\"deposit\", depositHandler);\n  receive(function (event) {\n    var deposit = restoredDeposits.get(event.hash);\n    if (!deposit) return;\n    var tx = detectedTransactions.get(event.hash);\n\n    if (!tx || !isConfirming(tx)) {\n      callback({\n        type: \"ERROR\",\n        data: event.data,\n        error: new Error(\"Invalid deposit: \".concat(String(event.hash)))\n      });\n      return;\n    }\n\n    var handle =\n    /*#__PURE__*/\n    function () {\n      var _ref7 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.t0 = event.type;\n                _context7.next = _context7.t0 === \"UPDATE\" ? 3 : _context7.t0 === \"SETTLE\" ? 5 : _context7.t0 === \"SIGN\" ? 8 : _context7.t0 === \"MINT\" ? 11 : 14;\n                break;\n\n              case 3:\n                detectedTransactions.set(event.hash, event.data);\n                return _context7.abrupt(\"break\", 14);\n\n              case 5:\n                _context7.next = 7;\n                return handleSettle(event.hash, deposit, callback);\n\n              case 7:\n                return _context7.abrupt(\"break\", 14);\n\n              case 8:\n                _context7.next = 10;\n                return handleSign(tx, deposit, callback);\n\n              case 10:\n                return _context7.abrupt(\"break\", 14);\n\n              case 11:\n                _context7.next = 13;\n                return handleMint(event.hash, deposit, callback, event.params);\n\n              case 13:\n                return _context7.abrupt(\"break\", 14);\n\n              case 14:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      return function handle() {\n        return _ref7.apply(this, arguments);\n      };\n    }();\n\n    handle().then().catch(function (e) {\n      console.error(e, event.data);\n      callback({\n        type: \"ERROR\",\n        data: event.data,\n        error: e\n      });\n    });\n  });\n  receive(function (event) {\n    switch (event.type) {\n      case \"RESTORE\":\n        minter.processDeposit(event.data.rawSourceTx).then(function (r) {\n          // Previously the on('deposit') event would have fired when restoring\n          // Now, we use the promise result to set up the handler as well in\n          // case the `deposit` event does not fire\n          depositHandler(r);\n        }).catch(function (e) {\n          callback({\n            type: \"ERROR\",\n            data: event.data,\n            error: e\n          });\n        });\n        break;\n    }\n  });\n}; // Listen for confirmations on the source chain\n\n\nvar depositListener = function depositListener(context) {\n  return function (callback, receive) {\n    var cleanup = function cleanup() {};\n\n    initMinter(context, callback).then(function (minter) {\n      cleanup = function cleanup() {\n        return minter.removeAllListeners();\n      };\n\n      mintFlow(context, callback, receive, minter);\n      callback({\n        type: \"LISTENING\"\n      });\n    }).catch(function (e) {\n      callback({\n        type: \"ERROR_LISTENING\",\n        data: e\n      });\n    });\n    return function () {\n      cleanup();\n    };\n  };\n}; // Spawn an actor that will listen for either all deposits to a gatewayAddress,\n// or to a single deposit if present in the context\n\n\nvar listenerAction = assign({\n  depositListenerRef: function depositListenerRef(c, _e) {\n    var actorName = \"\".concat(c.tx.id, \"SessionListener\");\n\n    if (c.depositListenerRef) {\n      console.warn(\"listener already exists\");\n      return c.depositListenerRef;\n    }\n\n    var cb = depositListener(c); // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n\n    return spawn(cb, actorName);\n  }\n});\n\nvar spawnDepositMachine = function spawnDepositMachine(machineContext, name) {\n  return spawn(buildDepositMachine().withContext(machineContext).withConfig({\n    actions: {\n      listenerAction: listenerAction\n    }\n  }), {\n    // sync: true,\n    name: name\n  });\n};\n\nexport var buildMintConfig = function buildMintConfig() {\n  return {\n    services: {\n      txCreator: txCreator,\n      depositListener: depositListener\n    },\n    actions: {\n      broadcast: actions.pure(function (ctx, event) {\n        return Object.values(ctx.depositMachines || {}).map(function (m) {\n          return send(event, {\n            to: m.id\n          });\n        });\n      }),\n      forwardEvent: send(function (_, b) {\n        return b;\n      }, {\n        to: function to(_ctx) {\n          return \"depositListener\";\n        }\n      }),\n      routeEvent: send(function (_, b) {\n        return b;\n      }, {\n        to: function to(ctx, evt) {\n          var _a, _b;\n\n          var machines = ctx.depositMachines || {};\n          if (!evt.data) throw new Error(\"missing data\" + JSON.stringify(evt));\n          return ((_b = machines[((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxHash) || \"\"]) === null || _b === void 0 ? void 0 : _b.id) || \"missing\";\n        }\n      }),\n      spawnDepositMachine: assign({\n        depositMachines: function depositMachines(context, evt) {\n          var _a;\n\n          var machines = context.depositMachines || {};\n\n          if (machines[((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxHash) || \"\"] || !evt.data) {\n            return machines;\n          }\n\n          var newMachines = {};\n\n          for (var _i2 = 0, _Object$entries = Object.entries(machines); _i2 < _Object$entries.length; _i2++) {\n            var machine = _Object$entries[_i2];\n            newMachines[machine[0]] = machine[1];\n          }\n\n          newMachines[evt.data.sourceTxHash] = spawnDepositMachine({\n            deposit: evt.data\n          }, String(evt.data.sourceTxHash));\n          return newMachines;\n        }\n      }),\n      depositMachineSpawner: assign({\n        depositMachines: function depositMachines(context, _) {\n          var machines = {};\n\n          for (var _i3 = 0, _Object$entries2 = Object.entries(context.tx.transactions || {}); _i3 < _Object$entries2.length; _i3++) {\n            var tx = _Object$entries2[_i3];\n            var machineContext = {\n              deposit: tx[1]\n            };\n            machines[tx[0]] = spawnDepositMachine(machineContext, machineContext.deposit.sourceTxHash);\n          }\n\n          return Object.assign(Object.assign({}, machines), context.depositMachines);\n        }\n      }),\n      listenerAction: listenerAction\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}