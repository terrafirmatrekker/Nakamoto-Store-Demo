{"ast":null,"code":"import _toConsumableArray from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { assign, createMachine, send } from \"xstate\";\nimport { assert } from \"@renproject/utils\";\nimport { log } from \"xstate/lib/actions\";\nimport { isMinted, isOpen } from \"../types/mint\";\nexport var GatewayStates;\n\n(function (GatewayStates) {\n  GatewayStates[\"RESTORING\"] = \"restoring\";\n  GatewayStates[\"CREATING\"] = \"creating\";\n  GatewayStates[\"ERROR_CREATING\"] = \"srcInitializeError\";\n  GatewayStates[\"LISTENING\"] = \"listening\";\n  GatewayStates[\"COMPLETED\"] = \"completed\";\n})(GatewayStates || (GatewayStates = {}));\n\nexport var buildMintContextWithMap = function buildMintContextWithMap(params) {\n  var from = params.fromChainMap[params.tx.sourceChain];\n  var to = params.toChainMap[params.tx.destChain];\n  var constructed = {\n    tx: params.tx,\n    to: to,\n    sdk: params.sdk,\n    from: from\n  };\n  return constructed;\n};\n/**\n * An Xstate machine that, when given a serializable [[GatewaySession]] tx,\n * will instantiate a RenJS LockAndMint session, provide a gateway address,\n * listen for deposits, and request a signature once a deposit has reached\n * the appropriate number of confirmations.\n *\n * Given the same [[GatewaySession]] parameters, as long as the tx has not\n * expired, the machine will restore the transaction to the appropriate\n * state and enable the completion of in-progress minting transactions.\n *\n * The machine allows for multiple deposits to be detected; it is up to the\n * developer to decide if a detected deposit should be signed or rejected.\n * See `/demos/simpleMint.ts` for example usage.\n */\n\nexport var buildMintMachine = function buildMintMachine() {\n  return createMachine({\n    id: \"RenVMGatewaySession\",\n    initial: \"restoring\",\n    states: {\n      restoring: {\n        entry: [send(\"RESTORE\"), assign({\n          mintRequests: function mintRequests(_c, _e) {\n            return [];\n          },\n          depositMachines: function depositMachines(_ctx, _evt) {\n            return {};\n          }\n        })],\n        meta: {\n          test: function () {\n            var _test = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee() {\n              return _regeneratorRuntime.wrap(function _callee$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            function test() {\n              return _test.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        },\n        on: {\n          RESTORE: [{\n            target: \"completed\",\n            cond: \"isExpired\"\n          }, {\n            target: \"listening\",\n            cond: \"isCreated\"\n          }, {\n            target: \"creating\"\n          }]\n        }\n      },\n      creating: {\n        meta: {\n          test: function test(_, state) {\n            assert(!state.context.tx.gatewayAddress ? true : false, \"Gateway address should not be initialized\");\n          }\n        },\n        invoke: {\n          src: \"txCreator\",\n          onDone: {\n            target: \"listening\",\n            actions: assign({\n              tx: function tx(_context, evt) {\n                return Object.assign({}, evt.data);\n              }\n            })\n          },\n          onError: {\n            target: \"srcInitializeError\",\n            actions: [assign({\n              tx: function tx(context, evt) {\n                var newTx = Object.assign(Object.assign({}, context.tx), {\n                  error: evt.data || true\n                });\n                return newTx;\n              }\n            }), log(function (_ctx, evt) {\n              return evt.data;\n            }, \"ERROR\")]\n          }\n        }\n      },\n      srcInitializeError: {\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.error ? true : false, \"Error must exist\");\n          }\n        }\n      },\n      listening: {\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.gatewayAddress ? true : false, \"GatewayAddress must exist\");\n          }\n        },\n        invoke: {\n          src: \"depositListener\"\n        },\n        on: {\n          EXPIRED: \"completed\",\n          // once we have ren-js listening for deposits,\n          // start the statemachines to determine deposit states\n          LISTENING: {\n            actions: \"depositMachineSpawner\"\n          },\n          ERROR_LISTENING: {\n            target: \"srcInitializeError\",\n            actions: [assign({\n              tx: function tx(context, evt) {\n                var newTx = Object.assign(Object.assign({}, context.tx), {\n                  error: evt.data || true\n                });\n                return newTx;\n              }\n            }), log(function (_ctx, evt) {\n              return evt.data;\n            }, \"ERROR\")]\n          },\n          // forward messages from child machines to renjs listeners\n          RESTORE: [{\n            cond: \"isPersistedDeposit\",\n            actions: \"forwardEvent\"\n          }, {\n            actions: [assign({\n              tx: function tx(_ref, e) {\n                var _tx = _ref.tx;\n                if (!e.data.sourceTxHash) return _tx;\n                return Object.assign(Object.assign({}, _tx), {\n                  transactions: Object.assign(Object.assign({}, _tx.transactions), _defineProperty({}, e.data.sourceTxHash, e.data))\n                });\n              }\n            }), \"spawnDepositMachine\", \"forwardEvent\"]\n          }],\n          SETTLE: {\n            actions: \"forwardEvent\"\n          },\n          SIGN: {\n            actions: \"forwardEvent\"\n          },\n          MINT: {\n            actions: \"forwardEvent\"\n          },\n          // Send messages to child machines\n          RESTORED: {\n            actions: \"routeEvent\"\n          },\n          CLAIM: {\n            actions: \"routeEvent\"\n          },\n          CONFIRMATION: {\n            actions: \"routeEvent\"\n          },\n          CONFIRMED: {\n            actions: \"routeEvent\"\n          },\n          ERROR: {\n            actions: \"routeEvent\"\n          },\n          SIGN_ERROR: {\n            actions: \"routeEvent\"\n          },\n          REVERTED: {\n            actions: \"routeEvent\"\n          },\n          SUBMIT_ERROR: {\n            actions: \"routeEvent\"\n          },\n          SIGNED: {\n            actions: \"routeEvent\"\n          },\n          SUBMITTED: {\n            actions: \"routeEvent\"\n          },\n          ACKNOWLEDGE: {\n            actions: \"routeEvent\"\n          },\n          CLAIMABLE: {\n            actions: assign({\n              mintRequests: function mintRequests(context, evt) {\n                var _a;\n\n                var oldRequests = context.mintRequests || [];\n                var newRequest = (_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxHash;\n\n                if (!newRequest) {\n                  return oldRequests;\n                }\n\n                if (oldRequests.includes(newRequest)) {\n                  return oldRequests;\n                }\n\n                return [].concat(_toConsumableArray(oldRequests), [newRequest]);\n              },\n              tx: function tx(context, evt) {\n                if (evt.data.sourceTxHash) {\n                  context.tx.transactions[evt.data.sourceTxHash] = evt.data;\n                }\n\n                return context.tx;\n              }\n            })\n          },\n          // We only complete when expiring\n          // DEPOSIT_COMPLETED: {\n          //     target: \"completed\",\n          //     cond: \"isCompleted\",\n          // },\n          DEPOSIT_UPDATE: [{\n            actions: [assign({\n              mintRequests: function mintRequests(ctx, evt) {\n                var _a; // check if completed\n\n\n                if (isMinted(evt.data)) {\n                  return ((_a = ctx.mintRequests) === null || _a === void 0 ? void 0 : _a.filter(function (x) {\n                    return x !== evt.data.sourceTxHash;\n                  })) || [];\n                } else {\n                  return ctx.mintRequests;\n                }\n              },\n              tx: function tx(context, evt) {\n                if (evt.data.sourceTxHash) {\n                  context.tx.transactions[evt.data.sourceTxHash] = evt.data;\n                }\n\n                return context.tx;\n              }\n            }), send(function (_, evt) {\n              return {\n                type: \"UPDATE\",\n                hash: evt.data.sourceTxHash,\n                data: evt.data\n              };\n            }, {\n              to: function to(_ctx) {\n                return \"depositListener\";\n              }\n            })]\n          }],\n          DEPOSIT: {\n            cond: \"isNewDeposit\",\n            actions: [assign({\n              tx: function tx(context, evt) {\n                // Replace the transaction with the newly\n                // detected one; the listener will provide\n                // persisted data if it is already present\n                return Object.assign(Object.assign({}, context.tx), {\n                  transactions: Object.assign(Object.assign({}, context.tx.transactions), _defineProperty({}, evt.data.sourceTxHash, evt.data))\n                });\n              }\n            }), \"spawnDepositMachine\"]\n          }\n        }\n      },\n      completed: {\n        meta: {\n          test: function test(_, state) {\n            if (state.context.depositListenerRef) {\n              throw Error(\"Deposit listener has not been cleaned up\");\n            }\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isPersistedDeposit: function isPersistedDeposit(ctx, evt) {\n        var depositEvt = evt;\n        if (!depositEvt.data) return false;\n        return (ctx.tx.transactions || {})[depositEvt.data.sourceTxHash] ? true : false;\n      },\n      isNewDeposit: function isNewDeposit(ctx, evt) {\n        var depositEvt = evt;\n        if (!depositEvt.data) return false;\n        return !(ctx.depositMachines || {})[depositEvt.data.sourceTxHash];\n      },\n      isExpired: function isExpired(_ref2) {\n        var tx = _ref2.tx;\n        return tx.expiryTime < new Date().getTime();\n      },\n      isCreated: function isCreated(_ref3) {\n        var tx = _ref3.tx;\n        return isOpen(tx);\n      }\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}