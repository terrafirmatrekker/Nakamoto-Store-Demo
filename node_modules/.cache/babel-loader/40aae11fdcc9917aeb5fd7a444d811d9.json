{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// TODO: Improve typings.\nimport { assign, Machine, send } from \"xstate\";\nimport { assert } from \"@renproject/utils\";\nimport { isReleased } from \"../types/burn\";\nexport var BurnStates;\n\n(function (BurnStates) {\n  /** Tx is resolving which state it should be in based on feedback from renjs */\n  BurnStates[\"RESTORE\"] = \"restoring\";\n  /** Tx is being initialized by renjs */\n\n  BurnStates[\"CREATING\"] = \"creating\";\n  /** Tx has been initialized by renjs successfully and is ready to be submitted*/\n\n  BurnStates[\"CREATED\"] = \"created\";\n  /** Burn has been submitted to host chain */\n\n  BurnStates[\"SUBMITTING_BURN\"] = \"submittingBurn\";\n  /** Source/host chain is awaiting sufficient confirmations */\n\n  BurnStates[\"CONFIRMING_BURN\"] = \"srcSettling\";\n  /** There was an error encountered while processing the burn tx\n   * Could be either from renvm or the host chain */\n\n  BurnStates[\"ERROR_BURNING\"] = \"errorBurning\";\n  /** Source/host chain has reached sufficient confirmations and tx\n   * can be submitted to renVM for release */\n\n  BurnStates[\"RENVM_RELEASING\"] = \"srcConfirmed\";\n  /** RenVM has recieved the tx and provided a hash */\n\n  BurnStates[\"RENVM_ACCEPTED\"] = \"accepted\";\n  /** An error occored while processing the release\n   * Should only come from renVM */\n\n  BurnStates[\"ERROR_RELEASING\"] = \"errorReleasing\";\n  /** The release tx has successfully been broadcast\n   * For network v0.3+ we get the release destTxHash\n   * otherwise it will never be provided\n   */\n\n  BurnStates[\"RELEASED\"] = \"destInitiated\";\n})(BurnStates || (BurnStates = {}));\n\nexport var buildBurnContextWithMap = function buildBurnContextWithMap(params) {\n  var from = params.fromChainMap[params.tx.sourceChain];\n  var to = params.toChainMap[params.tx.destChain];\n  var constructed = {\n    tx: params.tx,\n    to: to,\n    sdk: params.sdk,\n    from: from\n  };\n  return constructed;\n};\n/**\n * An Xstate machine that, when given a serializable [[BurnSession]] tx,\n * will instantiate a RenJS BurnAndRelease session, prompt the user to submit a\n * burn transaction (or automatically submit if the `autoSubmit` flag is set),\n * on the host chain, listen for confirmations, and detect the release transaction\n * once the native asset has been released.\n *\n * Given the same [[BurnSession]] parameters, as long as the tx has not\n * expired, the machine will restore the transaction to the appropriate\n * state and enable the completion of in-progress burning transactions, however\n * RenVM will generally automatically complete asset releases once the burn\n * transaction has been submitted to the host chain.\n *\n * See `/demos/simpleBurn.ts` for example usage.\n */\n\nexport var buildBurnMachine = function buildBurnMachine() {\n  return Machine({\n    id: \"RenVMBurnMachine\",\n    initial: \"restoring\",\n    states: {\n      restoring: {\n        entry: send(\"RESTORE\"),\n        on: {\n          RESTORE: [{\n            target: \"destInitiated\",\n            cond: \"isDestInitiated\"\n          }, // We can't restore to this state, because the machine needs\n          // to be initialized\n          // { target: \"srcConfirmed\", cond: \"isSrcConfirmed\" },\n          {\n            target: \"srcSettling\",\n            cond: \"isSrcSettling\"\n          }, {\n            target: \"creating\"\n          }]\n        },\n        meta: {\n          test: function () {\n            var _test = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee() {\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            function test() {\n              return _test.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      creating: {\n        entry: \"burnSpawner\",\n        on: {\n          CREATED: \"created\"\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(!state.context.tx.transaction ? true : false, \"Should not have a transaction\");\n          }\n        }\n      },\n      created: {\n        on: {\n          // When we fail to submit to the host chain, we don't enter the\n          // settling state, so handle the error here\n          BURN_ERROR: {\n            target: \"errorBurning\",\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return evt.data ? Object.assign(Object.assign({}, ctx.tx), {\n                  error: evt.data\n                }) : ctx.tx;\n              }\n            })\n          },\n          SUBMIT: {\n            target: BurnStates.SUBMITTING_BURN,\n            actions: send(\"SUBMIT\", {\n              to: function to(ctx) {\n                var _a;\n\n                return ((_a = ctx.burnListenerRef) === null || _a === void 0 ? void 0 : _a.id) || \"\";\n              }\n            })\n          }\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(!state.context.tx.transaction ? true : false, \"Should not have a transaction\");\n          }\n        }\n      },\n      errorBurning: {\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.error ? true : false, \"Error must exist\");\n          }\n        }\n      },\n      submittingBurn: {\n        on: {\n          BURN_ERROR: {\n            target: \"errorBurning\",\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return evt.data ? Object.assign(Object.assign({}, ctx.tx), {\n                  error: evt.error\n                }) : ctx.tx;\n              }\n            })\n          },\n          SUBMITTED: {\n            actions: [assign({\n              tx: function tx(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.tx), {\n                  transaction: evt.data\n                });\n              }\n            })]\n          },\n          // Wait for a confirmation before entering confirming\n          CONFIRMATION: {\n            target: \"srcSettling\",\n            // update src confs\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.tx), {\n                  transaction: evt.data\n                });\n              }\n            })\n          }\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.error ? false : true, \"Error must not exist\");\n          }\n        }\n      },\n      srcSettling: {\n        // spawn in case we aren't creating\n        entry: \"burnSpawner\",\n        on: {\n          // In case we restored and didn't submit\n          SUBMIT: {\n            actions: send(\"SUBMIT\", {\n              to: function to(ctx) {\n                var _a;\n\n                return ((_a = ctx.burnListenerRef) === null || _a === void 0 ? void 0 : _a.id) || \"\";\n              }\n            })\n          },\n          CONFIRMATION: {\n            // update src confs\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.tx), {\n                  transaction: evt.data\n                });\n              }\n            })\n          },\n          CONFIRMED: {\n            actions: [assign({\n              tx: function tx(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.tx), {\n                  transaction: evt.data\n                });\n              }\n            })],\n            target: \"srcConfirmed\"\n          }\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(Object.keys(state.context.tx.transaction).length ? true : false, \"Should have a transaction\");\n          }\n        }\n      },\n      errorReleasing: {\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.error ? true : false, \"Error must exist\");\n          }\n        }\n      },\n      srcConfirmed: {\n        entry: send(\"RELEASE\", {\n          to: function to(ctx) {\n            var _a;\n\n            return ((_a = ctx.burnListenerRef) === null || _a === void 0 ? void 0 : _a.id) || \"\";\n          }\n        }),\n        on: {\n          RELEASE_ERROR: {\n            target: \"errorReleasing\",\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return evt.data ? Object.assign(Object.assign({}, ctx.tx), {\n                  error: evt.error\n                }) : ctx.tx;\n              }\n            })\n          },\n          ACCEPTED: {\n            actions: [assign({\n              tx: function tx(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.tx), {\n                  transaction: evt.data\n                });\n              }\n            })],\n            target: \"accepted\"\n          }\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.transaction.sourceTxConfs >= (state.context.tx.transaction.sourceTxConfTarget || 0) ? true : false, \"Should have a confirmed transaction\");\n          }\n        }\n      },\n      accepted: {\n        on: {\n          RELEASE_ERROR: {\n            target: \"errorReleasing\",\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return evt.data ? Object.assign(Object.assign({}, ctx.tx), {\n                  error: evt.error\n                }) : ctx.tx;\n              }\n            })\n          },\n          RELEASED: {\n            target: \"destInitiated\",\n            actions: assign({\n              tx: function tx(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.tx), {\n                  transaction: evt.data\n                });\n              }\n            })\n          }\n        },\n        meta: {\n          test: function () {\n            var _test2 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee2() {\n              return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee2);\n            }));\n\n            function test() {\n              return _test2.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      destInitiated: {\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.tx.transaction.renResponse ? true : false, \"renResponse must exist\");\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isSrcSettling: function isSrcSettling(ctx, _evt) {\n        return ctx.tx.transaction && ctx.tx.transaction.sourceTxHash ? true : false;\n      },\n      isSrcConfirmed: function isSrcConfirmed(ctx, _evt) {\n        return !!ctx.tx.transaction && ctx.tx.transaction.sourceTxConfs >= (ctx.tx.transaction.sourceTxConfTarget || Number.POSITIVE_INFINITY);\n      },\n      // We assume that the renVmHash implies that the dest tx has been initiated\n      isDestInitiated: function isDestInitiated(ctx, _evt) {\n        return !!ctx.tx.transaction && isReleased(ctx.tx.transaction) && !!ctx.tx.transaction.renResponse;\n      }\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}