{"ast":null,"code":"import _defineProperty from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _slicedToArray from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { NullLogger } from \"@renproject/interfaces\";\nimport { assert, fixSignature, fromBase64, Ox, signatureToBuffer, toBase64 } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { RenVMType } from \"./value\";\n\nvar decodeString = function decodeString(input) {\n  return fromBase64(input).toString();\n};\n\nvar decodeBytes = function decodeBytes(input) {\n  return fromBase64(input);\n};\n\nvar decodeNumber = function decodeNumber(input) {\n  return new BigNumber(input);\n};\n/**\n * Validate an argument returned from RenVM.\n *\n * @param name The expected name.\n * @param type The expected type.\n * @param arg The actual argument returned.\n */\n\n\nvar assertArgumentType = function assertArgumentType(name, type, arg) {\n  assert(arg.type === type, \"Expected argument \".concat(name, \" of type \").concat(type, \" but got \").concat(arg.name, \" of type \").concat(arg.type));\n  return arg.value;\n};\n\nvar assertAndDecodeBytes = function assertAndDecodeBytes(name, type, arg) {\n  try {\n    return decodeBytes( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    assertArgumentType(name, type, arg));\n  } catch (error) {\n    error.message = \"Unable to decode parameter \".concat(name, \" with value \").concat(String(arg.value), \" (type \").concat(typeof arg.value, \"): \").concat(String(error.message));\n    throw error;\n  }\n};\n\nvar assertAndDecodeNumber = function assertAndDecodeNumber(name, type, arg) {\n  try {\n    return decodeNumber( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    assertArgumentType(name, type, arg));\n  } catch (error) {\n    error.message = \"Unable to decode parameter \".concat(name, \" with value \").concat(String(arg.value), \" (type \").concat(typeof arg.value, \"): \").concat(String(error.message));\n    throw error;\n  }\n};\n\nvar assertAndDecodeAddress = function assertAndDecodeAddress(name, type, arg) {\n  try {\n    return Ox( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    assertArgumentType(name, type, arg));\n  } catch (error) {\n    error.message = \"Unable to decode parameter \".concat(name, \" with value \").concat(String(arg.value), \" (type \").concat(typeof arg.value, \"): \").concat(String(error.message));\n    throw error;\n  }\n};\n\nvar defaultPayload = {\n  name: \"p\",\n  type: RenVMType.ExtEthCompatPayload,\n  value: {\n    abi: \"W10=\",\n    value: \"\",\n    fn: \"\"\n  }\n};\n\nvar findField = function findField(field, response) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (response.tx.out || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var outField = _step.value;\n\n      if (outField.name === field) {\n        return outField;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = response.tx.autogen[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _outField = _step2.value;\n\n      if (_outField.name === field) {\n        return _outField;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = response.tx.in[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _outField2 = _step3.value;\n\n      if (_outField2.name === field) {\n        return _outField2;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  throw new Error(\"Unable to find field \".concat(field, \" in response from RenVM.\"));\n};\n\nvar onError = function onError(getP, defaultP) {\n  try {\n    return getP();\n  } catch (error) {\n    return defaultP;\n  }\n};\n\nexport var unmarshalMintTx = function unmarshalMintTx(response) {\n  var logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NullLogger;\n  // Note: Numbers are decoded and re-encoded to ensure they are in the correct format.\n  var pRaw = assertArgumentType(\"p\", RenVMType.ExtEthCompatPayload, onError(function () {\n    return findField(\"p\", response);\n  }, defaultPayload));\n  var token = assertAndDecodeAddress(\"token\", RenVMType.ExtTypeEthCompatAddress, findField(\"token\", response));\n  var to = assertAndDecodeAddress(\"to\", RenVMType.ExtTypeEthCompatAddress, findField(\"to\", response));\n  var n = assertAndDecodeBytes(\"n\", RenVMType.B32, findField(\"n\", response));\n  var p = {\n    abi: JSON.parse(decodeString(pRaw.abi)),\n    value: decodeBytes(pRaw.value),\n    fn: decodeString(pRaw.fn)\n  };\n  var phash = assertAndDecodeBytes(\"phash\", RenVMType.B32, findField(\"phash\", response));\n  var ghash = assertAndDecodeBytes(\"ghash\", RenVMType.B32, findField(\"ghash\", response));\n  var nhash = assertAndDecodeBytes(\"nhash\", RenVMType.B32, findField(\"nhash\", response));\n  var amount = assertAndDecodeNumber(\"amount\", RenVMType.U256, findField(\"amount\", response)).toFixed();\n  var utxoRaw = assertArgumentType(\"utxo\", RenVMType.ExtTypeBtcCompatUTXO, findField(\"utxo\", response));\n  var sighash = assertAndDecodeBytes(\"sighash\", RenVMType.B32, findField(\"sighash\", response));\n  var utxo = {\n    txHash: Ox(decodeBytes(utxoRaw.txHash), {\n      prefix: \"\"\n    }),\n    vOut: parseInt(utxoRaw.vOut, 10),\n    scriptPubKey: utxoRaw.scriptPubKey ? Ox(decodeBytes(utxoRaw.scriptPubKey), {\n      prefix: \"\"\n    }) : \"\",\n    amount: decodeNumber(utxoRaw.amount).toFixed()\n  };\n  var out = {\n    sighash: sighash,\n    ghash: ghash,\n    nhash: nhash,\n    phash: phash,\n    amount: amount\n  };\n\n  if (response.tx.out) {\n    var _ref = [findField(\"r\", response), findField(\"s\", response), findField(\"v\", response)],\n        rArg = _ref[0],\n        sArg = _ref[1],\n        vArg = _ref[2];\n    var r = rArg.type === RenVMType.B ? assertAndDecodeBytes(\"r\", RenVMType.B, rArg) : assertAndDecodeBytes(\"r\", RenVMType.B32, rArg);\n    var s = sArg.type === RenVMType.B ? assertAndDecodeBytes(\"s\", RenVMType.B, sArg) : assertAndDecodeBytes(\"s\", RenVMType.B32, sArg);\n    var v = vArg.type === RenVMType.B ? assertAndDecodeBytes(\"v\", RenVMType.B, vArg)[0] : assertAndDecodeNumber(\"v\", RenVMType.U8, vArg).toNumber();\n    var signature = signatureToBuffer(fixSignature(r, s, v, sighash, phash, amount, to, token, nhash, false, logger));\n    out.signature = signature; // r, s, v\n  }\n\n  return {\n    hash: toBase64(decodeBytes(response.tx.hash)),\n    txStatus: response.txStatus,\n    to: response.tx.to,\n    in: {\n      p: p,\n      token: token,\n      to: to,\n      n: n,\n      utxo: utxo\n    },\n    out: out\n  };\n};\nexport var unmarshalBurnTx = function unmarshalBurnTx(response) {\n  // TODO: Check that result is burn response.\n  // assert(\n  //     parseV1Selector(response.tx.to).from === Chain.Ethereum,\n  //     `Expected burn details but got back mint details (${response.tx.hash} - ${response.tx.to})`\n  // );\n  var _response$tx$in = _slicedToArray(response.tx.in, 3),\n      refArg = _response$tx$in[0],\n      toArg = _response$tx$in[1],\n      amountArg = _response$tx$in[2];\n\n  var ref = assertAndDecodeNumber(\"ref\", RenVMType.U64, refArg).toFixed();\n  var toRaw = assertArgumentType(\"to\", RenVMType.B, toArg);\n  var amount;\n\n  try {\n    amount = assertAndDecodeNumber(\"amount\", RenVMType.U256, amountArg).toFixed();\n  } catch (error) {\n    amount = assertAndDecodeNumber(\"amount\", RenVMType.U64, amountArg).toFixed();\n  }\n\n  var to = toRaw; // response.tx.to === Tokens.ZEC.Eth2Zec ?\n  //     utils.zec.addressFrom(toRaw) :\n  //     response.tx.to === Tokens.BCH.Eth2Bch ?\n  //         utils.bch.addressFrom(toRaw) :\n  //         utils.btc.addressFrom(toRaw);\n\n  return {\n    hash: toBase64(decodeBytes(response.tx.hash)),\n    to: response.tx.to,\n    in: {\n      ref: ref,\n      to: to,\n      amount: amount\n    },\n    txStatus: response.txStatus\n  };\n};\n\nvar unmarshalAssetFees = function unmarshalAssetFees(fees) {\n  var lock = fees.lock,\n      release = fees.release,\n      tokens = _objectWithoutProperties(fees, [\"lock\", \"release\"]); // TODO: Fix type errors.\n\n\n  return _objectSpread({\n    lock: decodeNumber(lock),\n    release: decodeNumber(release)\n  }, Object.keys(tokens).reduce(function (acc, token) {\n    return _objectSpread({}, acc, _defineProperty({}, token, {\n      mint: decodeNumber(fees[token].mint).toNumber(),\n      burn: decodeNumber(fees[token].burn).toNumber()\n    }));\n  }, {}));\n};\n\nexport var unmarshalFees = function unmarshalFees(response) {\n  var fees = {};\n\n  for (var _i = 0, _Object$keys = Object.keys(response); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    fees[key] = unmarshalAssetFees(response[key]);\n  }\n\n  return fees;\n};","map":null,"metadata":{},"sourceType":"module"}