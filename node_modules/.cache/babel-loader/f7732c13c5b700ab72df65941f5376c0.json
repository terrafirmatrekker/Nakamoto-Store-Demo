{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar baddress = require('./address');\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar btemplates = require('./templates');\n\nvar coins = require('./coins');\n\nvar networks = require('./networks');\n\nvar ops = require('bitcoin-ops');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar scriptTypes = btemplates.types;\nvar SIGNABLE = [btemplates.types.P2PKH, btemplates.types.P2PK, btemplates.types.MULTISIG];\nvar P2SH = SIGNABLE.concat([btemplates.types.P2WPKH, btemplates.types.P2WSH]);\n\nvar ECPair = require('./ecpair');\n\nvar ECSignature = require('./ecsignature');\n\nvar Transaction = require('./transaction');\n\nvar debug = require('debug')('bitgo:utxolib:txbuilder');\n\nfunction supportedType(type) {\n  return SIGNABLE.indexOf(type) !== -1;\n}\n\nfunction supportedP2SHType(type) {\n  return P2SH.indexOf(type) !== -1;\n}\n\nfunction extractChunks(type, chunks, script) {\n  var pubKeys = [];\n  var signatures = [];\n\n  switch (type) {\n    case scriptTypes.P2PKH:\n      // if (redeemScript) throw new Error('Nonstandard... P2SH(P2PKH)')\n      pubKeys = chunks.slice(1);\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys[0] = script ? btemplates.pubKey.output.decode(script) : undefined;\n      signatures = chunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      if (script) {\n        var multisig = btemplates.multisig.output.decode(script);\n        pubKeys = multisig.pubKeys;\n      }\n\n      signatures = chunks.slice(1).map(function (chunk) {\n        return chunk.length === 0 ? undefined : chunk;\n      });\n      break;\n  }\n\n  return {\n    pubKeys: pubKeys,\n    signatures: signatures\n  };\n}\n\nfunction expandInput(scriptSig, witnessStack) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n  var prevOutScript;\n  var prevOutType;\n  var scriptType;\n  var script;\n  var redeemScript;\n  var witnessScript;\n  var witnessScriptType;\n  var redeemScriptType;\n  var witness = false;\n  var p2wsh = false;\n  var p2sh = false;\n  var witnessProgram;\n  var chunks;\n  var scriptSigChunks = bscript.decompile(scriptSig);\n  var sigType = btemplates.classifyInput(scriptSigChunks, true);\n\n  if (sigType === scriptTypes.P2SH) {\n    p2sh = true;\n    redeemScript = scriptSigChunks[scriptSigChunks.length - 1];\n    redeemScriptType = btemplates.classifyOutput(redeemScript);\n    prevOutScript = btemplates.scriptHash.output.encode(bcrypto.hash160(redeemScript));\n    prevOutType = scriptTypes.P2SH;\n    script = redeemScript;\n  }\n\n  var classifyWitness = btemplates.classifyWitness(witnessStack, true);\n\n  if (classifyWitness === scriptTypes.P2WSH) {\n    witnessScript = witnessStack[witnessStack.length - 1];\n    witnessScriptType = btemplates.classifyOutput(witnessScript);\n    p2wsh = true;\n    witness = true;\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n      prevOutType = scriptTypes.P2WSH;\n\n      if (redeemScript !== undefined) {\n        throw new Error('Redeem script given when unnecessary');\n      } // bare witness\n\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WSH, but scriptSig non-empty');\n      }\n\n      witnessProgram = btemplates.witnessScriptHash.output.encode(bcrypto.sha256(witnessScript));\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script didn\\'t match witnessScript');\n      }\n    }\n\n    if (!supportedType(btemplates.classifyOutput(witnessScript))) {\n      throw new Error('unsupported witness script');\n    }\n\n    script = witnessScript;\n    scriptType = witnessScriptType;\n    chunks = witnessStack.slice(0, -1);\n  } else if (classifyWitness === scriptTypes.P2WPKH) {\n    witness = true;\n    var key = witnessStack[witnessStack.length - 1];\n    var keyHash = bcrypto.hash160(key);\n\n    if (scriptSig.length === 0) {\n      prevOutScript = btemplates.witnessPubKeyHash.output.encode(keyHash);\n      prevOutType = scriptTypes.P2WPKH;\n\n      if (typeof redeemScript !== 'undefined') {\n        throw new Error('Redeem script given when unnecessary');\n      }\n    } else {\n      if (!redeemScript) {\n        throw new Error('No redeemScript provided for P2WPKH, but scriptSig wasn\\'t empty');\n      }\n\n      witnessProgram = btemplates.witnessPubKeyHash.output.encode(keyHash);\n\n      if (!redeemScript.equals(witnessProgram)) {\n        throw new Error('Redeem script did not have the right witness program');\n      }\n    }\n\n    scriptType = scriptTypes.P2PKH;\n    chunks = witnessStack;\n  } else if (redeemScript) {\n    if (!supportedP2SHType(redeemScriptType)) {\n      throw new Error('Bad redeemscript!');\n    }\n\n    script = redeemScript;\n    scriptType = redeemScriptType;\n    chunks = scriptSigChunks.slice(0, -1);\n  } else {\n    prevOutType = scriptType = btemplates.classifyInput(scriptSig);\n    chunks = scriptSigChunks;\n  }\n\n  var expanded = extractChunks(scriptType, chunks, script);\n  var result = {\n    pubKeys: expanded.pubKeys,\n    signatures: expanded.signatures,\n    prevOutScript: prevOutScript,\n    prevOutType: prevOutType,\n    signType: scriptType,\n    signScript: script,\n    witness: Boolean(witness)\n  };\n\n  if (p2sh) {\n    result.redeemScript = redeemScript;\n    result.redeemScriptType = redeemScriptType;\n  }\n\n  if (p2wsh) {\n    result.witnessScript = witnessScript;\n    result.witnessScriptType = witnessScriptType;\n  }\n\n  return result;\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin, value, network) {\n  if (input.redeemScriptType !== scriptTypes.MULTISIG || !input.redeemScript) return;\n  if (input.pubKeys.length === input.signatures.length) return;\n  network = network || networks.bitcoin;\n  var unmatched = input.signatures.concat();\n  input.signatures = input.pubKeys.map(function (pubKey) {\n    var keyPair = ECPair.fromPublicKeyBuffer(pubKey);\n    var match; // check for a signature\n\n    unmatched.some(function (signature, i) {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      var parsed = ECSignature.parseScriptSignature(signature);\n      var hash;\n\n      switch (network.coin) {\n        case coins.BSV:\n        case coins.BCH:\n          hash = transaction.hashForCashSignature(vin, input.signScript, value, parsed.hashType);\n          break;\n\n        case coins.BTG:\n          hash = transaction.hashForGoldSignature(vin, input.signScript, value, parsed.hashType);\n          break;\n\n        case coins.ZEC:\n          if (value === undefined) {\n            return false;\n          }\n\n          hash = transaction.hashForZcashSignature(vin, input.signScript, value, parsed.hashType);\n          break;\n\n        default:\n          if (input.witness) {\n            hash = transaction.hashForWitnessV0(vin, input.signScript, value, parsed.hashType);\n          } else {\n            hash = transaction.hashForSignature(vin, input.signScript, parsed.hashType);\n          }\n\n          break;\n      } // skip if signature does not match pubKey\n\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, scriptType, ourPubKey) {\n  typeforce(types.Buffer, script);\n  var scriptChunks = bscript.decompile(script);\n\n  if (!scriptType) {\n    scriptType = btemplates.classifyOutput(script);\n  }\n\n  var pubKeys = [];\n\n  switch (scriptType) {\n    // does our hash160(pubKey) match the output scripts?\n    case scriptTypes.P2PKH:\n      if (!ourPubKey) break;\n      var pkh1 = scriptChunks[2];\n      var pkh2 = bcrypto.hash160(ourPubKey);\n      if (pkh1.equals(pkh2)) pubKeys = [ourPubKey];\n      break;\n    // does our hash160(pubKey) match the output scripts?\n\n    case scriptTypes.P2WPKH:\n      if (!ourPubKey) break;\n      var wpkh1 = scriptChunks[1];\n      var wpkh2 = bcrypto.hash160(ourPubKey);\n      if (wpkh1.equals(wpkh2)) pubKeys = [ourPubKey];\n      break;\n\n    case scriptTypes.P2PK:\n      pubKeys = scriptChunks.slice(0, 1);\n      break;\n\n    case scriptTypes.MULTISIG:\n      pubKeys = scriptChunks.slice(1, -2);\n      break;\n\n    default:\n      return {\n        scriptType: scriptType\n      };\n  }\n\n  return {\n    pubKeys: pubKeys,\n    scriptType: scriptType,\n    signatures: pubKeys.map(function () {\n      return undefined;\n    })\n  };\n}\n\nfunction checkP2SHInput(input, redeemScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2SH) throw new Error('PrevOutScript must be P2SH');\n    var prevOutScriptScriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!prevOutScriptScriptHash.equals(redeemScriptHash)) throw new Error('Inconsistent hash160(RedeemScript)');\n  }\n}\n\nfunction checkP2WSHInput(input, witnessScriptHash) {\n  if (input.prevOutType) {\n    if (input.prevOutType !== scriptTypes.P2WSH) throw new Error('PrevOutScript must be P2WSH');\n    var scriptHash = bscript.decompile(input.prevOutScript)[1];\n    if (!scriptHash.equals(witnessScriptHash)) throw new Error('Inconsistent sha25(WitnessScript)');\n  }\n}\n\nfunction prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript) {\n  var expanded;\n  var prevOutType;\n  var prevOutScript;\n  var p2sh = false;\n  var p2shType;\n  var redeemScriptHash;\n  var witness = false;\n  var p2wsh = false;\n  var witnessType;\n  var witnessScriptHash;\n  var signType;\n  var signScript;\n\n  if (redeemScript && witnessScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2SHInput(input, redeemScriptHash);\n    if (!redeemScript.equals(btemplates.witnessScriptHash.output.encode(witnessScriptHash))) throw new Error('Witness script inconsistent with redeem script');\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = witness = p2wsh = true;\n    p2shType = btemplates.types.P2WSH;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (redeemScript) {\n    redeemScriptHash = bcrypto.hash160(redeemScript);\n    checkP2SHInput(input, redeemScriptHash);\n    expanded = expandOutput(redeemScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('RedeemScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2SH;\n    prevOutScript = btemplates.scriptHash.output.encode(redeemScriptHash);\n    p2sh = true;\n    signType = p2shType = expanded.scriptType;\n    signScript = redeemScript;\n    witness = signType === btemplates.types.P2WPKH;\n  } else if (witnessScript) {\n    witnessScriptHash = bcrypto.sha256(witnessScript);\n    checkP2WSHInput(input, witnessScriptHash);\n    expanded = expandOutput(witnessScript, undefined, kpPubKey);\n    if (!expanded.pubKeys) throw new Error('WitnessScript not supported \"' + bscript.toASM(redeemScript) + '\"');\n    prevOutType = btemplates.types.P2WSH;\n    prevOutScript = btemplates.witnessScriptHash.output.encode(witnessScriptHash);\n    witness = p2wsh = true;\n    signType = witnessType = expanded.scriptType;\n    signScript = witnessScript;\n  } else if (input.prevOutType) {\n    // embedded scripts are not possible without a redeemScript\n    if (input.prevOutType === scriptTypes.P2SH || input.prevOutType === scriptTypes.P2WSH) {\n      throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    }\n\n    prevOutType = input.prevOutType;\n    prevOutScript = input.prevOutScript;\n    expanded = expandOutput(input.prevOutScript, input.prevOutType, kpPubKey);\n    if (!expanded.pubKeys) return;\n    witness = input.prevOutType === scriptTypes.P2WPKH;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  } else {\n    prevOutScript = btemplates.pubKeyHash.output.encode(bcrypto.hash160(kpPubKey));\n    expanded = expandOutput(prevOutScript, scriptTypes.P2PKH, kpPubKey);\n    prevOutType = scriptTypes.P2PKH;\n    witness = false;\n    signType = prevOutType;\n    signScript = prevOutScript;\n  }\n\n  if (signType === scriptTypes.P2WPKH) {\n    signScript = btemplates.pubKeyHash.output.encode(btemplates.witnessPubKeyHash.output.decode(signScript));\n  }\n\n  if (p2sh) {\n    input.redeemScript = redeemScript;\n    input.redeemScriptType = p2shType;\n  }\n\n  if (p2wsh) {\n    input.witnessScript = witnessScript;\n    input.witnessScriptType = witnessType;\n  }\n\n  input.pubKeys = expanded.pubKeys;\n  input.signatures = expanded.signatures;\n  input.signScript = signScript;\n  input.signType = signType;\n  input.prevOutScript = prevOutScript;\n  input.prevOutType = prevOutType;\n  input.witness = witness;\n}\n\nfunction buildStack(type, signatures, pubKeys, allowIncomplete) {\n  if (type === scriptTypes.P2PKH) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0]) && pubKeys.length === 1) return btemplates.pubKeyHash.input.encodeStack(signatures[0], pubKeys[0]);\n  } else if (type === scriptTypes.P2PK) {\n    if (signatures.length === 1 && Buffer.isBuffer(signatures[0])) return btemplates.pubKey.input.encodeStack(signatures[0]);\n  } else if (type === scriptTypes.MULTISIG) {\n    if (signatures.length > 0) {\n      signatures = signatures.map(function (signature) {\n        return signature || ops.OP_0;\n      });\n\n      if (!allowIncomplete) {\n        // remove blank signatures\n        signatures = signatures.filter(function (x) {\n          return x !== ops.OP_0;\n        });\n      }\n\n      return btemplates.multisig.input.encodeStack(signatures);\n    }\n  } else {\n    throw new Error('Not yet supported');\n  }\n\n  if (!allowIncomplete) throw new Error('Not enough signatures provided');\n  return [];\n}\n\nfunction buildInput(input, allowIncomplete) {\n  var scriptType = input.prevOutType;\n  var sig = [];\n  var witness = [];\n\n  if (supportedType(scriptType)) {\n    sig = buildStack(scriptType, input.signatures, input.pubKeys, allowIncomplete);\n  }\n\n  var p2sh = false;\n\n  if (scriptType === btemplates.types.P2SH) {\n    // We can remove this error later when we have a guarantee prepareInput\n    // rejects unsignable scripts - it MUST be signable at this point.\n    if (!allowIncomplete && !supportedP2SHType(input.redeemScriptType)) {\n      throw new Error('Impossible to sign this type');\n    }\n\n    if (supportedType(input.redeemScriptType)) {\n      sig = buildStack(input.redeemScriptType, input.signatures, input.pubKeys, allowIncomplete);\n    } // If it wasn't SIGNABLE, it's witness, defer to that\n\n\n    if (input.redeemScriptType) {\n      p2sh = true;\n      scriptType = input.redeemScriptType;\n    }\n  }\n\n  switch (scriptType) {\n    // P2WPKH is a special case of P2PKH\n    case btemplates.types.P2WPKH:\n      witness = buildStack(btemplates.types.P2PKH, input.signatures, input.pubKeys, allowIncomplete);\n      break;\n\n    case btemplates.types.P2WSH:\n      // We can remove this check later\n      if (!allowIncomplete && !supportedType(input.witnessScriptType)) {\n        throw new Error('Impossible to sign this type');\n      }\n\n      if (supportedType(input.witnessScriptType)) {\n        witness = buildStack(input.witnessScriptType, input.signatures, input.pubKeys, allowIncomplete);\n        witness.push(input.witnessScript);\n        scriptType = input.witnessScriptType;\n      }\n\n      break;\n  } // append redeemScript if necessary\n\n\n  if (p2sh) {\n    sig.push(input.redeemScript);\n  }\n\n  return {\n    type: scriptType,\n    script: bscript.compile(sig),\n    witness: witness\n  };\n} // By default, assume is a bitcoin transaction\n\n\nfunction TransactionBuilder(network, maximumFeeRate) {\n  this.prevTxMap = {};\n  this.network = network || networks.bitcoin; // WARNING: This is __NOT__ to be relied on, its just another potential safety mechanism (safety in-depth)\n\n  this.maximumFeeRate = maximumFeeRate || 2500;\n  this.inputs = [];\n  this.tx = new Transaction(this.network);\n}\n\nTransactionBuilder.prototype.setLockTime = function (locktime) {\n  typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n  if (this.inputs.some(function (input) {\n    if (!input.signatures) return false;\n    return input.signatures.some(function (s) {\n      return s;\n    });\n  })) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  this.tx.locktime = locktime;\n};\n\nTransactionBuilder.prototype.setVersion = function (version) {\n  var overwinter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  typeforce(types.UInt32, version);\n\n  if (coins.isZcash(this.network)) {\n    if (!this.network.consensusBranchId.hasOwnProperty(this.tx.version)) {\n      throw new Error('Unsupported Zcash transaction');\n    }\n\n    this.tx.overwintered = overwinter ? 1 : 0;\n  }\n\n  this.tx.version = version;\n};\n\nTransactionBuilder.prototype.setVersionGroupId = function (versionGroupId) {\n  if (!(coins.isZcash(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n\n  typeforce(types.UInt32, versionGroupId);\n  this.tx.versionGroupId = versionGroupId;\n};\n\nTransactionBuilder.prototype.setExpiryHeight = function (expiryHeight) {\n  if (!(coins.isZcash(this.network) && this.tx.isOverwinterCompatible())) {\n    throw new Error('expiryHeight can only be set for Zcash starting at overwinter version. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n\n  typeforce(types.UInt32, expiryHeight);\n  this.tx.expiryHeight = expiryHeight;\n};\n\nTransactionBuilder.prototype.setJoinSplits = function (transaction) {\n  if (!(coins.isZcash(this.network) && this.tx.supportsJoinSplits())) {\n    throw new Error('joinsplits can only be set for Zcash starting at version 2. Current network coin: ' + this.network.coin + ', version: ' + this.tx.version);\n  }\n\n  if (transaction && transaction.joinsplits) {\n    this.tx.joinsplits = transaction.joinsplits.map(function (txJoinsplit) {\n      return {\n        vpubOld: txJoinsplit.vpubOld,\n        vpubNew: txJoinsplit.vpubNew,\n        anchor: txJoinsplit.anchor,\n        nullifiers: txJoinsplit.nullifiers,\n        commitments: txJoinsplit.commitments,\n        ephemeralKey: txJoinsplit.ephemeralKey,\n        randomSeed: txJoinsplit.randomSeed,\n        macs: txJoinsplit.macs,\n        zproof: txJoinsplit.zproof,\n        ciphertexts: txJoinsplit.ciphertexts\n      };\n    });\n    this.tx.joinsplitPubkey = transaction.joinsplitPubkey;\n    this.tx.joinsplitSig = transaction.joinsplitSig;\n    return;\n  }\n\n  throw new Error('Invalid transaction with joinsplits');\n};\n\nTransactionBuilder.fromTransaction = function (transaction, network) {\n  var txbNetwork = network || networks.bitcoin;\n  var txb = new TransactionBuilder(txbNetwork);\n\n  if (txb.network.coin !== transaction.network.coin) {\n    throw new Error('This transaction is incompatible with the transaction builder');\n  } // Copy transaction fields\n\n\n  txb.setVersion(transaction.version, transaction.overwintered);\n  txb.setLockTime(transaction.locktime);\n\n  if (coins.isZcash(txbNetwork)) {\n    // Copy Zcash overwinter fields. Omitted if the transaction builder is not for Zcash.\n    if (txb.tx.isOverwinterCompatible()) {\n      txb.setVersionGroupId(transaction.versionGroupId);\n      txb.setExpiryHeight(transaction.expiryHeight);\n    } // We don't support protected transactions but we copy the joinsplits for consistency. However, the transaction\n    // builder will fail when we try to sign one of these transactions\n\n\n    if (txb.tx.supportsJoinSplits()) {\n      txb.setJoinSplits(transaction);\n    }\n  } // Copy Dash special transaction fields. Omitted if the transaction builder is not for Dash.\n\n\n  if (coins.isDash(txbNetwork)) {\n    typeforce(types.UInt16, transaction.type);\n    txb.tx.type = transaction.type;\n\n    if (txb.tx.versionSupportsDashSpecialTransactions()) {\n      typeforce(types.Buffer, transaction.extraPayload);\n      txb.tx.extraPayload = transaction.extraPayload;\n    }\n  } // Copy outputs (done first to avoid signature invalidation)\n\n\n  transaction.outs.forEach(function (txOut) {\n    txb.addOutput(txOut.script, txOut.value);\n  }); // Copy inputs\n\n  transaction.ins.forEach(function (txIn) {\n    txb.__addInputUnsafe(txIn.hash, txIn.index, {\n      sequence: txIn.sequence,\n      script: txIn.script,\n      witness: txIn.witness,\n      value: txIn.value\n    });\n  }); // fix some things not possible through the public API\n\n  txb.inputs.forEach(function (input, i) {\n    fixMultisigOrder(input, transaction, i, input.value, txbNetwork);\n  });\n  return txb;\n};\n\nTransactionBuilder.prototype.addInput = function (txHash, vout, sequence, prevOutScript) {\n  if (!this.__canModifyInputs()) {\n    throw new Error('No, this would invalidate signatures');\n  }\n\n  var value; // is it a hex string?\n\n  if (typeof txHash === 'string') {\n    // transaction hashs's are displayed in reverse order, un-reverse it\n    txHash = Buffer.from(txHash, 'hex').reverse(); // is it a Transaction object?\n  } else if (txHash instanceof Transaction) {\n    var txOut = txHash.outs[vout];\n    prevOutScript = txOut.script;\n    value = txOut.value;\n    txHash = txHash.getHash();\n  }\n\n  return this.__addInputUnsafe(txHash, vout, {\n    sequence: sequence,\n    prevOutScript: prevOutScript,\n    value: value\n  });\n};\n\nTransactionBuilder.prototype.__addInputUnsafe = function (txHash, vout, options) {\n  if (Transaction.isCoinbaseHash(txHash)) {\n    throw new Error('coinbase inputs not supported');\n  }\n\n  var prevTxOut = txHash.toString('hex') + ':' + vout;\n  if (this.prevTxMap[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n  var input = {}; // derive what we can from the scriptSig\n\n  if (options.script !== undefined) {\n    input = expandInput(options.script, options.witness || []);\n  } // if an input value was given, retain it\n\n\n  if (options.value !== undefined) {\n    input.value = options.value;\n  } // derive what we can from the previous transactions output script\n\n\n  if (!input.prevOutScript && options.prevOutScript) {\n    var prevOutType;\n\n    if (!input.pubKeys && !input.signatures) {\n      var expanded = expandOutput(options.prevOutScript);\n\n      if (expanded.pubKeys) {\n        input.pubKeys = expanded.pubKeys;\n        input.signatures = expanded.signatures;\n      }\n\n      prevOutType = expanded.scriptType;\n    }\n\n    input.prevOutScript = options.prevOutScript;\n    input.prevOutType = prevOutType || btemplates.classifyOutput(options.prevOutScript);\n  }\n\n  var vin = this.tx.addInput(txHash, vout, options.sequence, options.scriptSig);\n  this.inputs[vin] = input;\n  this.prevTxMap[prevTxOut] = vin;\n  return vin;\n};\n\nTransactionBuilder.prototype.addOutput = function (scriptPubKey, value) {\n  if (!this.__canModifyOutputs()) {\n    throw new Error('No, this would invalidate signatures');\n  } // Attempt to get a script if it's a base58 address string\n\n\n  if (typeof scriptPubKey === 'string') {\n    scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n  }\n\n  return this.tx.addOutput(scriptPubKey, value);\n};\n\nTransactionBuilder.prototype.build = function () {\n  return this.__build(false);\n};\n\nTransactionBuilder.prototype.buildIncomplete = function () {\n  return this.__build(true);\n};\n\nTransactionBuilder.prototype.__build = function (allowIncomplete) {\n  if (!allowIncomplete) {\n    if (!this.tx.ins.length) throw new Error('Transaction has no inputs');\n    if (!this.tx.outs.length) throw new Error('Transaction has no outputs');\n  }\n\n  var tx = this.tx.clone(); // Create script signatures from inputs\n\n  this.inputs.forEach(function (input, i) {\n    var scriptType = input.witnessScriptType || input.redeemScriptType || input.prevOutType;\n    if (!scriptType && !allowIncomplete) throw new Error('Transaction is not complete');\n    var result = buildInput(input, allowIncomplete); // skip if no result\n\n    if (!allowIncomplete) {\n      if (!supportedType(result.type) && result.type !== btemplates.types.P2WPKH) {\n        throw new Error(result.type + ' not supported');\n      }\n    }\n\n    tx.setInputScript(i, result.script);\n    tx.setWitness(i, result.witness);\n  });\n\n  if (!allowIncomplete) {\n    // do not rely on this, its merely a last resort\n    if (this.__overMaximumFees(tx.virtualSize())) {\n      throw new Error('Transaction has absurd fees');\n    }\n  }\n\n  return tx;\n};\n\nfunction canSign(input) {\n  return input.prevOutScript !== undefined && input.signScript !== undefined && input.pubKeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubKeys.length && input.pubKeys.length > 0 && (input.witness === false || input.witness === true && input.value !== undefined);\n}\n\nTransactionBuilder.prototype.sign = function (vin, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n  debug('Signing transaction: (input: %d, hashType: %d, witnessVal: %s, witnessScript: %j)', vin, hashType, witnessValue, witnessScript);\n  debug('Transaction Builder network: %j', this.network); // TODO: remove keyPair.network matching in 4.0.0\n\n  if (keyPair.network && keyPair.network !== this.network) throw new TypeError('Inconsistent network');\n  if (!this.inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || Transaction.SIGHASH_ALL;\n  var input = this.inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  var kpPubKey = keyPair.publicKey || keyPair.getPublicKeyBuffer();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input didn\\'t match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    debug('Preparing input %d for signing', vin);\n    if (!canSign(input)) prepareInput(input, kpPubKey, redeemScript, witnessValue, witnessScript);\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n\n\n  var signatureHash;\n\n  if (coins.isBitcoinGold(this.network)) {\n    signatureHash = this.tx.hashForGoldSignature(vin, input.signScript, witnessValue, hashType, input.witness);\n    debug('Calculated BTG sighash (%s)', signatureHash.toString('hex'));\n  } else if (coins.isBitcoinCash(this.network) || coins.isBitcoinSV(this.network)) {\n    signatureHash = this.tx.hashForCashSignature(vin, input.signScript, witnessValue, hashType);\n    debug('Calculated BCH sighash (%s)', signatureHash.toString('hex'));\n  } else if (coins.isZcash(this.network)) {\n    signatureHash = this.tx.hashForZcashSignature(vin, input.signScript, witnessValue, hashType);\n    debug('Calculated ZEC sighash (%s)', signatureHash.toString('hex'));\n  } else {\n    if (input.witness) {\n      signatureHash = this.tx.hashForWitnessV0(vin, input.signScript, witnessValue, hashType);\n      debug('Calculated witnessv0 sighash (%s)', signatureHash.toString('hex'));\n    } else {\n      signatureHash = this.tx.hashForSignature(vin, input.signScript, hashType);\n      debug('Calculated sighash (%s)', signatureHash.toString('hex'));\n    }\n  } // enforce in order signing of public keys\n\n\n  var signed = input.pubKeys.some(function (pubKey, i) {\n    if (!kpPubKey.equals(pubKey)) return false;\n    if (input.signatures[i]) throw new Error('Signature already exists');\n    if (kpPubKey.length !== 33 && input.signType === scriptTypes.P2WPKH) throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    var signature = keyPair.sign(signatureHash);\n    if (Buffer.isBuffer(signature)) signature = ECSignature.fromRSBuffer(signature);\n    debug('Produced signature (r: %s, s: %s)', signature.r, signature.s);\n    input.signatures[i] = signature.toScriptSignature(hashType);\n    return true;\n  });\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n};\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nTransactionBuilder.prototype.__canModifyInputs = function () {\n  return this.inputs.every(function (input) {\n    // any signatures?\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n      // be invalidated by more inputs\n\n      return hashType & Transaction.SIGHASH_ANYONECANPAY;\n    });\n  });\n};\n\nTransactionBuilder.prototype.__canModifyOutputs = function () {\n  var nInputs = this.tx.ins.length;\n  var nOutputs = this.tx.outs.length;\n  return this.inputs.every(function (input) {\n    if (input.signatures === undefined) return true;\n    return input.signatures.every(function (signature) {\n      if (!signature) return true;\n      var hashType = signatureHashType(signature);\n      var hashTypeMod = hashType & 0x1f;\n      if (hashTypeMod === Transaction.SIGHASH_NONE) return true;\n\n      if (hashTypeMod === Transaction.SIGHASH_SINGLE) {\n        // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n        // some signatures would be invalidated by the addition\n        // of more outputs\n        return nInputs <= nOutputs;\n      }\n    });\n  });\n};\n\nTransactionBuilder.prototype.__overMaximumFees = function (bytes) {\n  // not all inputs will have .value defined\n  var incoming = this.inputs.reduce(function (a, x) {\n    return a + (x.value >>> 0);\n  }, 0); // but all outputs do, and if we have any input value\n  // we can immediately determine if the outputs are too small\n\n  var outgoing = this.tx.outs.reduce(function (a, x) {\n    return a + x.value;\n  }, 0);\n  var fee = incoming - outgoing;\n  var feeRate = fee / bytes;\n  return feeRate > this.maximumFeeRate;\n};\n\nmodule.exports = TransactionBuilder;","map":null,"metadata":{},"sourceType":"script"}