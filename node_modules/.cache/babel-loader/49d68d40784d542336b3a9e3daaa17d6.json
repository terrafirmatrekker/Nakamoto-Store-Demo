{"ast":null,"code":"import { fromBase64 } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nexport var PackPrimitive;\n\n(function (PackPrimitive) {\n  PackPrimitive[\"Bool\"] = \"bool\";\n  PackPrimitive[\"U8\"] = \"u8\";\n  PackPrimitive[\"U16\"] = \"u16\";\n  PackPrimitive[\"U32\"] = \"u32\";\n  PackPrimitive[\"U64\"] = \"u64\";\n  PackPrimitive[\"U128\"] = \"u128\";\n  PackPrimitive[\"U256\"] = \"u256\";\n  PackPrimitive[\"Str\"] = \"string\";\n  PackPrimitive[\"Bytes\"] = \"bytes\";\n  PackPrimitive[\"Bytes32\"] = \"bytes32\";\n  PackPrimitive[\"Bytes65\"] = \"bytes65\";\n})(PackPrimitive || (PackPrimitive = {})); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport var unmarshalPackPrimitive = function unmarshalPackPrimitive(type, value) {\n  switch (type) {\n    // Booleans\n    case PackPrimitive.Bool:\n      return value;\n    // Integers\n\n    case PackPrimitive.U8:\n    case PackPrimitive.U16:\n    case PackPrimitive.U32:\n    case PackPrimitive.U64:\n    case PackPrimitive.U128:\n    case PackPrimitive.U256:\n      return new BigNumber(value);\n    // Strings\n\n    case PackPrimitive.Str:\n      return Buffer.from(value);\n    // Bytes\n\n    case PackPrimitive.Bytes:\n    case PackPrimitive.Bytes32:\n    case PackPrimitive.Bytes65:\n      return fromBase64(value);\n  }\n};\nexport var unmarshalPackStruct = function unmarshalPackStruct(type, value) {\n  var struct = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = type.struct[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var member = _step.value;\n      var keys = Object.keys(member);\n\n      if (keys.length === 0) {\n        throw new Error(\"Invalid struct member with no entries.\");\n      }\n\n      if (keys.length > 1) {\n        throw new Error(\"Invalid struct member with multiple entries.\");\n      }\n\n      var key = Object.keys(member)[0];\n      var memberType = member[key];\n\n      if (value && !value.hasOwnProperty(key)) {\n        throw new Error(\"Missing pack value for key \".concat(key, \".\"));\n      }\n\n      struct[key] = unmarshalPackValue(memberType, value[key]);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return struct;\n};\nexport var unmarshalPackValue = function unmarshalPackValue(type, value) {\n  if (typeof type === \"object\") {\n    return unmarshalPackStruct(type, value);\n  } else if (typeof type === \"string\") {\n    if (type === \"nil\") return null;\n    return unmarshalPackPrimitive(type, value);\n  }\n\n  throw new Error(\"Unknown value type \".concat(String(type)).concat(!type ? \" for value \".concat(String(value)) : \"\", \".\"));\n};\nexport var unmarshalTypedPackValue = function unmarshalTypedPackValue(_ref) {\n  var t = _ref.t,\n      v = _ref.v;\n  return unmarshalPackValue(t, v);\n};","map":null,"metadata":{},"sourceType":"module"}