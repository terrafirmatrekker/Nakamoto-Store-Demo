{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('../../util/preconditions');\n\nvar errors = require('../../errors');\n\nvar BufferWriter = require('../../encoding/bufferwriter');\n\nvar buffer = require('buffer');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar JSUtil = require('../../util/js');\n\nvar Script = require('../../script');\n\nvar Sighash = require('../sighash');\n\nvar Output = require('../output');\n\nvar MAXINT = 0xffffffff; // Math.pow(2, 32) - 1;\n\nvar DEFAULT_RBF_SEQNUMBER = MAXINT - 2;\nvar DEFAULT_SEQNUMBER = MAXINT;\nvar DEFAULT_LOCKTIME_SEQNUMBER = MAXINT - 1;\nvar SEQUENCE_LOCKTIME_DISABLE_FLAG = Math.pow(2, 31); // (1 << 31);\n\nvar SEQUENCE_LOCKTIME_TYPE_FLAG = Math.pow(2, 22); // (1 << 22);\n\nvar SEQUENCE_LOCKTIME_MASK = 0xffff;\nvar SEQUENCE_LOCKTIME_GRANULARITY = 512; // 512 seconds\n\nvar SEQUENCE_BLOCKDIFF_LIMIT = Math.pow(2, 16) - 1; // 16 bits \n\nfunction Input(params) {\n  if (!(this instanceof Input)) {\n    return new Input(params);\n  }\n\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nInput.MAXINT = MAXINT;\nInput.DEFAULT_SEQNUMBER = DEFAULT_SEQNUMBER;\nInput.DEFAULT_LOCKTIME_SEQNUMBER = DEFAULT_LOCKTIME_SEQNUMBER;\nInput.DEFAULT_RBF_SEQNUMBER = DEFAULT_RBF_SEQNUMBER;\nInput.SEQUENCE_LOCKTIME_TYPE_FLAG = SEQUENCE_LOCKTIME_TYPE_FLAG;\nObject.defineProperty(Input.prototype, 'script', {\n  configurable: false,\n  enumerable: true,\n  get: function get() {\n    if (this.isNull()) {\n      return null;\n    }\n\n    if (!this._script) {\n      this._script = new Script(this._scriptBuffer);\n      this._script._isInput = true;\n    }\n\n    return this._script;\n  }\n});\n\nInput.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj));\n  var input = new Input();\n  return input._fromObject(obj);\n};\n\nInput.prototype._fromObject = function (params) {\n  var prevTxId;\n\n  if (_.isString(params.prevTxId) && JSUtil.isHexa(params.prevTxId)) {\n    prevTxId = Buffer.from(params.prevTxId, 'hex');\n  } else {\n    prevTxId = params.prevTxId;\n  }\n\n  this.output = params.output ? params.output instanceof Output ? params.output : new Output(params.output) : undefined;\n  this.prevTxId = prevTxId || params.txidbuf;\n  this.outputIndex = _.isUndefined(params.outputIndex) ? params.txoutnum : params.outputIndex;\n  this.sequenceNumber = _.isUndefined(params.sequenceNumber) ? _.isUndefined(params.seqnum) ? DEFAULT_SEQNUMBER : params.seqnum : params.sequenceNumber;\n\n  if (_.isUndefined(params.script) && _.isUndefined(params.scriptBuffer)) {\n    throw new errors.Transaction.Input.MissingScript();\n  }\n\n  this.setScript(params.scriptBuffer || params.script);\n  return this;\n};\n\nInput.prototype.toObject = Input.prototype.toJSON = function toObject() {\n  var obj = {\n    prevTxId: this.prevTxId.toString('hex'),\n    outputIndex: this.outputIndex,\n    sequenceNumber: this.sequenceNumber,\n    script: this._scriptBuffer.toString('hex')\n  }; // add human readable form if input contains valid script\n\n  if (this.script) {\n    obj.scriptString = this.script.toString();\n  }\n\n  if (this.output) {\n    obj.output = this.output.toObject();\n  }\n\n  return obj;\n};\n\nInput.fromBufferReader = function (br) {\n  var input = new Input();\n  input.prevTxId = br.readReverse(32);\n  input.outputIndex = br.readUInt32LE();\n  input._scriptBuffer = br.readVarLengthBuffer();\n  input.sequenceNumber = br.readUInt32LE(); // TODO: return different classes according to which input it is\n  // e.g: CoinbaseInput, PublicKeyHashInput, MultiSigScriptHashInput, etc.\n\n  return input;\n};\n\nInput.prototype.toBufferWriter = function (writer) {\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n\n  writer.writeReverse(this.prevTxId);\n  writer.writeUInt32LE(this.outputIndex);\n  var script = this._scriptBuffer;\n  writer.writeVarintNum(script.length);\n  writer.write(script);\n  writer.writeUInt32LE(this.sequenceNumber);\n  return writer;\n};\n\nInput.prototype.setScript = function (script) {\n  this._script = null;\n\n  if (script instanceof Script) {\n    this._script = script;\n    this._script._isInput = true;\n    this._scriptBuffer = script.toBuffer();\n  } else if (script === null) {\n    this._script = Script.empty();\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (JSUtil.isHexa(script)) {\n    // hex string script\n    this._scriptBuffer = Buffer.from(script, 'hex');\n  } else if (_.isString(script)) {\n    // human readable string script\n    this._script = new Script(script);\n    this._script._isInput = true;\n    this._scriptBuffer = this._script.toBuffer();\n  } else if (BufferUtil.isBuffer(script)) {\n    // buffer script\n    this._scriptBuffer = Buffer.from(script);\n  } else {\n    throw new TypeError('Invalid argument type: script');\n  }\n\n  return this;\n};\n/**\n * Retrieve signatures for the provided PrivateKey.\n *\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key to use when signing\n * @param {number} inputIndex - the index of this input in the provided transaction\n * @param {number} sigType - defaults to Signature.SIGHASH_ALL\n * @param {Buffer} addressHash - if provided, don't calculate the hash of the\n *     public key associated with the private key provided\n * @param {String} signingMethod \"schnorr\" or \"ecdsa\", default to \"ecdsa\" if not provided\n * @abstract\n */\n\n\nInput.prototype.getSignatures = function () {\n  throw new errors.AbstractMethodInvoked('Trying to sign unsupported output type (only P2PKH and P2SH multisig inputs are supported)' + ' for input: ' + JSON.stringify(this));\n};\n\nInput.prototype.isFullySigned = function () {\n  throw new errors.AbstractMethodInvoked('Input#isFullySigned');\n};\n\nInput.prototype.isFinal = function () {\n  return this.sequenceNumber !== 4294967295;\n};\n\nInput.prototype.addSignature = function () {\n  throw new errors.AbstractMethodInvoked('Input#addSignature');\n};\n\nInput.prototype.clearSignatures = function () {\n  throw new errors.AbstractMethodInvoked('Input#clearSignatures');\n};\n\nInput.prototype.isValidSignature = function (transaction, signature, signingMethod) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.output.script, this.output.satoshisBN, undefined, signingMethod);\n};\n/**\n * @returns true if this is a coinbase input (represents no input)\n */\n\n\nInput.prototype.isNull = function () {\n  return this.prevTxId.toString('hex') === '0000000000000000000000000000000000000000000000000000000000000000' && this.outputIndex === 0xffffffff;\n};\n\nInput.prototype._estimateSize = function () {\n  return this.toBufferWriter().toBuffer().length;\n};\n/**\n * Sets sequence number so that transaction is not valid until the desired seconds\n *  since the transaction is mined\n *\n * @param {Number} time in seconds\n * @return {Transaction} this\n */\n\n\nInput.prototype.lockForSeconds = function (seconds) {\n  $.checkArgument(_.isNumber(seconds));\n\n  if (seconds < 0 || seconds >= SEQUENCE_LOCKTIME_GRANULARITY * SEQUENCE_LOCKTIME_MASK) {\n    throw new errors.Transaction.Input.LockTimeRange();\n  }\n\n  seconds = parseInt(Math.floor(seconds / SEQUENCE_LOCKTIME_GRANULARITY)); // SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 \n\n  this.sequenceNumber = seconds | SEQUENCE_LOCKTIME_TYPE_FLAG;\n  return this;\n};\n/**\n * Sets sequence number so that transaction is not valid until the desired block height differnece since the tx is mined\n *\n * @param {Number} height\n * @return {Transaction} this\n */\n\n\nInput.prototype.lockUntilBlockHeight = function (heightDiff) {\n  $.checkArgument(_.isNumber(heightDiff));\n\n  if (heightDiff < 0 || heightDiff >= SEQUENCE_BLOCKDIFF_LIMIT) {\n    throw new errors.Transaction.Input.BlockHeightOutOfRange();\n  } // SEQUENCE_LOCKTIME_TYPE_FLAG = 0\n  // SEQUENCE_LOCKTIME_DISABLE_FLAG = 0\n\n\n  this.sequenceNumber = heightDiff;\n  return this;\n};\n/**\n *  Returns a semantic version of the input's sequence nLockTime.\n *  @return {Number|Date}\n *  If sequence lock is disabled  it returns null,\n *  if is set to block height lock, returns a block height (number)\n *  else it returns a Date object.\n */\n\n\nInput.prototype.getLockTime = function () {\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return null;\n  }\n\n  if (this.sequenceNumber & SEQUENCE_LOCKTIME_TYPE_FLAG) {\n    var seconds = SEQUENCE_LOCKTIME_GRANULARITY * (this.sequenceNumber & SEQUENCE_LOCKTIME_MASK);\n    return seconds;\n  } else {\n    var blockHeight = this.sequenceNumber & SEQUENCE_LOCKTIME_MASK;\n    return blockHeight;\n  }\n};\n\nmodule.exports = Input;","map":null,"metadata":{},"sourceType":"script"}