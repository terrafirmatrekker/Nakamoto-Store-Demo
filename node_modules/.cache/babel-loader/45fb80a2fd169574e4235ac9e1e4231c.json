{"ast":null,"code":"import _extends from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/extends\";\nimport _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _objectSpread from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { getRenNetworkDetails, newPromiEvent, NullLogger } from \"@renproject/interfaces\";\nimport { assertObject, assertType, fromBase64, generateBurnTxHash, generateGHash, generateNHash, generatePHash, generateSHash, isDefined, Ox, renVMHashToBase64, retryNTimes, SECONDS, sleep, toBase64, toURLBase64 } from \"@renproject/utils\";\nimport BN from \"bn.js\";\nimport BigNumber from \"bignumber.js\";\nexport var BurnAndReleaseStatus;\n\n(function (BurnAndReleaseStatus) {\n  BurnAndReleaseStatus[\"Pending\"] = \"pending\";\n  BurnAndReleaseStatus[\"Burned\"] = \"burned\";\n  BurnAndReleaseStatus[\"Released\"] = \"released\";\n  BurnAndReleaseStatus[\"Reverted\"] = \"reverted\";\n})(BurnAndReleaseStatus || (BurnAndReleaseStatus = {}));\n\nexport var BurnAndRelease =\n/** @hidden */\nfunction BurnAndRelease(renVM, params) {\n  var _this = this;\n\n  var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  _classCallCheck(this, BurnAndRelease);\n\n  this.validateParams = function () {\n    assertObject({\n      from: \"object | undefined\",\n      to: \"object\",\n      transaction: \"any | undefined\",\n      burnNonce: \"string | number | undefined\",\n      contractCalls: \"any[] | undefined\",\n      asset: \"string\",\n      txHash: \"string | undefined\",\n      nonce: \"Buffer | string | undefined\",\n      tags: \"string[] | undefined\"\n    }, {\n      params: _this.params\n    });\n\n    if (_this.params.contractCalls) {\n      _this.params.contractCalls.map(function (contractCall) {\n        assertType(\"string\", {\n          sendTo: contractCall.sendTo,\n          contractFn: contractCall.contractFn\n        });\n      });\n    }\n  };\n  /** @hidden */\n\n\n  this._initialize =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var burnPayload, overwriteParams;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = _this._state.renNetwork;\n\n            if (_context.t0) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.t1 = getRenNetworkDetails;\n            _context.next = 5;\n            return _this.renVM.getNetwork(_this._state.selector);\n\n          case 5:\n            _context.t2 = _context.sent;\n            _context.t0 = (0, _context.t1)(_context.t2);\n\n          case 7:\n            _this._state.renNetwork = _context.t0;\n\n            if (!(_this.params.from && !_this.params.from.renNetwork)) {\n              _context.next = 11;\n              break;\n            }\n\n            _context.next = 11;\n            return _this.params.from.initialize(_this._state.renNetwork);\n\n          case 11:\n            if (_this.params.to.renNetwork) {\n              _context.next = 14;\n              break;\n            }\n\n            _context.next = 14;\n            return _this.params.to.initialize(_this._state.renNetwork);\n\n          case 14:\n            _context.t3 = _this.params.to.burnPayload;\n\n            if (!_context.t3) {\n              _context.next = 19;\n              break;\n            }\n\n            _context.next = 18;\n            return _this.params.to.burnPayload();\n\n          case 18:\n            _context.t3 = _context.sent;\n\n          case 19:\n            burnPayload = _context.t3;\n            _context.t4 = _this.params.from && _this.params.from.getBurnParams;\n\n            if (!_context.t4) {\n              _context.next = 25;\n              break;\n            }\n\n            _context.next = 24;\n            return _this.params.from.getBurnParams(_this.params.asset, burnPayload);\n\n          case 24:\n            _context.t4 = _context.sent;\n\n          case 25:\n            overwriteParams = _context.t4;\n            _this.params = _objectSpread({}, overwriteParams, _this.params);\n\n            if (!(_this.renVM.version(_this._state.selector) >= 2)) {\n              _context.next = 31;\n              break;\n            }\n\n            _context.next = 30;\n            return _this.renVM.selectPublicKey(_this._state.selector, _this.params.to.name);\n\n          case 30:\n            _this._state.gPubKey = _context.sent;\n\n          case 31:\n            return _context.abrupt(\"return\", _this);\n\n          case 32:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  /**\n   * TODO: Refresh the BurnAndRelease status by checking the status of the\n   * mint-chain transaction and the RenVM transaction.\n   *\n   * ```ts\n   * await burnAndRelease.refreshStatus();\n   * // > \"released\"\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n  this.refreshStatus =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", _this.status);\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  this.confirmationTarget =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4() {\n    var target, getConfirmationTarget;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!isDefined(_this._state.targetConfirmations)) {\n              _context4.next = 2;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", _this._state.targetConfirmations);\n\n          case 2:\n            getConfirmationTarget = _this.renVM.getConfirmationTarget;\n\n            if (!getConfirmationTarget) {\n              _context4.next = 7;\n              break;\n            }\n\n            _context4.next = 6;\n            return retryNTimes(\n            /*#__PURE__*/\n            _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee3() {\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      return _context3.abrupt(\"return\", getConfirmationTarget(_this._state.selector, _this.params.from));\n\n                    case 1:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3);\n            })), 2);\n\n          case 6:\n            target = _context4.sent;\n\n          case 7:\n            _this._state.targetConfirmations = isDefined(target) ? target : 6;\n            return _context4.abrupt(\"return\", _this._state.targetConfirmations);\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  /**\n   * Read a burn reference from an Ethereum transaction - or submit a\n   * transaction first if the transaction details have been provided.\n   */\n\n  this.burn = function () {\n    var promiEvent = newPromiEvent();\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5() {\n      var _this$params, asset, transaction, burnNonce, contractCalls, current, target, _ref6;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!_this.params.txHash) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\", _this);\n\n            case 2:\n              if (_this.params.from) {\n                _context5.next = 4;\n                break;\n              }\n\n              throw new Error(\"Must either provide field `to` or field `txHash`.\");\n\n            case 4:\n              _this$params = _this.params, asset = _this$params.asset, transaction = _this$params.transaction, burnNonce = _this$params.burnNonce, contractCalls = _this$params.contractCalls;\n              _context5.next = 7;\n              return _this.params.from.findBurnTransaction(asset, {\n                transaction: transaction,\n                burnNonce: burnNonce,\n                contractCalls: contractCalls\n              }, promiEvent, _this._state.logger, _this._state.config.networkDelay);\n\n            case 7:\n              _this.burnDetails = _context5.sent;\n              _this.status = BurnAndReleaseStatus.Burned;\n              current = 0, target = 1;\n\n            case 10:\n              if (!(current < target)) {\n                _context5.next = 30;\n                break;\n              }\n\n              _context5.prev = 11;\n              _context5.next = 14;\n              return _this.params.from.transactionConfidence(_this.burnDetails.transaction);\n\n            case 14:\n              _ref6 = _context5.sent;\n              current = _ref6.current;\n              target = _ref6.target;\n\n              if (_this._state.targetConfirmations && target < _this._state.targetConfirmations) {\n                target = _this._state.targetConfirmations;\n              } // Eth based chains only emits until 24 confs;\n              // keep emitting so that we can update the UI\n\n\n              promiEvent.emit(\"confirmation\", current, target); // Exit early so that we don't have to sleep if confs are met\n\n              if (!(current >= target)) {\n                _context5.next = 21;\n                break;\n              }\n\n              return _context5.abrupt(\"break\", 30);\n\n            case 21:\n              _context5.next = 26;\n              break;\n\n            case 23:\n              _context5.prev = 23;\n              _context5.t0 = _context5[\"catch\"](11);\n              console.error(_context5.t0);\n\n            case 26:\n              _context5.next = 28;\n              return sleep(10 * SECONDS);\n\n            case 28:\n              _context5.next = 10;\n              break;\n\n            case 30:\n              return _context5.abrupt(\"return\", _this);\n\n            case 31:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, null, [[11, 23]]);\n    }))().then(promiEvent.resolve).catch(promiEvent.reject);\n\n    return promiEvent;\n  };\n  /**\n   * `txHash` returns the RenVM transaction hash, which is distinct from the\n   * lock or mint chain transaction hashes. It can be used to query the\n   * burn-and-release details from RenVM once they've been submitted to it.\n   *\n   * The RenVM txHash is a URL-base64 string.\n   *\n   * ```ts\n   * burnAndRelease.txHash();\n   * // > \"QNM87rNDuxx54H7VK7D_NAU0u_mjk09-G25IJZL1QrI\"\n   * ```\n   */\n\n\n  this.txHash = function () {\n    var txHash = _this.params.txHash;\n\n    if (txHash) {\n      return renVMHashToBase64(txHash, _this.renVM.version(_this._state.selector) >= 2);\n    }\n\n    if (!_this.params.from) {\n      throw new Error(\"Must either provide field `to` or field `txHash`.\");\n    }\n\n    if (!_this.burnDetails) {\n      throw new Error(\"Must call `burn` before calling `txHash`.\");\n    }\n\n    if (_this.renVM.version(_this._state.selector) >= 2 && _this.renVM.burnTxHash) {\n      var _this$burnDetails = _this.burnDetails,\n          transaction = _this$burnDetails.transaction,\n          amount = _this$burnDetails.amount,\n          to = _this$burnDetails.to,\n          nonce = _this$burnDetails.nonce;\n      var payload = Buffer.from([]);\n      var pHash = generatePHash([], _this._state.logger);\n\n      var _this$params$from$tra = _this.params.from.transactionRPCFormat(transaction, true),\n          txid = _this$params$from$tra.txid,\n          txindex = _this$params$from$tra.txindex;\n\n      var nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, \"be\", 32);\n      var nHash = generateNHash(nonceBuffer, txid, txindex, _this.renVM.version(_this._state.selector) >= 2, _this._state.logger);\n      var sHash = generateSHash(\"\".concat(_this.params.asset, \"/to\").concat(_this.params.to.name));\n      var gHash = generateGHash([], Ox(_this.params.to.addressStringToBytes(to)), Ox(sHash), nonceBuffer, _this.renVM.version(_this._state.selector) >= 2, _this._state.logger);\n      var gPubKey = _this._state.gPubKey;\n\n      if (!gPubKey) {\n        throw new Error(\"BurnAndRelease object must be initialized.\");\n      }\n\n      return toURLBase64(_this.renVM.burnTxHash({\n        selector: _this._state.selector,\n        gHash: gHash,\n        gPubKey: gPubKey,\n        nHash: nHash,\n        nonce: nonceBuffer,\n        output: {\n          txid: txid,\n          txindex: txindex\n        },\n        amount: amount.toFixed(),\n        payload: payload,\n        pHash: pHash,\n        to: to.toString()\n      }));\n    } else {\n      return toBase64(generateBurnTxHash(_this._state.selector, _this.burnDetails.nonce.toFixed(), _this._state.logger));\n    }\n  };\n  /**\n   * queryTx requests the status of the burn from RenVM.\n   */\n\n\n  this.queryTx =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6() {\n    var burnTransaction;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return _this.renVM.queryMintOrBurn(_this._state.selector, fromBase64(_this.txHash()));\n\n          case 2:\n            burnTransaction = _context6.sent;\n            _this._state.queryTxResult = burnTransaction;\n            return _context6.abrupt(\"return\", burnTransaction);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  /**\n   * submit queries RenVM for the status of the burn until the funds are\n   * released.\n   */\n\n  this.release = function () {\n    var promiEvent = newPromiEvent();\n\n    _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7() {\n      var txHash, tags, _this$burnDetails2, transaction, amount, to, nonce, returnedTxHash, gPubKey, payload, pHash, _this$params$from$tra2, txid, txindex, nonceBuffer, nHash, sHash, gHash, response, _transaction, _txid, _response$out$outpoin, hash, index;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(!_this.burnDetails && !_this.params.txHash)) {\n                _context7.next = 2;\n                break;\n              }\n\n              throw new Error(\"Must call `burn` before calling `release`.\");\n\n            case 2:\n              txHash = _this.txHash();\n\n              if (!(!_this.params.txHash && _this.burnDetails)) {\n                _context7.next = 41;\n                break;\n              }\n\n              if (_this.params.from) {\n                _context7.next = 6;\n                break;\n              }\n\n              throw new Error(\"Must either provide field `to` or field `txHash`.\");\n\n            case 6:\n              if (!(_this.params.tags && _this.params.tags.length > 1)) {\n                _context7.next = 8;\n                break;\n              }\n\n              throw new Error(\"Providing multiple tags is not supported yet.\");\n\n            case 8:\n              tags = _this.params.tags && _this.params.tags.length ? [_this.params.tags[0]] : [];\n              _this$burnDetails2 = _this.burnDetails, transaction = _this$burnDetails2.transaction, amount = _this$burnDetails2.amount, to = _this$burnDetails2.to, nonce = _this$burnDetails2.nonce;\n              _context7.prev = 10;\n\n              if (!(_this.renVM.version(_this._state.selector) >= 2)) {\n                _context7.next = 30;\n                break;\n              }\n\n              assertType(\"string\", {\n                to: to\n              });\n              gPubKey = _this._state.gPubKey;\n\n              if (gPubKey) {\n                _context7.next = 16;\n                break;\n              }\n\n              throw new Error(\"BurnAndRelease object must be initialized.\");\n\n            case 16:\n              payload = Buffer.from([]);\n              pHash = generatePHash([], _this._state.logger);\n              _this$params$from$tra2 = _this.params.from.transactionRPCFormat(transaction, true), txid = _this$params$from$tra2.txid, txindex = _this$params$from$tra2.txindex;\n              nonceBuffer = new BN(nonce.toFixed()).toArrayLike(Buffer, \"be\", 32);\n              nHash = generateNHash(nonceBuffer, txid, txindex, _this.renVM.version(_this._state.selector) >= 2, _this._state.logger);\n              sHash = generateSHash(\"\".concat(_this.params.asset, \"/to\").concat(_this.params.to.name));\n              gHash = generateGHash([], Ox(_this.params.to.addressStringToBytes(to)), Ox(sHash), nonceBuffer, _this.renVM.version(_this._state.selector) >= 2, _this._state.logger);\n              _context7.t0 = toURLBase64;\n              _context7.next = 26;\n              return _this.renVM.submitBurn({\n                selector: _this._state.selector,\n                tags: tags,\n                gHash: gHash,\n                gPubKey: gPubKey,\n                nHash: nHash,\n                nonce: nonceBuffer,\n                output: {\n                  txid: txid,\n                  txindex: txindex\n                },\n                amount: amount.toFixed(),\n                payload: payload,\n                pHash: pHash,\n                to: to.toString(),\n                // from v1\n                burnNonce: new BigNumber(0)\n              });\n\n            case 26:\n              _context7.t1 = _context7.sent;\n              returnedTxHash = (0, _context7.t0)(_context7.t1);\n              _context7.next = 35;\n              break;\n\n            case 30:\n              _context7.t2 = toBase64;\n              _context7.next = 33;\n              return _this.renVM.submitBurn({\n                selector: _this._state.selector,\n                tags: tags,\n                burnNonce: nonce,\n                // for v2\n                gHash: Buffer.from([]),\n                gPubKey: Buffer.from([]),\n                nHash: Buffer.from([]),\n                nonce: Buffer.from([]),\n                output: {\n                  txid: Buffer.from([]),\n                  txindex: \"\"\n                },\n                amount: \"\",\n                payload: Buffer.from([]),\n                pHash: Buffer.from([]),\n                to: \"\"\n              });\n\n            case 33:\n              _context7.t3 = _context7.sent;\n              returnedTxHash = (0, _context7.t2)(_context7.t3);\n\n            case 35:\n              if (txHash && txHash !== returnedTxHash) {\n                _this._state.logger.warn(\"Unexpected txHash returned from RenVM. Received: \".concat(returnedTxHash, \", expected: \").concat(txHash));\n              }\n\n              _context7.next = 41;\n              break;\n\n            case 38:\n              _context7.prev = 38;\n              _context7.t4 = _context7[\"catch\"](10);\n              throw _context7.t4;\n\n            case 41:\n              // const txHash = await this.renVMNetwork.submitTokenFromEthereum(this.params.sendToken, burnNonce);\n              promiEvent.emit(\"txHash\", txHash);\n\n              _this._state.logger.debug(\"txHash:\", txHash);\n\n              _context7.next = 45;\n              return _this.renVM.waitForTX(_this._state.selector, fromBase64(txHash), function (status) {\n                promiEvent.emit(\"status\", status);\n\n                _this._state.logger.debug(\"transaction status:\", status);\n              }, function () {\n                return promiEvent._isCancelled();\n              }, _this._state.config.networkDelay);\n\n            case 45:\n              response = _context7.sent;\n\n              if (!(response.out && response.out.revert !== undefined)) {\n                _context7.next = 52;\n                break;\n              }\n\n              _this.status = BurnAndReleaseStatus.Reverted;\n              _this.revertReason = response.out.revert.toString();\n              throw new Error(_this.revertReason);\n\n            case 52:\n              _this.status = BurnAndReleaseStatus.Released;\n\n              if (!(response.out && _this.renVM.version(_this._state.selector) >= 2)) {\n                _context7.next = 73;\n                break;\n              }\n\n              _context7.prev = 54;\n\n              if (!response.out.txid) {\n                _context7.next = 62;\n                break;\n              }\n\n              _txid = response.out.txid;\n              _context7.next = 59;\n              return _this.params.to.transactionFromID(_txid, \"\", true);\n\n            case 59:\n              _transaction = _context7.sent;\n              _context7.next = 67;\n              break;\n\n            case 62:\n              if (!response.out.outpoint) {\n                _context7.next = 67;\n                break;\n              }\n\n              _response$out$outpoin = response.out.outpoint, hash = _response$out$outpoin.hash, index = _response$out$outpoin.index;\n              _context7.next = 66;\n              return _this.params.to.transactionFromID(hash, index.toFixed(), true);\n\n            case 66:\n              _transaction = _context7.sent;\n\n            case 67:\n              _context7.next = 72;\n              break;\n\n            case 69:\n              _context7.prev = 69;\n              _context7.t5 = _context7[\"catch\"](54);\n\n              _this._state.logger.debug(_context7.t5);\n\n            case 72:\n              if (_transaction) {\n                _this.releaseTransaction = _transaction;\n                promiEvent.emit(\"transaction\", _transaction);\n              }\n\n            case 73:\n              return _context7.abrupt(\"return\", response);\n\n            case 74:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[10, 38], [54, 69]]);\n    }))().then(promiEvent.resolve).catch(promiEvent.reject);\n\n    return promiEvent;\n  };\n\n  this.params = params;\n  this.renVM = renVM;\n  this._state = {\n    logger: config.logger || NullLogger,\n    selector: this.renVM.selector(this.params),\n    targetConfirmations: undefined,\n    config: _objectSpread({}, config, {\n      networkDelay: config.networkDelay || 15 * SECONDS\n    })\n  };\n  this.validateParams();\n  this.status = this.params.txHash ? BurnAndReleaseStatus.Burned : BurnAndReleaseStatus.Pending;\n  {\n    // Debug log\n    var restOfParams = _extends({}, this.params);\n\n    this._state.logger.debug(\"burnAndRelease created:\", restOfParams);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}