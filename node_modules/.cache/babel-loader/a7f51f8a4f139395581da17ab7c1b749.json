{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { getRenNetworkDetails, NullLogger, TxStatus } from \"@renproject/interfaces\";\nimport { HttpProvider } from \"@renproject/provider\";\nimport { assertType, fromBase64, isDefined, SECONDS, sleep, toURLBase64 } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { RPCMethod } from \"./methods\";\nimport { hashTransaction, mintParamsType } from \"./transaction\";\nimport { unmarshalBurnTx, unmarshalMintTx } from \"./unmarshal\";\nexport var resolveV2Contract = function resolveV2Contract(_ref) {\n  var asset = _ref.asset,\n      from = _ref.from,\n      to = _ref.to;\n\n  if (from.assetIsNative && from.assetIsNative(asset)) {\n    return \"\".concat(asset, \"/to\").concat(to.name);\n  }\n\n  if (to.assetIsNative && to.assetIsNative(asset)) {\n    return \"\".concat(asset, \"/from\").concat(from.name);\n  }\n\n  return \"\".concat(asset, \"/from\").concat(from.name, \"To\").concat(to.name);\n};\nexport var RenVMProvider = function RenVMProvider(network, provider) {\n  var _this = this;\n\n  var logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NullLogger;\n\n  _classCallCheck(this, RenVMProvider);\n\n  this.version = function () {\n    return 2;\n  };\n\n  this.selector = function (params) {\n    return resolveV2Contract(params);\n  };\n\n  this.queryBlock =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(blockHeight, retry) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", _this.sendMessage(RPCMethod.QueryBlock, {\n                blockHeight: blockHeight\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  this.queryBlocks =\n  /*#__PURE__*/\n  function () {\n    var _ref3 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(blockHeight, n, retry) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", _this.sendMessage(RPCMethod.QueryBlocks, {\n                blockHeight: blockHeight,\n                n: n\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x3, _x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  this.submitTx =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(tx, retry) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", _this.sendMessage(RPCMethod.SubmitTx, {\n                tx: tx\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x6, _x7) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  this.queryTx =\n  /*#__PURE__*/\n  function () {\n    var _ref5 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(txHash, retry) {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", _this.sendMessage(RPCMethod.QueryTx, {\n                txHash: txHash\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x8, _x9) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  this.queryTxs =\n  /*#__PURE__*/\n  function () {\n    var _ref6 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5(tags, page, pageSize, txStatus, retry) {\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", _this.sendMessage(RPCMethod.QueryTxs, {\n                tags: tags,\n                page: (page || 0).toString(),\n                pageSize: (pageSize || 0).toString(),\n                txStatus: txStatus\n              }, retry));\n\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x10, _x11, _x12, _x13, _x14) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n\n  this.queryConfig =\n  /*#__PURE__*/\n  function () {\n    var _ref7 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee6(retry) {\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", _this.sendMessage(RPCMethod.QueryConfig, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x15) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n\n  this.queryState =\n  /*#__PURE__*/\n  function () {\n    var _ref8 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7(retry) {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              return _context7.abrupt(\"return\", _this.sendMessage(RPCMethod.QueryState, {}, retry));\n\n            case 1:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function (_x16) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n\n  this.buildTransaction = function (_ref9) {\n    var selector = _ref9.selector,\n        gHash = _ref9.gHash,\n        gPubKey = _ref9.gPubKey,\n        nHash = _ref9.nHash,\n        nonce = _ref9.nonce,\n        output = _ref9.output,\n        amount = _ref9.amount,\n        payload = _ref9.payload,\n        pHash = _ref9.pHash,\n        to = _ref9.to;\n    assertType(\"Buffer\", {\n      gHash: gHash,\n      gPubKey: gPubKey,\n      nHash: nHash,\n      nonce: nonce,\n      payload: payload,\n      pHash: pHash,\n      txid: output.txid\n    });\n    assertType(\"string\", {\n      to: to,\n      amount: amount,\n      txindex: output.txindex\n    });\n    var version = \"1\";\n    var txIn = {\n      t: mintParamsType(),\n      v: {\n        txid: toURLBase64(output.txid),\n        txindex: output.txindex,\n        ghash: toURLBase64(gHash),\n        gpubkey: toURLBase64(gPubKey),\n        nhash: toURLBase64(nHash),\n        nonce: toURLBase64(nonce),\n        payload: toURLBase64(payload),\n        phash: toURLBase64(pHash),\n        to: to,\n        amount: amount\n      }\n    };\n    return {\n      hash: toURLBase64(hashTransaction(version, selector, txIn)),\n      selector: selector,\n      version: version,\n      // TODO: Fix types\n      in: txIn\n    };\n  };\n\n  this.mintTxHash = function (params) {\n    return fromBase64(_this.buildTransaction(params).hash);\n  };\n\n  this.submitMint =\n  /*#__PURE__*/\n  function () {\n    var _ref10 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8(params) {\n      var tx;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              tx = _this.buildTransaction(params);\n              _context8.next = 3;\n              return _this.submitTx(tx);\n\n            case 3:\n              return _context8.abrupt(\"return\", fromBase64(tx.hash));\n\n            case 4:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    return function (_x17) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n\n  this.burnTxHash = this.mintTxHash;\n  this.submitBurn = this.submitMint;\n  /**\n   * Queries the result of a RenVM transaction and unmarshals the result into\n   * a [[LockAndMintTransaction]] or [[BurnAndReleaseTransaction]].\n   *\n   * @param renVMTxHash The transaction hash as a Buffer.\n   */\n\n  this.queryMintOrBurn =\n  /*#__PURE__*/\n  function () {\n    var _ref11 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee9(_selector, renVMTxHash) {\n      var response, isMint;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.prev = 0;\n              _context9.next = 3;\n              return _this.queryTx(toURLBase64(renVMTxHash));\n\n            case 3:\n              response = _context9.sent;\n              // Unmarshal transaction.\n              // TODO: Improve mint/burn detection. Currently checks if the format\n              // is `ASSET/toChain` or `ASSET/fromChainToChain`. It may return\n              // a false positive if the chain name contains `To`.\n              isMint = /((\\/to)|(To))/.exec(response.tx.selector);\n\n              if (!isMint) {\n                _context9.next = 9;\n                break;\n              }\n\n              return _context9.abrupt(\"return\", unmarshalMintTx(response));\n\n            case 9:\n              return _context9.abrupt(\"return\", unmarshalBurnTx(response));\n\n            case 10:\n              _context9.next = 15;\n              break;\n\n            case 12:\n              _context9.prev = 12;\n              _context9.t0 = _context9[\"catch\"](0);\n              throw _context9.t0;\n\n            case 15:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9, null, [[0, 12]]);\n    }));\n\n    return function (_x18, _x19) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  /**\n   * Fetches the result of a RenVM transaction on a repeated basis until the\n   * transaction's status is `\"done\"`.\n   *\n   * @param utxoTxHash The transaction hash as a Buffer.\n   * @param onStatus A callback called each time the status of the transaction\n   * is refreshed - even if it hasn't changed.\n   * @param _cancelRequested A function that returns `true` to cancel the\n   * loop.\n   */\n\n\n  this.waitForTX =\n  /*#__PURE__*/\n  function () {\n    var _ref12 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee10(selector, utxoTxHash, onStatus, _cancelRequested, timeout) {\n      var rawResponse, result;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              assertType(\"Buffer\", {\n                utxoTxHash: utxoTxHash\n              });\n\n            case 1:\n              if (!true) {\n                _context10.next = 23;\n                break;\n              }\n\n              if (!(_cancelRequested && _cancelRequested())) {\n                _context10.next = 4;\n                break;\n              }\n\n              throw new Error(\"waitForTX cancelled.\");\n\n            case 4:\n              _context10.prev = 4;\n              _context10.next = 7;\n              return _this.queryMintOrBurn(selector, utxoTxHash);\n\n            case 7:\n              result = _context10.sent;\n\n              if (!(result && result.txStatus === TxStatus.TxStatusDone)) {\n                _context10.next = 13;\n                break;\n              }\n\n              rawResponse = result;\n              return _context10.abrupt(\"break\", 23);\n\n            case 13:\n              if (onStatus && result && result.txStatus) {\n                onStatus(result.txStatus);\n              }\n\n            case 14:\n              _context10.next = 19;\n              break;\n\n            case 16:\n              _context10.prev = 16;\n              _context10.t0 = _context10[\"catch\"](4);\n\n              if (/(not found)|(not available)/.exec(String((_context10.t0 || {}).message))) {// ignore\n              } else {\n                _this.logger.error(String(_context10.t0)); // TODO: throw unexpected errors\n\n              }\n\n            case 19:\n              _context10.next = 21;\n              return sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n\n            case 21:\n              _context10.next = 1;\n              break;\n\n            case 23:\n              return _context10.abrupt(\"return\", rawResponse);\n\n            case 24:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10, null, [[4, 16]]);\n    }));\n\n    return function (_x20, _x21, _x22, _x23, _x24) {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n  /**\n   * selectPublicKey fetches the public key for the RenVM shard handling\n   * the provided contract.\n   *\n   * @param chain The chain for which the public key should be fetched.\n   * @returns The public key hash (20 bytes) as a string.\n   */\n\n\n  this.selectPublicKey =\n  /*#__PURE__*/\n  function () {\n    var _ref13 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee11(_selector, chain) {\n      var response;\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return _this.queryState(5);\n\n            case 2:\n              response = _context11.sent;\n              return _context11.abrupt(\"return\", fromBase64(response.state[chain].pubKey));\n\n            case 4:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, _callee11);\n    }));\n\n    return function (_x25, _x26) {\n      return _ref13.apply(this, arguments);\n    };\n  }(); // In the future, this will be asynchronous. It returns a promise for\n  // compatibility.\n  // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  this.getNetwork =\n  /*#__PURE__*/\n  function () {\n    var _ref14 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee12(_selector) {\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              return _context12.abrupt(\"return\", _this.network);\n\n            case 1:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, _callee12);\n    }));\n\n    return function (_x27) {\n      return _ref14.apply(this, arguments);\n    };\n  }();\n\n  this.getConfirmationTarget =\n  /*#__PURE__*/\n  function () {\n    var _ref15 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee13(_selector, chain) {\n      var renVMConfig;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return _this.sendMessage(RPCMethod.QueryConfig, {});\n\n            case 2:\n              renVMConfig = _context13.sent;\n              return _context13.abrupt(\"return\", parseInt(renVMConfig.confirmations[chain.name], 10));\n\n            case 4:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee13);\n    }));\n\n    return function (_x28, _x29) {\n      return _ref15.apply(this, arguments);\n    };\n  }();\n\n  this.estimateTransactionFee =\n  /*#__PURE__*/\n  function () {\n    var _ref16 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee14(_selector, chain) {\n      var renVMState, _renVMState$state$cha, gasLimit, gasCap, fee;\n\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return _this.sendMessage(RPCMethod.QueryState, {});\n\n            case 2:\n              renVMState = _context14.sent;\n\n              if (renVMState.state[chain.name]) {\n                _context14.next = 5;\n                break;\n              }\n\n              throw new Error(\"No fee details found for \".concat(chain.name));\n\n            case 5:\n              _renVMState$state$cha = renVMState.state[chain.name], gasLimit = _renVMState$state$cha.gasLimit, gasCap = _renVMState$state$cha.gasCap;\n              fee = new BigNumber(gasLimit).times(new BigNumber(gasCap));\n              return _context14.abrupt(\"return\", {\n                lock: fee,\n                release: fee\n              });\n\n            case 8:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, _callee14);\n    }));\n\n    return function (_x30, _x31) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n\n  if (!provider || typeof provider === \"string\") {\n    var rpcUrl = provider || (getRenNetworkDetails(network) || {}).lightnode;\n\n    try {\n      provider = new HttpProvider(rpcUrl, logger);\n    } catch (error) {\n      if (/Invalid node URL/.exec(String(error && error.message))) {\n        throw new Error(\"Invalid network or provider URL: \\\"\".concat((getRenNetworkDetails(network) || {}).name || String(network), \"\\\"\"));\n      }\n\n      throw error;\n    }\n  }\n\n  this.network = network;\n  this.logger = logger;\n  this.provider = provider;\n  this.sendMessage = this.provider.sendMessage;\n};","map":null,"metadata":{},"sourceType":"module"}