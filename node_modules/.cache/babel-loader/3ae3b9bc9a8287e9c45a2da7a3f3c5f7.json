{"ast":null,"code":"'use strict';\n\nvar BN = require('./crypto/bn');\n\nvar Point = require('./crypto/point');\n\nvar Hash = require('./crypto/hash');\n\nvar JSUtil = require('./util/js');\n\nvar Network = require('./networks');\n\nvar _ = require('lodash');\n\nvar $ = require('./util/preconditions');\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\n\n\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra); // validation\n\n\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n  return this;\n}\n\n;\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\n\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  }; // detect type of data\n\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(Buffer.from(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n\n  return info;\n};\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isPrivateKey = function (param) {\n  var PrivateKey = require('./privatekey');\n\n  return param instanceof PrivateKey;\n};\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\n\n\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformDER = function (buf, strict) {\n  /* jshint maxstatements: 30 */\n\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n\n  return info;\n};\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformX = function (odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\n\n\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n\n  var info = PublicKey._transformPrivateKey(privkey);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromDER = PublicKey.fromBuffer = function (buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n\n  var info = PublicKey._transformDER(buf, strict);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromPoint = function (point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromString = function (str, encoding) {\n  var buf = Buffer.from(str, encoding || 'hex');\n\n  var info = PublicKey._transformDER(buf);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\n\n\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\n\n\nPublicKey.getValidationError = function (data) {\n  var error;\n\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n\n  return error;\n};\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\n\n\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n/**\n * @returns {Object} A plain object of the PublicKey\n */\n\n\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\n\n\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n\n  if (!this.compressed) {\n    prefix = Buffer.from([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n\n    if (odd) {\n      prefix = Buffer.from([0x03]);\n    } else {\n      prefix = Buffer.from([0x02]);\n    }\n\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\n\n\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @param {string} type - Either 'pubkeyhash', 'witnesspubkeyhash', or 'scripthash'\n * @returns {Address} An address generated from the public key\n */\n\n\nPublicKey.prototype.toAddress = function (network, type) {\n  var Address = require('./address');\n\n  return Address.fromPublicKey(this, network || this.network, type);\n};\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\n\n\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\n\n\nPublicKey.prototype.inspect = function () {\n  return '<PublicKey: ' + this.toString() + (this.compressed ? '' : ', uncompressed') + '>';\n};\n\nmodule.exports = PublicKey;","map":null,"metadata":{},"sourceType":"script"}