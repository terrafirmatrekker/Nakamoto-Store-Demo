{"ast":null,"code":"import _objectSpread from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _toConsumableArray from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { NullLogger } from \"@renproject/interfaces\";\nimport { assert, assertType, extractError, fromHex, isDefined, Ox, payloadToABI, payloadToMintABI, SECONDS, sleep } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport BN from \"bn.js\";\nimport BlocknativeSdk from \"bnc-sdk\";\nimport { isValidAddress, isValidChecksumAddress } from \"ethereumjs-util\";\nimport { keccak256 as web3Keccak256 } from \"web3-utils\";\nexport var ignorePromiEventError = function ignorePromiEventError(error) {\n  try {\n    return !!(error && error.message && (/Invalid block number/.exec(error.message) || /Timeout exceeded during the transaction confirmation process./.exec(error.message)));\n  } catch (innerError) {\n    return false;\n  }\n};\n/**\n * Forward the events emitted by a Web3 PromiEvent to another PromiEvent.\n */\n\nexport var forwardWeb3Events = function forwardWeb3Events(src, dest) {\n  // eslint-disable-next-line no-void\n  void src.on(\"transactionHash\", function (eventReceipt) {\n    dest.emit(\"transactionHash\", eventReceipt);\n    dest.emit(\"eth_transactionHash\", eventReceipt);\n  }); // eslint-disable-next-line no-void\n\n  void src.on(\"receipt\", function (eventReceipt) {\n    dest.emit(\"receipt\", eventReceipt);\n    dest.emit(\"eth_receipt\", eventReceipt);\n  }); // eslint-disable-next-line no-void\n\n  void src.on(\"confirmation\", function (confNumber, eventReceipt) {\n    dest.emit(\"confirmation\", confNumber, eventReceipt);\n    dest.emit(\"eth_confirmation\", confNumber, eventReceipt);\n  }); // Don't forward - instead these should be listened for and thrown.\n  // // eslint-disable-next-line no-void\n  // void src.on(\"error\", (error: Error) => {\n  //     dest.emit(\"error\", error);\n  // });\n};\n/**\n * eventTopics contains the Ethereum event identifiers (the first log topic) for\n * Gateway contract events.\n */\n\nexport var eventTopics = {\n  /**\n   * ```js\n   * event LogBurn(\n   *     bytes _to,\n   *     uint256 _amount,\n   *     uint256 indexed _n,\n   *     bytes indexed _indexedTo\n   *  );\n   * ```\n   */\n  LogBurn: web3Keccak256(\"LogBurn(bytes,uint256,uint256,bytes)\"),\n\n  /**\n   * ```js\n   * event LogMint(\n   *     address indexed _to,\n   *     uint256 _amount,\n   *     uint256 indexed _n,\n   *     bytes32 indexed _signedMessageHash\n   * );\n   * ```\n   */\n  LogMint: web3Keccak256(\"LogMint(address,uint256,uint256,bytes32)\")\n};\n/**\n * Waits for the receipt of a transaction to be available, retrying every 3\n * seconds until it is.\n *\n * @param web3 A web3 instance.\n * @param txHash The hash of the transaction being read.\n */\n\nexport var waitForReceipt =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(web3, txHash, logger, timeout) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            new Promise(\n            /*#__PURE__*/\n            function () {\n              var _ref2 = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee(resolve, reject) {\n                var blocknative, _blocknative$transact, emitter, receipt;\n\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        assertType(\"string\", {\n                          txHash: txHash\n                        });\n                        _context.prev = 1;\n                        _context.t0 = BlocknativeSdk;\n                        _context.next = 5;\n                        return web3.eth.net.getId();\n\n                      case 5:\n                        _context.t1 = _context.sent;\n                        _context.t2 = {\n                          dappId: \"6b3d07f1-b158-4cf1-99ec-919b11fe3654\",\n                          networkId: _context.t1\n                        };\n                        blocknative = new _context.t0(_context.t2);\n                        _blocknative$transact = blocknative.transaction(txHash), emitter = _blocknative$transact.emitter;\n                        emitter.on(\"txSpeedUp\", function (state) {\n                          if (state.hash) {\n                            txHash = Ox(state.hash);\n                          }\n                        });\n                        emitter.on(\"txCancel\", function () {\n                          reject(new Error(\"Ethereum transaction was cancelled.\"));\n                        });\n                        _context.next = 15;\n                        break;\n\n                      case 13:\n                        _context.prev = 13;\n                        _context.t3 = _context[\"catch\"](1);\n\n                      case 15:\n                        if (!(!receipt || !receipt.blockHash)) {\n                          _context.next = 26;\n                          break;\n                        }\n\n                        if (logger) {\n                          logger.debug(\"Fetching transaction receipt: \".concat(txHash));\n                        }\n\n                        _context.next = 19;\n                        return web3.eth.getTransactionReceipt(txHash);\n\n                      case 19:\n                        receipt = _context.sent;\n\n                        if (!(receipt && receipt.blockHash)) {\n                          _context.next = 22;\n                          break;\n                        }\n\n                        return _context.abrupt(\"break\", 26);\n\n                      case 22:\n                        _context.next = 24;\n                        return sleep(isDefined(timeout) ? timeout : 15 * SECONDS);\n\n                      case 24:\n                        _context.next = 15;\n                        break;\n\n                      case 26:\n                        try {\n                          // Destroy blocknative SDK.\n                          if (blocknative) {\n                            blocknative.unsubscribe(txHash);\n                            blocknative.destroy();\n                          }\n                        } catch (error) {} // Ignore blocknative error.\n                        // Status might be undefined - so check against `false` explicitly.\n\n\n                        if (!(receipt.status === false)) {\n                          _context.next = 30;\n                          break;\n                        }\n\n                        reject(new Error(\"Transaction was reverted. { \\\"transactionHash\\\": \\\"\".concat(txHash, \"\\\" }\")));\n                        return _context.abrupt(\"return\");\n\n                      case 30:\n                        resolve(receipt);\n                        return _context.abrupt(\"return\");\n\n                      case 32:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 13]]);\n              }));\n\n              return function (_x5, _x6) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function waitForReceipt(_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var parseBurnEvent = function parseBurnEvent(web3, event) {\n  assert(event.topics[0] === eventTopics.LogBurn);\n\n  var _web3$eth$abi$decodeL = web3.eth.abi.decodeLog([{\n    indexed: false,\n    name: \"_to\",\n    type: \"bytes\"\n  }, {\n    indexed: false,\n    name: \"_amount\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    name: \"_n\",\n    type: \"uint256\"\n  }, {\n    indexed: true,\n    name: \"_indexedTo\",\n    type: \"bytes\"\n  }], event.data, event.topics.slice(1)),\n      _to = _web3$eth$abi$decodeL._to,\n      _amount = _web3$eth$abi$decodeL._amount,\n      _n = _web3$eth$abi$decodeL._n;\n\n  return {\n    transaction: event.transactionHash,\n    amount: new BigNumber(_amount.toString()),\n    to: fromHex(_to).toString(),\n    nonce: new BigNumber(_n.toString())\n  };\n};\nexport var extractBurnDetails =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(web3, txHash, logger, timeout) {\n    var receipt, burnDetails;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            assertType(\"string\", {\n              txHash: txHash\n            });\n            _context3.next = 3;\n            return waitForReceipt(web3, txHash, logger, timeout);\n\n          case 3:\n            receipt = _context3.sent;\n\n            if (receipt.logs) {\n              _context3.next = 6;\n              break;\n            }\n\n            throw Error(\"No events found in transaction\");\n\n          case 6:\n            burnDetails = receipt.logs.filter(function (event) {\n              return event.topics[0] === eventTopics.LogBurn;\n            }).map(function (event) {\n              return parseBurnEvent(web3, event);\n            });\n\n            if (burnDetails.length > 1) {// WARNING: More than one burn found.\n            }\n\n            if (!burnDetails.length) {\n              _context3.next = 10;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", burnDetails[0]);\n\n          case 10:\n            throw Error(\"No reference ID found in logs\");\n\n          case 11:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function extractBurnDetails(_x7, _x8, _x9, _x10) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var getGatewayAddress =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(network, web3, asset) {\n    var getGatewayBySymbol, registry, registryAddress;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            getGatewayBySymbol = {\n              constant: true,\n              inputs: [{\n                internalType: \"string\",\n                name: \"_tokenSymbol\",\n                type: \"string\"\n              }],\n              name: \"getGatewayBySymbol\",\n              outputs: [{\n                internalType: \"contract IGateway\",\n                name: \"\",\n                type: \"address\"\n              }],\n              payable: false,\n              stateMutability: \"view\",\n              type: \"function\"\n            };\n            registry = new web3.eth.Contract([getGatewayBySymbol], network.addresses.GatewayRegistry);\n            _context4.next = 5;\n            return registry.methods.getGatewayBySymbol(asset).call();\n\n          case 5:\n            registryAddress = _context4.sent;\n\n            if (registryAddress) {\n              _context4.next = 8;\n              break;\n            }\n\n            throw new Error(\"Empty address returned.\");\n\n          case 8:\n            return _context4.abrupt(\"return\", registryAddress);\n\n          case 11:\n            _context4.prev = 11;\n            _context4.t0 = _context4[\"catch\"](0);\n            (_context4.t0 || {}).message = \"Error looking up \".concat(asset, \" gateway address\").concat(_context4.t0.message ? \": \".concat(String(_context4.t0.message)) : \".\");\n            throw _context4.t0;\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 11]]);\n  }));\n\n  return function getGatewayAddress(_x11, _x12, _x13) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nexport var findBurnByNonce =\n/*#__PURE__*/\nfunction () {\n  var _ref5 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5(network, web3, asset, nonce) {\n    var gatewayAddress, nonceBuffer, burnEvents;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return getGatewayAddress(network, web3, asset);\n\n          case 2:\n            gatewayAddress = _context5.sent;\n            nonceBuffer = Buffer.isBuffer(nonce) ? nonce : new BN(nonce).toArrayLike(Buffer, \"be\", 32);\n            _context5.next = 6;\n            return web3.eth.getPastLogs({\n              address: gatewayAddress,\n              fromBlock: \"1\",\n              toBlock: \"latest\",\n              topics: [eventTopics.LogBurn, Ox(nonceBuffer)]\n            });\n\n          case 6:\n            burnEvents = _context5.sent;\n\n            if (burnEvents.length) {\n              _context5.next = 9;\n              break;\n            }\n\n            throw Error(\"Burn not found for nonce \".concat(Ox(nonceBuffer)));\n\n          case 9:\n            if (burnEvents.length > 1) {// WARNING: More than one burn with the same nonce.\n            }\n\n            return _context5.abrupt(\"return\", parseBurnEvent(web3, burnEvents[0]));\n\n          case 11:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function findBurnByNonce(_x14, _x15, _x16, _x17) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nexport var defaultAccountError = \"No accounts found in Web3 wallet.\";\nexport var withDefaultAccount =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6(web3, config) {\n    var accounts;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (config.from) {\n              _context6.next = 11;\n              break;\n            }\n\n            if (!web3.eth.defaultAccount) {\n              _context6.next = 5;\n              break;\n            }\n\n            config.from = web3.eth.defaultAccount;\n            _context6.next = 11;\n            break;\n\n          case 5:\n            _context6.next = 7;\n            return web3.eth.getAccounts();\n\n          case 7:\n            accounts = _context6.sent;\n\n            if (!(accounts.length === 0)) {\n              _context6.next = 10;\n              break;\n            }\n\n            throw new Error(defaultAccountError);\n\n          case 10:\n            config.from = accounts[0];\n\n          case 11:\n            return _context6.abrupt(\"return\", config);\n\n          case 12:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function withDefaultAccount(_x18, _x19) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n/**\n * Bind a promiEvent to an Ethereum transaction hash, sending confirmation\n * events. Web3 may export a similar function, which should be used instead if\n * it exists.\n *\n * @param web3 A Web3 instance for watching for confirmations.\n * @param txHash The Ethereum transaction has as a hex string.\n * @param promiEvent The existing promiEvent to forward events to.\n */\n\nexport var manualPromiEvent =\n/*#__PURE__*/\nfunction () {\n  var _ref7 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee8(web3, txHash, promiEvent) {\n    var receipt, emitConfirmation;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            assertType(\"string\", {\n              txHash: txHash\n            });\n            _context8.next = 3;\n            return web3.eth.getTransactionReceipt(txHash);\n\n          case 3:\n            receipt = _context8.sent;\n            promiEvent.emit(\"transactionHash\", txHash);\n\n            emitConfirmation =\n            /*#__PURE__*/\n            function () {\n              var _ref8 = _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee7() {\n                var currentBlock;\n                return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        _context7.next = 2;\n                        return web3.eth.getBlockNumber();\n\n                      case 2:\n                        currentBlock = _context7.sent;\n                        promiEvent.emit(\"confirmation\", Math.max(0, currentBlock - receipt.blockNumber), // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        receipt);\n\n                      case 4:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _callee7);\n              }));\n\n              return function emitConfirmation() {\n                return _ref8.apply(this, arguments);\n              };\n            }(); // The following section should be revised to properly\n            // register the event emitter to the transaction's\n            // confirmations, so that on(\"confirmation\") works\n            // as expected. This code branch only occurs if a\n            // completed transfer is passed to RenJS again, which\n            // should not usually happen.\n            // Emit confirmation now and in 1s, since a common use\n            // case may be to have the following code, which doesn't\n            // work if we emit the txHash and confirmations\n            // with no time in between:\n            //\n            // ```js\n            // const txHash = await new Promise((resolve, reject) => lockAndMint.on(\"transactionHash\", resolve).catch(reject));\n            // lockAndMint.on(\"confirmation\", () => { /* do something */ });\n            // ```\n\n\n            _context8.next = 8;\n            return emitConfirmation();\n\n          case 8:\n            setTimeout(function () {\n              emitConfirmation().catch(console.error);\n            }, 1000);\n            return _context8.abrupt(\"return\", receipt);\n\n          case 10:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function manualPromiEvent(_x20, _x21, _x22) {\n    return _ref7.apply(this, arguments);\n  };\n}();\nexport var getTokenAddress =\n/*#__PURE__*/\nfunction () {\n  var _ref9 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee9(network, web3, asset) {\n    var getTokenBySymbolABI, registry, tokenAddress;\n    return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            _context9.prev = 0;\n            getTokenBySymbolABI = {\n              constant: true,\n              inputs: [{\n                internalType: \"string\",\n                name: \"_tokenSymbol\",\n                type: \"string\"\n              }],\n              name: \"getTokenBySymbol\",\n              outputs: [{\n                internalType: \"contract IERC20\",\n                name: \"\",\n                type: \"address\"\n              }],\n              payable: false,\n              stateMutability: \"view\",\n              type: \"function\"\n            };\n            registry = new web3.eth.Contract([getTokenBySymbolABI], network.addresses.GatewayRegistry);\n            _context9.next = 5;\n            return registry.methods.getTokenBySymbol(asset).call();\n\n          case 5:\n            tokenAddress = _context9.sent;\n\n            if (tokenAddress) {\n              _context9.next = 8;\n              break;\n            }\n\n            throw new Error(\"Empty address returned.\");\n\n          case 8:\n            return _context9.abrupt(\"return\", tokenAddress);\n\n          case 11:\n            _context9.prev = 11;\n            _context9.t0 = _context9[\"catch\"](0);\n            (_context9.t0 || {}).message = \"Error looking up \".concat(asset, \" token address\").concat(_context9.t0.message ? \": \".concat(String(_context9.t0.message)) : \".\");\n            throw _context9.t0;\n\n          case 15:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee9, null, [[0, 11]]);\n  }));\n\n  return function getTokenAddress(_x23, _x24, _x25) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nexport var findTransactionBySigHash =\n/*#__PURE__*/\nfunction () {\n  var _ref10 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee10(network, web3, asset, nHash, sigHash, blockLimit) {\n    var status, gatewayAddress, statusABI, gatewayContract, fromBlock, toBlock, oldMintEvents, newMintEvents;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.prev = 0;\n            _context10.next = 3;\n            return getGatewayAddress(network, web3, asset);\n\n          case 3:\n            gatewayAddress = _context10.sent;\n            statusABI = {\n              constant: true,\n              inputs: [{\n                internalType: \"bytes32\",\n                name: \"\",\n                type: \"bytes32\"\n              }],\n              name: \"status\",\n              outputs: [{\n                internalType: \"bool\",\n                name: \"\",\n                type: \"bool\"\n              }],\n              payable: false,\n              stateMutability: \"view\",\n              type: \"function\"\n            };\n            gatewayContract = new web3.eth.Contract([statusABI], gatewayAddress);\n            fromBlock = 1;\n            toBlock = \"latest\";\n\n            if (!blockLimit) {\n              _context10.next = 15;\n              break;\n            }\n\n            _context10.t0 = BigNumber;\n            _context10.next = 12;\n            return web3.eth.getBlockNumber();\n\n          case 12:\n            _context10.t1 = _context10.sent.toString();\n            toBlock = new _context10.t0(_context10.t1).toNumber();\n            fromBlock = toBlock - blockLimit + 1;\n\n          case 15:\n            if (!sigHash) {\n              _context10.next = 26;\n              break;\n            }\n\n            _context10.next = 18;\n            return gatewayContract.methods.status(Ox(sigHash)).call();\n\n          case 18:\n            status = _context10.sent;\n\n            if (status) {\n              _context10.next = 21;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", undefined);\n\n          case 21:\n            _context10.next = 23;\n            return web3.eth.getPastLogs({\n              address: gatewayAddress,\n              fromBlock: fromBlock,\n              toBlock: toBlock,\n              topics: [eventTopics.LogMint, null, null, Ox(sigHash)]\n            });\n\n          case 23:\n            oldMintEvents = _context10.sent;\n\n            if (!oldMintEvents.length) {\n              _context10.next = 26;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", oldMintEvents[0].transactionHash);\n\n          case 26:\n            _context10.next = 28;\n            return web3.eth.getPastLogs({\n              address: gatewayAddress,\n              fromBlock: fromBlock,\n              toBlock: toBlock,\n              topics: [eventTopics.LogMint, null, null, Ox(nHash)]\n            });\n\n          case 28:\n            newMintEvents = _context10.sent;\n\n            if (!newMintEvents.length) {\n              _context10.next = 31;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", newMintEvents[0].transactionHash);\n\n          case 31:\n            _context10.next = 36;\n            break;\n\n          case 33:\n            _context10.prev = 33;\n            _context10.t2 = _context10[\"catch\"](0);\n            console.warn(_context10.t2); // Continue with transaction\n\n          case 36:\n            if (!status) {\n              _context10.next = 38;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", \"\");\n\n          case 38:\n            return _context10.abrupt(\"return\");\n\n          case 39:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10, null, [[0, 33]]);\n  }));\n\n  return function findTransactionBySigHash(_x26, _x27, _x28, _x29, _x30, _x31) {\n    return _ref10.apply(this, arguments);\n  };\n}();\nexport var submitToEthereum =\n/*#__PURE__*/\nfunction () {\n  var _ref11 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee11(web3, contractCalls, mintTx, eventEmitter) {\n    var logger,\n        tx,\n        i,\n        _contract$methods,\n        contractCall,\n        last,\n        contractParams,\n        contractFn,\n        sendTo,\n        callParams,\n        ABI,\n        contract,\n        txConfig,\n        config,\n        _args11 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            logger = _args11.length > 4 && _args11[4] !== undefined ? _args11[4] : NullLogger;\n\n            if (mintTx.out) {\n              _context11.next = 3;\n              break;\n            }\n\n            throw new Error(\"No result available from RenVM transaction.\");\n\n          case 3:\n            if (!(mintTx.out.revert !== undefined)) {\n              _context11.next = 5;\n              break;\n            }\n\n            throw new Error(\"Unable to submit reverted RenVM transaction.\");\n\n          case 5:\n            if (mintTx.out.signature) {\n              _context11.next = 7;\n              break;\n            }\n\n            throw new Error(\"No signature available from RenVM transaction.\");\n\n          case 7:\n            i = 0;\n\n          case 8:\n            if (!(i < contractCalls.length)) {\n              _context11.next = 25;\n              break;\n            }\n\n            contractCall = contractCalls[i];\n            last = i === contractCalls.length - 1;\n            contractParams = contractCall.contractParams, contractFn = contractCall.contractFn, sendTo = contractCall.sendTo;\n            callParams = last ? [].concat(_toConsumableArray((contractParams || []).map(function (value) {\n              return value.value;\n            })), [Ox(new BigNumber(mintTx.out.amount).toString(16)), Ox(mintTx.out.nhash), Ox(mintTx.out.signature)]) : (contractParams || []).map(function (value) {\n              return value.value;\n            });\n            ABI = last ? payloadToMintABI(contractFn, contractParams || []) : payloadToABI(contractFn, contractParams || []);\n            contract = new web3.eth.Contract(ABI, sendTo);\n            txConfig = typeof contractCall === \"object\" ? contractCall.txConfig : {};\n            _context11.next = 18;\n            return withDefaultAccount(web3, _objectSpread({}, txConfig, {\n              value: txConfig && txConfig.value ? txConfig.value.toString() : undefined,\n              gasPrice: txConfig && txConfig.gasPrice ? txConfig.gasPrice.toString() : undefined\n            }));\n\n          case 18:\n            config = _context11.sent;\n            logger.debug.apply(logger, [\"Calling Ethereum contract\", contractFn, sendTo].concat(_toConsumableArray(callParams), [config]));\n            tx = (_contract$methods = contract.methods)[contractFn].apply(_contract$methods, _toConsumableArray(callParams)).send(config);\n\n            if (last && tx !== undefined) {\n              forwardWeb3Events(tx, eventEmitter);\n            }\n\n          case 22:\n            i++;\n            _context11.next = 8;\n            break;\n\n          case 25:\n            _context11.next = 27;\n            return new Promise(function (innerResolve, reject) {\n              if (tx === undefined) {\n                throw new Error(\"Must provide contract call.\");\n              }\n\n              tx.once(\"confirmation\", function (_confirmations, receipt) {\n                innerResolve(receipt.transactionHash);\n              }).catch(function (error) {\n                try {\n                  if (ignorePromiEventError(error)) {\n                    logger.error(extractError(error));\n                    return;\n                  }\n                } catch (_error) {\n                  /* Ignore _error */\n                }\n\n                reject(error);\n              });\n            });\n\n          case 27:\n            return _context11.abrupt(\"return\", _context11.sent);\n\n          case 28:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n\n  return function submitToEthereum(_x32, _x33, _x34, _x35) {\n    return _ref11.apply(this, arguments);\n  };\n}();\nexport var addressIsValid = function addressIsValid(address) {\n  if (/^.+\\.eth$/.exec(address)) {\n    return true;\n  }\n\n  if (/^0x[a-f0-9]{40}$/.exec(address)) {\n    return isValidAddress(address);\n  }\n\n  if (/^0x[a-fA-F0-9]{40}$/.exec(address)) {\n    return isValidChecksumAddress(address);\n  }\n\n  return false;\n};","map":null,"metadata":{},"sourceType":"module"}