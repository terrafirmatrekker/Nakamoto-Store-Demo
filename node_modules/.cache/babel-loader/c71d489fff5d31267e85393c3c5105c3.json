{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Networks, Opcode, Script } from \"bitcore-lib\";\nimport { encode } from \"bs58\";\nimport { getConfirmations, getUTXO, getUTXOs } from \"send-crypto/build/main/handlers/BTC/BTCHandler\";\nimport { validate } from \"wallet-address-validator\";\nimport { createAddress } from \"./common\";\nimport { Ox, strip0x } from \"./hex\";\nexport var createBTCAddress = createAddress(Networks, Opcode, Script);\nexport var getBitcoinUTXOs = function getBitcoinUTXOs(_ref) {\n  var isTestnet = _ref.isTestnet;\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(address, confirmations) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", getUTXOs(isTestnet, {\n                  address: address,\n                  confirmations: confirmations\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x, _x2) {\n        return _ref2.apply(this, arguments);\n      };\n    }()\n  );\n};\nexport var getBitcoinConfirmations = function getBitcoinConfirmations(_ref3) {\n  var isTestnet = _ref3.isTestnet;\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref4 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(txHash) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", getConfirmations(isTestnet, txHash));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x3) {\n        return _ref4.apply(this, arguments);\n      };\n    }()\n  );\n};\nexport var getBitcoinUTXO = function getBitcoinUTXO(_ref5) {\n  var isTestnet = _ref5.isTestnet;\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref6 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(txHash, vOut) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", getUTXO(isTestnet, txHash, vOut));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      return function (_x4, _x5) {\n        return _ref6.apply(this, arguments);\n      };\n    }()\n  );\n}; // export const btcAddressToHex = (address: string) => {\n//     const addressBuffer = new Address(address).toBuffer();\n//     // Concatenate checksum\n//     return Ox(Buffer.concat([addressBuffer, Base58Check.checksum(addressBuffer)]));\n// };\n// export const btcAddressFrom = (address: string, encoding: \"hex\" | \"base64\") => {\n//     // tslint:disable-next-line: no-any\n//     return (Address as any)\n//         .fromBuffer(Buffer.from(encoding === \"hex\" ? strip0x(address) : address, encoding).slice(0, -4))\n//         .toString();\n// };\n\nexport var btcAddressToHex = function btcAddressToHex(address) {\n  return Ox(Buffer.from(address));\n};\n\nvar isBTCAddress = function isBTCAddress(address) {\n  return validate(address, \"btc\", \"testnet\") || validate(address, \"btc\", \"prod\");\n};\n\nvar btcTactics = {\n  decoders: [function (address) {\n    return Buffer.from(address);\n  }, function (address) {\n    return Buffer.from(address, \"base64\");\n  }, function (address) {\n    return Buffer.from(strip0x(address), \"hex\");\n  }],\n  encoders: [function (buffer) {\n    return encode(buffer);\n  }, function (buffer) {\n    return buffer.toString();\n  }]\n};\nexport var anyAddressFrom = function anyAddressFrom(isAnyAddress, _ref7) {\n  var encoders = _ref7.encoders,\n      decoders = _ref7.decoders;\n  return function (address) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = encoders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var encoder = _step.value;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = decoders[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var decoder = _step2.value;\n\n            try {\n              var encoded = encoder(decoder(address));\n\n              if (isAnyAddress(encoded)) {\n                return encoded;\n              }\n            } catch (error) {// Ignore errors\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return address;\n  };\n};\nexport var btcAddressFrom = anyAddressFrom(isBTCAddress, btcTactics);","map":null,"metadata":{},"sourceType":"module"}