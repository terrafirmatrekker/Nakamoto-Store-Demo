{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { getRenNetworkDetails, NullLogger, RenNetwork } from \"@renproject/interfaces\";\nimport { RenVMProvider as V1Provider } from \"./v1\";\nimport { RenVMProvider as V2Provider } from \"./v2\";\n\nvar isV1Selector = function isV1Selector(selector) {\n  return [\"BTC0Btc2Eth\", \"BTC0Eth2Btc\", \"ZEC0Zec2Eth\", \"ZEC0Eth2Zec\", \"BCH0Bch2Eth\", \"BCH0Eth2Bch\"].indexOf(selector) >= 0;\n};\n\nexport var CombinedProvider = function CombinedProvider(network) {\n  var _this = this;\n\n  var logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NullLogger;\n\n  _classCallCheck(this, CombinedProvider);\n\n  this.selector = function (params) {\n    var v1Selector = _this.v1 && _this.v1.selector(params);\n\n    return v1Selector && isV1Selector(v1Selector) ? v1Selector : _this.v2.selector(params);\n  };\n\n  this.version = function (selector) {\n    return isV1Selector(selector) ? 1 : 2;\n  };\n\n  this.mintTxHash = function (params) {\n    return _this.v1 && isV1Selector(params.selector) ? _this.v1.mintTxHash(params) : _this.v2.mintTxHash(params);\n  };\n\n  this.submitMint = function (params) {\n    return _this.v1 && isV1Selector(params.selector) ? _this.v1.submitMint(params) : _this.v2.submitMint(params);\n  };\n\n  this.burnTxHash = function (params) {\n    if (isV1Selector(params.selector)) {\n      throw new Error(\"Fetching burn txHash is not supported for \".concat(params.selector));\n    }\n\n    return _this.v2.burnTxHash(params);\n  };\n\n  this.submitBurn = function (params) {\n    return _this.v1 && isV1Selector(params.selector) ? _this.v1.submitBurn(params) : _this.v2.submitBurn(params);\n  };\n\n  this.queryMintOrBurn = function (selector, utxoTxHash) {\n    return _this.v1 && isV1Selector(selector) ? _this.v1.queryMintOrBurn(selector, utxoTxHash) : _this.v2.queryMintOrBurn(selector, utxoTxHash);\n  };\n\n  this.waitForTX = function (selector, utxoTxHash, onStatus, cancelRequested, timeout) {\n    return _this.v1 && isV1Selector(selector) ? _this.v1.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout) : _this.v2.waitForTX(selector, utxoTxHash, onStatus, cancelRequested, timeout);\n  };\n  /**\n   * selectPublicKey fetches the key for the RenVM shard handling\n   * the provided contract.\n   *\n   * @returns The key hash (20 bytes) as a string.\n   */\n\n\n  this.selectPublicKey = function (selector, assetOrChain) {\n    return _this.v1 && isV1Selector(selector) ? _this.v1.selectPublicKey(selector, assetOrChain) : _this.v2.selectPublicKey(selector, assetOrChain);\n  };\n  /**\n   * Used to query what network a custom provider is connected to. LockAndMint\n   * and BurnAndRelease use this to configure their chain parameters.\n   */\n\n\n  this.getNetwork = function (selector) {\n    return _this.v1 && isV1Selector(selector) ? _this.v1.getNetwork(selector) : _this.v2.getNetwork(selector);\n  };\n\n  this.getConfirmationTarget =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(selector, chain) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", _this.v1 && isV1Selector(selector) ? _this.v1.getConfirmationTarget(selector, chain) : _this.v2.getConfirmationTarget(selector, chain));\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  this.estimateTransactionFee =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(selector, chain) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", _this.v1 && isV1Selector(selector) ? _this.v1.estimateTransactionFee(selector, chain) : _this.v2.estimateTransactionFee(selector, chain));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  this.network = getRenNetworkDetails(network);\n  var v1Network;\n  var v2Network;\n\n  switch (this.network.name) {\n    case RenNetwork.Mainnet:\n    case RenNetwork.Mainnet:\n    case RenNetwork.MainnetVDot3:\n    case RenNetwork.MainnetVDot3:\n      v1Network = RenNetwork.Mainnet;\n      v2Network = RenNetwork.MainnetVDot3;\n      break;\n\n    case RenNetwork.Testnet:\n    case RenNetwork.Testnet:\n    case RenNetwork.TestnetVDot3:\n    case RenNetwork.TestnetVDot3:\n      v1Network = RenNetwork.Testnet;\n      v2Network = RenNetwork.TestnetVDot3;\n      break;\n\n    case RenNetwork.DevnetVDot3:\n    case RenNetwork.DevnetVDot3:\n      v2Network = RenNetwork.DevnetVDot3;\n      break;\n\n    default:\n      v1Network = network;\n      v2Network = network;\n  }\n\n  if (v1Network) {\n    this.v1 = new V1Provider(v1Network, undefined, logger);\n  }\n\n  this.v2 = new V2Provider(v2Network, undefined, logger); // Default to the v2 network.\n\n  this.sendMessage = this.v2.sendMessage;\n};","map":null,"metadata":{},"sourceType":"module"}