{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/* eslint-disable no-console */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// TODO: Improve typings.\nimport { BurnAndReleaseStatus } from \"@renproject/ren/build/main/burnAndRelease\";\nimport { assign, spawn } from \"xstate\";\n\nvar burnAndRelease =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(context) {\n    var _a, transaction;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            transaction = (_a = context.tx.transaction) === null || _a === void 0 ? void 0 : _a.sourceTxHash;\n            _context.next = 3;\n            return context.sdk.burnAndRelease(Object.assign({\n              asset: context.tx.sourceAsset.toUpperCase(),\n              to: context.to(context),\n              from: context.from(context)\n            }, transaction ? {\n              transaction: transaction\n            } : {}));\n\n          case 3:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function burnAndRelease(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar spawnBurnTransaction = assign({\n  burnListenerRef: function burnListenerRef(c, _e) {\n    var actorName = \"\".concat(c.tx.id, \"BurnListener\");\n\n    if (c.burnListenerRef) {\n      console.warn(\"listener already exists\");\n      return c.burnListenerRef;\n    }\n\n    var cb = burnTransactionListener(c); // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n\n    return spawn(cb, actorName);\n  }\n});\n\nvar extractTx = function extractTx(burn) {\n  if (!burn.burnDetails) throw new Error(\"missing burn\");\n  var tx = {\n    renVMHash: burn.txHash(),\n    rawSourceTx: burn.burnDetails.transaction,\n    sourceTxConfTarget: 0,\n    sourceTxConfs: 0,\n    sourceTxHash: burn.burnDetails.transaction.hash,\n    detectedAt: Date.now(),\n    sourceTxAmount: burn.burnDetails.amount.toString()\n  };\n  return tx;\n};\n\nvar performBurn =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(burn, callback, cleaners, context) {\n    var _a, burnRef, tx, burnListener, target, r, data;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // will resume from previous tx if we have the hash\n            burnRef = burn.burn();\n\n            burnListener = function burnListener(confs\n            /* actually eth tx target: number */\n            ) {\n              burn.confirmationTarget().then(function (target) {\n                // We need to wait for burn details to resolve, which\n                // might not be ready even if we have sufficient confirmations\n                var data = Object.assign(Object.assign({}, Object.assign(Object.assign({}, tx), context.tx.transaction)), {\n                  sourceTxConfs: confs,\n                  sourceTxConfTarget: target\n                });\n                callback({\n                  type: \"CONFIRMATION\",\n                  data: data\n                });\n\n                if (target <= confs) {\n                  var _data = Object.assign(Object.assign({}, Object.assign(Object.assign({}, extractTx(burn)), context.tx.transaction)), {\n                    sourceTxConfs: target,\n                    sourceTxConfTarget: target\n                  });\n\n                  callback({\n                    type: \"CONFIRMED\",\n                    data: _data\n                  });\n                }\n              }).catch(function (e) {\n                throw e;\n              });\n            };\n\n            cleaners.push(function () {\n              burnRef._cancel();\n\n              burnRef.removeListener(\"confirmation\", burnListener);\n            });\n            _context2.prev = 3;\n            _context2.t0 = (_a = context.tx.transaction) === null || _a === void 0 ? void 0 : _a.sourceTxConfTarget;\n\n            if (_context2.t0) {\n              _context2.next = 9;\n              break;\n            }\n\n            _context2.next = 8;\n            return burn.confirmationTarget();\n\n          case 8:\n            _context2.t0 = _context2.sent;\n\n          case 9:\n            target = _context2.t0;\n            _context2.next = 12;\n            return burnRef // host chain tx hash\n            .on(\"transactionHash\", function (txHash) {\n              var data = {\n                sourceTxConfs: 0,\n                sourceTxConfTarget: target,\n                sourceTxHash: txHash,\n                detectedAt: Date.now(),\n                sourceTxAmount: context.tx.targetAmount\n              };\n              tx = data;\n              callback({\n                type: \"SUBMITTED\",\n                data: data\n              });\n            }).on(\"confirmation\", burnListener);\n\n          case 12:\n            r = _context2.sent;\n            // stop listening for confirmations once confirmed\n            burnRef.removeListener(\"confirmation\", burnListener);\n\n            if (!(r.status == BurnAndReleaseStatus.Burned || r.status == BurnAndReleaseStatus.Released)) {\n              _context2.next = 18;\n              break;\n            }\n\n            data = Object.assign(Object.assign({}, Object.assign(Object.assign({}, extractTx(burn)), context.tx.transaction)), {\n              sourceTxConfs: target,\n              sourceTxConfTarget: target\n            });\n            callback({\n              type: \"CONFIRMED\",\n              data: data\n            });\n            return _context2.abrupt(\"return\", data);\n\n          case 18:\n            if (!(r.status == BurnAndReleaseStatus.Reverted)) {\n              _context2.next = 20;\n              break;\n            }\n\n            throw new Error(\"Burn tx reverted: \".concat(r.revertReason));\n\n          case 20:\n            throw new Error(\"Burn interrupted\");\n\n          case 23:\n            _context2.prev = 23;\n            _context2.t1 = _context2[\"catch\"](3);\n            throw _context2.t1;\n\n          case 26:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 23]]);\n  }));\n\n  return function performBurn(_x2, _x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar performRelease =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(burn, callback, cleaners, tx) {\n    var _a, releaseListener, hashListener, response, transactionListener, releaseRef, res, data;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // Only start processing release once confirmed\n            // Release from renvm status\n            releaseListener = function releaseListener(status) {\n              status === \"confirming\" ? console.debug(\"confirming\") : console.debug(\"status\", status);\n            };\n\n            hashListener = function hashListener(renVMHash) {\n              var data = Object.assign(Object.assign({}, tx), {\n                renVMHash: renVMHash\n              });\n              callback({\n                type: \"ACCEPTED\",\n                data: data\n              });\n            };\n\n            transactionListener = function transactionListener(transaction) {\n              if (!burn.burnDetails) return;\n              var data = Object.assign(Object.assign({}, tx), {\n                rawSourceTx: burn.burnDetails.transaction,\n                destTxHash: transaction.hash,\n                // Can be used to construct blockchain explorer link\n                renResponse: response,\n                rawDestTx: transaction,\n                completedAt: Date.now(),\n                destTxAmount: transaction.amount\n              });\n              callback({\n                type: \"COMPLETED\",\n                data: data\n              });\n            };\n\n            releaseRef = burn.release();\n            cleaners.push(function () {\n              releaseRef._cancel();\n\n              releaseRef.removeListener(\"status\", releaseListener);\n              releaseRef.removeListener(\"transaction\", transactionListener);\n              releaseRef.removeListener(\"txHash\", hashListener);\n            });\n            releaseRef.catch(function (e) {\n              console.error(\"release error\", e);\n              callback({\n                type: \"RELEASE_ERROR\",\n                data: tx,\n                error: e\n              });\n            });\n            _context3.prev = 6;\n            _context3.next = 9;\n            return releaseRef.on(\"status\", releaseListener).on(\"transaction\", transactionListener).on(\"txHash\", hashListener);\n\n          case 9:\n            res = _context3.sent;\n\n            if ((_a = burn.burnDetails) === null || _a === void 0 ? void 0 : _a.transaction) {\n              _context3.next = 12;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 12:\n            response = res;\n            data = Object.assign(Object.assign({}, tx), {\n              rawSourceTx: burn.burnDetails.transaction,\n              destTxHash: burn.releaseTransaction,\n              renResponse: res\n            });\n            callback({\n              type: \"RELEASED\",\n              data: data\n            });\n            _context3.next = 20;\n            break;\n\n          case 17:\n            _context3.prev = 17;\n            _context3.t0 = _context3[\"catch\"](6);\n            callback({\n              type: \"RELEASE_ERROR\",\n              data: tx,\n              error: _context3.t0\n            });\n\n          case 20:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[6, 17]]);\n  }));\n\n  return function performRelease(_x6, _x7, _x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar burnTransactionListener = function burnTransactionListener(context) {\n  return function (callback, receive) {\n    var cleaners = [];\n    var burning = false;\n    var tx;\n    burnAndRelease(context).then(function (burn) {\n      // Ready to recieve SUBMIT\n      callback({\n        type: \"CREATED\"\n      });\n\n      if (context.autoSubmit || // Alway \"SUBMIT\" if we have submitted previously\n      context.tx.transaction) {\n        setTimeout(function () {\n          return callback(\"SUBMIT\");\n        }, 500);\n      }\n\n      receive(function (event) {\n        if (event.type === \"SUBMIT\") {\n          // Only burn once\n          if (burning) {\n            return;\n          }\n\n          burning = true;\n          performBurn(burn, callback, cleaners, context).then(function (r) {\n            return tx = r;\n          }).catch(function (e) {\n            console.error(e);\n            callback({\n              type: \"BURN_ERROR\",\n              data: e.toString(),\n              error: e\n            });\n          });\n        }\n\n        if (event.type === \"RELEASE\") {\n          var _tx = context.tx.transaction || extractTx(burn);\n\n          performRelease(burn, callback, cleaners, _tx).then().catch(function (e) {\n            callback({\n              type: \"BURN_ERROR\",\n              data: context.tx,\n              error: e\n            });\n          });\n        }\n      });\n    }).catch(function (e) {\n      console.error(e);\n      callback({\n        type: \"BURN_ERROR\",\n        data: {},\n        error: e\n      });\n    });\n    return function () {\n      for (var _i = 0, _cleaners = cleaners; _i < _cleaners.length; _i++) {\n        var cleaner = _cleaners[_i];\n        cleaner();\n      }\n    };\n  };\n};\n\nexport var buildBurnConfig = function buildBurnConfig() {\n  return {\n    actions: {\n      burnSpawner: spawnBurnTransaction\n    },\n    services: {\n      burnListener: burnTransactionListener\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module"}