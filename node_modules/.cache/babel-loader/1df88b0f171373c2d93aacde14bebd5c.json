{"ast":null,"code":"var typeforce = require('typeforce');\n\nvar ECSignature = require('./ecsignature');\n\nvar types = require('./types');\n\nvar secp256k1;\nvar available = false;\n\ntry {\n  // secp256k1 is an optional native module used for accelerating\n  // low-level elliptic curve operations. It's nice to have, but\n  // we can live without it too\n  secp256k1 = require('secp256k1');\n  available = true;\n} catch (e) {} // secp256k1 is not available, this is alright\n\n/**\n * Derive a public key from a 32 byte private key buffer.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n *\n * @param buffer {Buffer} Private key buffer\n * @param compressed {Boolean} Whether the public key should be compressed\n * @return {undefined}\n */\n\n\nvar publicKeyCreate = function publicKeyCreate(buffer, compressed) {\n  typeforce(types.tuple(types.Buffer256bit, types.Boolean), arguments);\n\n  if (!available) {\n    return undefined;\n  }\n\n  return secp256k1.publicKeyCreate(buffer, compressed);\n};\n/**\n * Create an ECDSA signature over the given message hash `hash` with\n * the private key `d`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be signed\n * @param d {BigInteger} private key which is to be used for signing\n * @return {ECSignature}\n */\n\n\nvar sign = function sign(hash, d) {\n  typeforce(types.tuple(types.Buffer256bit, types.BigInt), arguments);\n\n  if (!available) {\n    return undefined;\n  }\n\n  var sig = secp256k1.sign(hash, d.toBuffer(32)).signature;\n  return ECSignature.fromDER(secp256k1.signatureExport(sig));\n};\n/**\n * Verify an ECDSA signature over the given message hash `hash` with signature `sig`\n * and public key `pubkey`.\n *\n * Uses secp256k1 for acceleration. If secp256k1 is not available,\n * this function returns undefined.\n * @param hash {Buffer} hash of the message which is to be verified\n * @param sig {ECSignature} signature which is to be verified\n * @param pubkey {Buffer} public key which will be used to verify the message signature\n * @return {Boolean}\n */\n\n\nvar verify = function verify(hash, sig, pubkey) {\n  typeforce(types.tuple(types.Hash256bit, types.ECSignature, // both compressed and uncompressed public keys are fine\n  types.oneOf(types.BufferN(33), types.BufferN(65))), arguments);\n\n  if (!available) {\n    return undefined;\n  }\n\n  sig = new ECSignature(sig.r, sig.s);\n  sig = secp256k1.signatureNormalize(secp256k1.signatureImport(sig.toDER()));\n  return secp256k1.verify(hash, sig, pubkey);\n};\n\nmodule.exports = {\n  available: available,\n  publicKeyCreate: publicKeyCreate,\n  sign: sign,\n  verify: verify\n};","map":null,"metadata":{},"sourceType":"script"}