{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// TODO: Improve typings.\nimport { assign, createMachine, createSchema, send, sendParent } from \"xstate\";\nimport { log } from \"xstate/lib/actions\";\nimport { assert } from \"@renproject/utils\";\nimport { isAccepted as _isAccepted, isCompleted as _isCompleted, isConfirming, isMinted, isSubmitted } from \"../types/mint\";\n\nvar largest = function largest(x, y) {\n  if (!x) {\n    if (y) return y;\n    return 0;\n  }\n\n  if (!y) {\n    if (x) return x;\n    return 0;\n  }\n\n  if (x > y) return x;\n  return y;\n};\n\nexport var DepositStates;\n\n(function (DepositStates) {\n  DepositStates[\"CHECKING_COMPLETION\"] = \"checkingCompletion\";\n  /** We are waiting for ren-js to find the deposit */\n\n  DepositStates[\"RESTORING_DEPOSIT\"] = \"restoringDeposit\";\n  /** We couldn't restore this deposit */\n\n  DepositStates[\"ERROR_RESTORING\"] = \"errorRestoring\";\n  /** renjs has found the deposit for the transaction */\n\n  DepositStates[\"RESTORED_DEPOSIT\"] = \"restoredDeposit\";\n  /** we are waiting for the source chain to confirm the transaction */\n\n  DepositStates[\"CONFIRMING_DEPOSIT\"] = \"srcSettling\";\n  /** source chain has confirmed the transaction, submitting to renvm for signature */\n\n  DepositStates[\"RENVM_SIGNING\"] = \"srcConfirmed\";\n  /** renvm has accepted and signed the transaction */\n\n  DepositStates[\"RENVM_ACCEPTED\"] = \"accepted\";\n  /** renvm did not accept the tx */\n\n  DepositStates[\"ERROR_SIGNING\"] = \"errorAccepting\";\n  /** the user is submitting the transaction to mint on the destination chain */\n\n  DepositStates[\"SUBMITTING_MINT\"] = \"claiming\";\n  /** there was an error submitting the tx to the destination chain */\n\n  DepositStates[\"ERROR_MINTING\"] = \"errorSubmitting\";\n  /** We have recieved a txHash for the destination chain */\n\n  DepositStates[\"MINTING\"] = \"destInitiated\";\n  /** user has acknowledged that the transaction is completed, so we can stop listening for further deposits */\n\n  DepositStates[\"COMPLETED\"] = \"completed\";\n  /** user does not want to mint this deposit or the transaction reverted */\n\n  DepositStates[\"REJECTED\"] = \"rejected\";\n})(DepositStates || (DepositStates = {}));\n/** Statemachine that tracks individual deposits */\n\n\nexport var buildDepositMachine = function buildDepositMachine() {\n  return createMachine({\n    id: \"RenVMDepositTransaction\",\n    initial: DepositStates.CHECKING_COMPLETION,\n    schema: {\n      events: createSchema(),\n      context: createSchema()\n    },\n    states: {\n      // Checking if deposit is completed so that we can skip initialization\n      checkingCompletion: {\n        entry: [send(\"CHECK\")],\n        // If we already have completed, no need to listen\n        on: {\n          CHECK: [{\n            target: \"completed\",\n            cond: \"isCompleted\"\n          }, {\n            target: \"restoringDeposit\"\n          }]\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(!state.context.deposit.error ? true : false, \"Error must not exist\");\n          }\n        }\n      },\n      errorRestoring: {\n        entry: [log(function (ctx, _) {\n          return ctx.deposit.error;\n        }, \"ERROR\")],\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.deposit.error ? true : false, \"Error must exist\");\n          }\n        }\n      },\n      restoringDeposit: {\n        entry: sendParent(function (c, _) {\n          return {\n            type: \"RESTORE\",\n            data: c.deposit\n          };\n        }),\n        on: {\n          RESTORED: {\n            target: \"restoredDeposit\",\n            actions: [assign(function (_, e) {\n              return {\n                deposit: e.data\n              };\n            })]\n          },\n          ERROR: {\n            target: \"errorRestoring\",\n            actions: assign(function (c, e) {\n              return {\n                deposit: Object.assign(Object.assign({}, c.deposit), {\n                  error: e.error\n                })\n              };\n            })\n          }\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(!state.context.deposit.error ? true : false, \"Error must not exist\");\n          }\n        }\n      },\n      // Checking deposit internal state to transition to correct machine state\n      restoredDeposit: {\n        // Parent must send restored\n        entry: [send(\"RESTORED\")],\n        on: {\n          RESTORED: [{\n            target: \"srcSettling\",\n            cond: \"isSrcSettling\"\n          }, {\n            target: \"srcConfirmed\",\n            cond: \"isSrcSettled\"\n          }, {\n            target: \"accepted\",\n            cond: \"isAccepted\"\n          }].reverse()\n        },\n        meta: {\n          test: function () {\n            var _test = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee() {\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            function test() {\n              return _test.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      srcSettling: {\n        entry: sendParent(function (ctx, _) {\n          return {\n            type: \"SETTLE\",\n            hash: ctx.deposit.sourceTxHash\n          };\n        }),\n        on: {\n          CONFIRMED: [{\n            target: \"srcConfirmed\",\n            actions: [assign({\n              deposit: function deposit(_ref, evt) {\n                var _deposit = _ref.deposit;\n\n                if (isConfirming(_deposit) && _deposit.sourceTxConfTarget) {\n                  return Object.assign(Object.assign({}, _deposit), {\n                    sourceTxConfs: largest(_deposit.sourceTxConfs, evt.data.sourceTxConfs),\n                    sourceTxConfTarget: largest(_deposit.sourceTxConfTarget, evt.data.sourceTxConfTarget)\n                  });\n                }\n\n                return _deposit;\n              }\n            }), sendParent(function (ctx, _) {\n              return {\n                type: \"DEPOSIT_UPDATE\",\n                data: ctx.deposit\n              };\n            })]\n          }],\n          CONFIRMATION: [{\n            actions: [sendParent(function (ctx, evt) {\n              return {\n                type: \"DEPOSIT_UPDATE\",\n                data: Object.assign(Object.assign({}, ctx.deposit), evt.data)\n              };\n            }), assign({\n              deposit: function deposit(context, evt) {\n                var _a, _b;\n\n                return Object.assign(Object.assign({}, context.deposit), {\n                  sourceTxConfs: ((_a = evt.data) === null || _a === void 0 ? void 0 : _a.sourceTxConfs) || 0,\n                  sourceTxConfTarget: (_b = evt.data) === null || _b === void 0 ? void 0 : _b.sourceTxConfTarget\n                });\n              }\n            })]\n          }],\n          ERROR: [{\n            actions: [assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  error: evt.error\n                });\n              }\n            }), log(function (ctx, _) {\n              return ctx.deposit.error;\n            }, \"ERROR\")]\n          }]\n        },\n        meta: {\n          test: function () {\n            var _test2 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee2() {\n              return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee2);\n            }));\n\n            function test() {\n              return _test2.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      srcConfirmed: {\n        entry: sendParent(function (ctx, _) {\n          return {\n            type: \"SIGN\",\n            hash: ctx.deposit.sourceTxHash\n          };\n        }),\n        on: {\n          SIGN_ERROR: {\n            target: \"errorAccepting\",\n            actions: assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  error: evt.error\n                });\n              }\n            })\n          },\n          REVERTED: {\n            target: \"rejected\",\n            actions: assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  error: evt.error\n                });\n              }\n            })\n          },\n          SIGNED: {\n            target: \"accepted\",\n            actions: assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), evt.data);\n              }\n            })\n          }\n        },\n        meta: {\n          test: function () {\n            var _test3 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee3() {\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3);\n            }));\n\n            function test() {\n              return _test3.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      errorAccepting: {\n        entry: [log(function (ctx, _) {\n          return ctx.deposit.error;\n        }, \"ERROR\")],\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.deposit.error ? true : false, \"error must exist\");\n          }\n        }\n      },\n      accepted: {\n        entry: sendParent(function (ctx, _) {\n          return {\n            type: \"CLAIMABLE\",\n            data: ctx.deposit\n          };\n        }),\n        on: {\n          CLAIM: {\n            target: \"claiming\",\n            actions: assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  contractParams: evt.params\n                });\n              }\n            })\n          },\n          REJECT: \"rejected\"\n        },\n        meta: {\n          test: function () {\n            var _test4 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee4() {\n              return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4);\n            }));\n\n            function test() {\n              return _test4.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      errorSubmitting: {\n        entry: [log(function (ctx, _) {\n          return ctx.deposit.error;\n        }, \"ERROR\"), sendParent(function (ctx, _) {\n          return {\n            type: \"CLAIMABLE\",\n            data: ctx.deposit\n          };\n        })],\n        on: {\n          CLAIM: {\n            target: \"claiming\",\n            actions: assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  contractParams: evt.data\n                });\n              }\n            })\n          },\n          REJECT: \"rejected\"\n        },\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.deposit.error ? true : false, \"error must exist\");\n          }\n        }\n      },\n      claiming: {\n        entry: sendParent(function (ctx) {\n          return {\n            type: \"MINT\",\n            hash: ctx.deposit.sourceTxHash,\n            data: isSubmitted(ctx.deposit) && ctx.deposit.contractParams\n          };\n        }),\n        on: {\n          SUBMIT_ERROR: [{\n            target: \"errorSubmitting\",\n            actions: [assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  error: evt.error\n                });\n              }\n            }), sendParent(function (ctx, _) {\n              return {\n                type: \"DEPOSIT_UPDATE\",\n                data: ctx.deposit\n              };\n            })]\n          }],\n          SUBMITTED: [{\n            target: \"destInitiated\",\n            actions: [assign({\n              deposit: function deposit(ctx, evt) {\n                return Object.assign(Object.assign({}, ctx.deposit), evt.data);\n              }\n            }), sendParent(function (ctx, _) {\n              return {\n                type: \"DEPOSIT_UPDATE\",\n                data: ctx.deposit\n              };\n            })]\n          }]\n        },\n        meta: {\n          test: function () {\n            var _test5 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee5() {\n              return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5);\n            }));\n\n            function test() {\n              return _test5.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      destInitiated: {\n        on: {\n          ACKNOWLEDGE: {\n            target: \"completed\",\n            actions: [assign({\n              deposit: function deposit(ctx, _) {\n                return Object.assign(Object.assign({}, ctx.deposit), {\n                  completedAt: new Date().getTime()\n                });\n              }\n            })]\n          }\n        },\n        meta: {\n          test: function () {\n            var _test6 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee6() {\n              return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                while (1) {\n                  switch (_context6.prev = _context6.next) {\n                    case 0:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }\n              }, _callee6);\n            }));\n\n            function test() {\n              return _test6.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      rejected: {\n        entry: [sendParent(function (ctx, _) {\n          return {\n            type: \"DEPOSIT_UPDATE\",\n            data: ctx.deposit\n          };\n        })],\n        meta: {\n          test: function () {\n            var _test7 = _asyncToGenerator(\n            /*#__PURE__*/\n            _regeneratorRuntime.mark(function _callee7() {\n              return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                while (1) {\n                  switch (_context7.prev = _context7.next) {\n                    case 0:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }\n              }, _callee7);\n            }));\n\n            function test() {\n              return _test7.apply(this, arguments);\n            }\n\n            return test;\n          }()\n        }\n      },\n      completed: {\n        entry: [sendParent(function (ctx, _) {\n          return {\n            type: \"DEPOSIT_COMPLETED\",\n            data: ctx.deposit\n          };\n        }), sendParent(function (ctx, _) {\n          return {\n            type: \"DEPOSIT_UPDATE\",\n            data: ctx.deposit\n          };\n        })],\n        meta: {\n          test: function test(_, state) {\n            assert(state.context.deposit.completedAt ? true : false, \"Must have completedAt timestamp\");\n          }\n        }\n      }\n    }\n  }, {\n    guards: {\n      isSrcSettling: function isSrcSettling(_ref2) {\n        var deposit = _ref2.deposit;\n        return isConfirming(deposit) && (deposit.sourceTxConfs || 0) < (deposit.sourceTxConfTarget || Number.POSITIVE_INFINITY);\n      },\n      isSrcSettled: function isSrcSettled(_ref3) {\n        var deposit = _ref3.deposit;\n        return isConfirming(deposit) && (deposit.sourceTxConfs || 0) >= deposit.sourceTxConfTarget;\n      },\n      isAccepted: function isAccepted(_ref4) {\n        var deposit = _ref4.deposit;\n        return _isAccepted(deposit) && deposit.renSignature ? true : false;\n      },\n      isDestInitiated: function isDestInitiated(_ref5) {\n        var deposit = _ref5.deposit;\n        return isMinted(deposit) && deposit.destTxHash ? true : false;\n      },\n      isCompleted: function isCompleted(_ref6) {\n        var deposit = _ref6.deposit;\n        return _isCompleted(deposit) && deposit.completedAt ? true : false;\n      }\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}