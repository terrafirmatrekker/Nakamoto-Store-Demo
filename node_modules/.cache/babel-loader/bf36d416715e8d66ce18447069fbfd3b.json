{"ast":null,"code":"// OP_0 [signatures ...]\nvar Buffer = require('safe-buffer').Buffer;\n\nvar bscript = require('../../script');\n\nvar p2mso = require('./output');\n\nvar typeforce = require('typeforce');\n\nvar OPS = require('bitcoin-ops');\n\nfunction partialSignature(value) {\n  return value === OPS.OP_0 || bscript.isCanonicalSignature(value);\n}\n\nfunction check(script, allowIncomplete) {\n  var chunks = bscript.decompile(script);\n  if (chunks.length < 2) return false;\n  if (chunks[0] !== OPS.OP_0) return false;\n\n  if (allowIncomplete) {\n    return chunks.slice(1).every(partialSignature);\n  }\n\n  return chunks.slice(1).every(bscript.isCanonicalSignature);\n}\n\ncheck.toJSON = function () {\n  return 'multisig input';\n};\n\nvar EMPTY_BUFFER = Buffer.allocUnsafe(0);\n\nfunction encodeStack(signatures, scriptPubKey) {\n  typeforce([partialSignature], signatures);\n\n  if (scriptPubKey) {\n    var scriptData = p2mso.decode(scriptPubKey);\n\n    if (signatures.length < scriptData.m) {\n      throw new TypeError('Not enough signatures provided');\n    }\n\n    if (signatures.length > scriptData.pubKeys.length) {\n      throw new TypeError('Too many signatures provided');\n    }\n  }\n\n  return [].concat(EMPTY_BUFFER, signatures.map(function (sig) {\n    if (sig === OPS.OP_0) {\n      return EMPTY_BUFFER;\n    }\n\n    return sig;\n  }));\n}\n\nfunction encode(signatures, scriptPubKey) {\n  return bscript.compile(encodeStack(signatures, scriptPubKey));\n}\n\nfunction decodeStack(stack, allowIncomplete) {\n  typeforce(check, stack, allowIncomplete);\n  return stack.slice(1);\n}\n\nfunction decode(buffer, allowIncomplete) {\n  var stack = bscript.decompile(buffer);\n  return decodeStack(stack, allowIncomplete);\n}\n\nmodule.exports = {\n  check: check,\n  decode: decode,\n  decodeStack: decodeStack,\n  encode: encode,\n  encodeStack: encodeStack\n};","map":null,"metadata":{},"sourceType":"script"}