{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useState, useRef } from 'react';\nimport useIsomorphicLayoutEffect from 'use-isomorphic-layout-effect';\nimport useConstant from './useConstant';\nexport function isActorWithState(actorRef) {\n  return 'state' in actorRef;\n}\n\nfunction isDeferredActor(actorRef) {\n  return 'deferred' in actorRef;\n}\n\nvar noop = function noop() {\n  /* ... */\n};\n\nfunction defaultGetSnapshot(actorRef) {\n  return isActorWithState(actorRef) ? actorRef.state : 'getSnapshot' in actorRef ? actorRef.getSnapshot() : undefined;\n}\n\nexport function useActor(actorRef, getSnapshot) {\n  if (getSnapshot === void 0) {\n    getSnapshot = defaultGetSnapshot;\n  }\n\n  var actorRefRef = useRef(actorRef);\n  var deferredEventsRef = useRef([]);\n\n  var _a = __read(useState(function () {\n    return getSnapshot(actorRef);\n  }), 2),\n      current = _a[0],\n      setCurrent = _a[1];\n\n  var send = useConstant(function () {\n    return function (event) {\n      var currentActorRef = actorRefRef.current; // If the previous actor is a deferred actor,\n      // queue the events so that they can be replayed\n      // on the non-deferred actor.\n\n      if (isDeferredActor(currentActorRef) && currentActorRef.deferred) {\n        deferredEventsRef.current.push(event);\n      } else {\n        currentActorRef.send(event);\n      }\n    };\n  });\n  useIsomorphicLayoutEffect(function () {\n    actorRefRef.current = actorRef;\n    setCurrent(getSnapshot(actorRef));\n    var subscription = actorRef.subscribe({\n      next: function next(emitted) {\n        return setCurrent(emitted);\n      },\n      error: noop,\n      complete: noop\n    }); // Dequeue deferred events from the previous deferred actorRef\n\n    while (deferredEventsRef.current.length > 0) {\n      var deferredEvent = deferredEventsRef.current.shift();\n      actorRef.send(deferredEvent);\n    }\n\n    return function () {\n      subscription.unsubscribe();\n    };\n  }, [actorRef]);\n  return [current, send];\n}","map":null,"metadata":{},"sourceType":"module"}