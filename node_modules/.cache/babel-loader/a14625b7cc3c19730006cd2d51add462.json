{"ast":null,"code":"import _classCallCheck from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport { WordArray, Hasher } from './core.js'; // Initialization and round constants tables\n\nvar H = [];\nvar K = []; // Compute constants\n\nvar isPrime = function isPrime(n) {\n  var sqrtN = Math.sqrt(n);\n\n  for (var factor = 2; factor <= sqrtN; factor += 1) {\n    if (!(n % factor)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar getFractionalBits = function getFractionalBits(n) {\n  return (n - (n | 0)) * 0x100000000 | 0;\n};\n\nvar n = 2;\nvar nPrime = 0;\n\nwhile (nPrime < 64) {\n  if (isPrime(n)) {\n    if (nPrime < 8) {\n      H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n    }\n\n    K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n    nPrime += 1;\n  }\n\n  n += 1;\n} // Reusable object\n\n\nvar W = [];\n/**\n * SHA-256 hash algorithm.\n */\n\nexport var SHA256Algo =\n/*#__PURE__*/\nfunction (_Hasher) {\n  _inherits(SHA256Algo, _Hasher);\n\n  function SHA256Algo() {\n    _classCallCheck(this, SHA256Algo);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SHA256Algo).apply(this, arguments));\n  }\n\n  _createClass(SHA256Algo, [{\n    key: \"_doReset\",\n    value: function _doReset() {\n      this._hash = new WordArray(H.slice(0));\n    }\n  }, {\n    key: \"_doProcessBlock\",\n    value: function _doProcessBlock(M, offset) {\n      // Shortcut\n      var _H = this._hash.words; // Working variables\n\n      var a = _H[0];\n      var b = _H[1];\n      var c = _H[2];\n      var d = _H[3];\n      var e = _H[4];\n      var f = _H[5];\n      var g = _H[6];\n      var h = _H[7]; // Computation\n\n      for (var i = 0; i < 64; i += 1) {\n        if (i < 16) {\n          W[i] = M[offset + i] | 0;\n        } else {\n          var gamma0x = W[i - 15];\n          var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n          var gamma1x = W[i - 2];\n          var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n        }\n\n        var ch = e & f ^ ~e & g;\n        var maj = a & b ^ a & c ^ b & c;\n        var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n        var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n        var t1 = h + sigma1 + ch + K[i] + W[i];\n        var t2 = sigma0 + maj;\n        h = g;\n        g = f;\n        f = e;\n        e = d + t1 | 0;\n        d = c;\n        c = b;\n        b = a;\n        a = t1 + t2 | 0;\n      } // Intermediate hash value\n\n\n      _H[0] = _H[0] + a | 0;\n      _H[1] = _H[1] + b | 0;\n      _H[2] = _H[2] + c | 0;\n      _H[3] = _H[3] + d | 0;\n      _H[4] = _H[4] + e | 0;\n      _H[5] = _H[5] + f | 0;\n      _H[6] = _H[6] + g | 0;\n      _H[7] = _H[7] + h | 0;\n    }\n  }, {\n    key: \"_doFinalize\",\n    value: function _doFinalize() {\n      // Shortcuts\n      var data = this._data;\n      var dataWords = data.words;\n      var nBitsTotal = this._nDataBytes * 8;\n      var nBitsLeft = data.sigBytes * 8; // Add padding\n\n      dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n      data.sigBytes = dataWords.length * 4; // Hash final blocks\n\n      this._process(); // Return final computed hash\n\n\n      return this._hash;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var clone = _get(_getPrototypeOf(SHA256Algo.prototype), \"clone\", this).call(this);\n\n      clone._hash = this._hash.clone();\n      return clone;\n    }\n  }]);\n\n  return SHA256Algo;\n}(Hasher);\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA256('message');\n *     var hash = CryptoJS.SHA256(wordArray);\n */\n\nexport var SHA256 = Hasher._createHelper(SHA256Algo);\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA256(message, key);\n */\n\nexport var HmacSHA256 = Hasher._createHmacHelper(SHA256Algo);","map":null,"metadata":{},"sourceType":"module"}