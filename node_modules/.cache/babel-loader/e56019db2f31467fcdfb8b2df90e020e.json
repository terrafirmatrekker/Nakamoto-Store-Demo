{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar fastMerkleRoot = require('merkle-lib/fastRoot');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar bufferutils = require('./bufferutils');\n\nvar varuint = require('varuint-bitcoin');\n\nvar networks = require('./networks');\n\nvar coins = require('./coins');\n\nvar Transaction = require('./transaction');\n\nfunction Block(network) {\n  typeforce(types.maybe(types.Network), network);\n  network = network || networks.bitcoin;\n  this.version = 1;\n  this.prevHash = null;\n  this.merkleRoot = null;\n  this.timestamp = 0;\n  this.bits = 0;\n  this.nonce = 0;\n  this.network = network;\n\n  if (coins.isZcash(network)) {\n    this.finalSaplingRoot = null;\n    this.solutionSize = 0;\n    this.solution = null;\n  }\n}\n\nBlock.HEADER_BYTE_SIZE = 80;\nBlock.ZCASH_HEADER_BYTE_SIZE = 1487;\n\nBlock.fromBuffer = function (buffer, network) {\n  if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n  network = network || networks.bitcoin;\n  var bufferReader = new bufferutils.BufferReader(buffer);\n  var block = new Block(network);\n  block.version = bufferReader.readInt32();\n  block.prevHash = bufferReader.readSlice(32);\n  block.merkleRoot = bufferReader.readSlice(32);\n\n  if (coins.isZcash(network)) {\n    block.finalSaplingRoot = bufferReader.readSlice(32);\n  }\n\n  block.timestamp = bufferReader.readUInt32();\n  block.bits = bufferReader.readUInt32();\n\n  if (coins.isZcash(network)) {\n    block.nonce = bufferReader.readSlice(32);\n    block.solutionSize = bufferReader.readVarInt();\n    block.solution = bufferReader.readSlice(1344);\n  } else {\n    // Not sure sure why the nonce is read as UInt 32 and not as a slice\n    block.nonce = bufferReader.readUInt32();\n  }\n\n  if (bufferReader.buffer.length === 80) return block;\n\n  function readTransaction() {\n    var tx = Transaction.fromBuffer(buffer.slice(bufferReader.offset), network, true);\n    bufferReader.offset += tx.byteLength();\n    return tx;\n  }\n\n  var nTransactions = bufferReader.readVarInt();\n  block.transactions = [];\n\n  for (var i = 0; i < nTransactions; ++i) {\n    var tx = readTransaction();\n    block.transactions.push(tx);\n  }\n\n  return block;\n};\n\nBlock.prototype.byteLength = function (headersOnly) {\n  if (coins.isZcash(this.network)) {\n    if (headersOnly) {\n      return Block.ZCASH_HEADER_BYTE_SIZE;\n    }\n\n    return Block.ZCASH_HEADER_BYTE_SIZE + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n      return a + x.byteLength();\n    }, 0);\n  }\n\n  if (headersOnly || !this.transactions) return Block.HEADER_BYTE_SIZE;\n  return Block.HEADER_BYTE_SIZE + varuint.encodingLength(this.transactions.length) + this.transactions.reduce(function (a, x) {\n    return a + x.byteLength();\n  }, 0);\n};\n\nBlock.fromHex = function (hex, network) {\n  return Block.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nBlock.prototype.getHash = function () {\n  return bcrypto.hash256(this.toBuffer(true));\n};\n\nBlock.prototype.getId = function () {\n  return this.getHash().reverse().toString('hex');\n};\n\nBlock.prototype.getUTCDate = function () {\n  var date = new Date(0); // epoch\n\n  date.setUTCSeconds(this.timestamp);\n  return date;\n}; // TODO: buffer, offset compatibility\n\n\nBlock.prototype.toBuffer = function (headersOnly) {\n  var buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n  var bufferWriter = new bufferutils.BufferWriter(buffer);\n  bufferWriter.writeInt32(this.version);\n  bufferWriter.writeSlice(this.prevHash);\n  bufferWriter.writeSlice(this.merkleRoot);\n\n  if (coins.isZcash(this.network)) {\n    bufferWriter.writeSlice(this.finalSaplingRoot);\n  }\n\n  bufferWriter.writeUInt32(this.timestamp);\n  bufferWriter.writeUInt32(this.bits);\n\n  if (coins.isZcash(this.network)) {\n    bufferWriter.writeSlice(this.nonce); // TODO: use writeVarInt\n\n    varuint.encode(this.solutionSize, bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += varuint.encode.bytes;\n    bufferWriter.writeSlice(this.solution);\n  } else {\n    // Not sure sure why the nonce is interpreted as UInt 32 and not a slice in bitcoin\n    bufferWriter.writeUInt32(this.nonce);\n  }\n\n  if (headersOnly || !this.transactions) return buffer; // TODO: use writeVarInt\n\n  varuint.encode(this.transactions.length, bufferWriter.buffer, bufferWriter.offset);\n  bufferWriter.offset += varuint.encode.bytes; // TODO: use writeVarInt\n\n  this.transactions.forEach(function (tx) {\n    var txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n    tx.toBuffer(bufferWriter.buffer, bufferWriter.offset);\n    bufferWriter.offset += txSize;\n  });\n  return buffer;\n};\n\nBlock.prototype.toHex = function (headersOnly) {\n  return this.toBuffer(headersOnly).toString('hex');\n};\n\nBlock.calculateTarget = function (bits) {\n  var exponent = ((bits & 0xff000000) >> 24) - 3;\n  var mantissa = bits & 0x007fffff;\n  var target = Buffer.alloc(32, 0);\n\n  if (exponent < 0) {\n    // If it is negative, we will overflow the target buffer so we have to slice the mantissa to fit\n    mantissa = mantissa >> 8 * Math.abs(exponent);\n    target.writeUInt32BE(mantissa, 28);\n  } else if (exponent > 28) {\n    // If it is greater than 28, we need to shift the mantissa since the offset cannot be greater than 32 - 4\n    // (safe-buffer restriction)\n    mantissa <<= 8 * (exponent - 28);\n    target.writeUInt32BE(mantissa, 0);\n  } else {\n    target.writeUInt32BE(mantissa, 28 - exponent);\n  }\n\n  return target;\n};\n\nBlock.calculateMerkleRoot = function (transactions) {\n  typeforce([{\n    getHash: types.Function\n  }], transactions);\n  if (transactions.length === 0) throw TypeError('Cannot compute merkle root for zero transactions');\n  var hashes = transactions.map(function (transaction) {\n    return transaction.getHash();\n  });\n  return fastMerkleRoot(hashes, bcrypto.hash256);\n};\n\nBlock.prototype.checkMerkleRoot = function () {\n  if (!this.transactions) return false;\n  var actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n  return this.merkleRoot.compare(actualMerkleRoot) === 0;\n};\n\nBlock.prototype.checkProofOfWork = function () {\n  var hash = this.getHash().reverse();\n  var target = Block.calculateTarget(this.bits);\n  return hash.compare(target) <= 0;\n};\n\nmodule.exports = Block;","map":null,"metadata":{},"sourceType":"script"}