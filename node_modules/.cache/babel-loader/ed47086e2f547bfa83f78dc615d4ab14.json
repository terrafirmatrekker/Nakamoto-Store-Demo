{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar BN = require('../crypto/bn');\n\nvar BufferReader = function BufferReader(buf) {\n  if (!(this instanceof BufferReader)) {\n    return new BufferReader(buf);\n  }\n\n  if (_.isUndefined(buf)) {\n    return;\n  }\n\n  if (Buffer.isBuffer(buf)) {\n    this.set({\n      buf: buf\n    });\n  } else if (_.isString(buf)) {\n    this.set({\n      buf: new Buffer(buf, 'hex')\n    });\n  } else if (_.isObject(buf)) {\n    var obj = buf;\n    this.set(obj);\n  } else {\n    throw new TypeError('Unrecognized argument for BufferReader');\n  }\n};\n\nBufferReader.prototype.set = function (obj) {\n  this.buf = obj.buf || this.buf || undefined;\n  this.pos = obj.pos || this.pos || 0;\n  return this;\n};\n\nBufferReader.prototype.eof = function () {\n  return this.pos >= this.buf.length;\n};\n\nBufferReader.prototype.finished = BufferReader.prototype.eof;\n\nBufferReader.prototype.read = function (len) {\n  $.checkArgument(!_.isUndefined(len), 'Must specify a length');\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return buf;\n};\n\nBufferReader.prototype.readAll = function () {\n  var buf = this.buf.slice(this.pos, this.buf.length);\n  this.pos = this.buf.length;\n  return buf;\n};\n\nBufferReader.prototype.readUInt8 = function () {\n  var val = this.buf.readUInt8(this.pos);\n  this.pos = this.pos + 1;\n  return val;\n};\n\nBufferReader.prototype.readUInt16BE = function () {\n  var val = this.buf.readUInt16BE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt16LE = function () {\n  var val = this.buf.readUInt16LE(this.pos);\n  this.pos = this.pos + 2;\n  return val;\n};\n\nBufferReader.prototype.readUInt32BE = function () {\n  var val = this.buf.readUInt32BE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt32LE = function () {\n  var val = this.buf.readUInt32LE(this.pos);\n  this.pos = this.pos + 4;\n  return val;\n};\n\nBufferReader.prototype.readUInt64BEBN = function () {\n  var buf = this.buf.slice(this.pos, this.pos + 8);\n  var bn = BN.fromBuffer(buf);\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readUInt64LEBN = function () {\n  var second = this.buf.readUInt32LE(this.pos);\n  var first = this.buf.readUInt32LE(this.pos + 4);\n  var combined = first * 0x100000000 + second; // Instantiating an instance of BN with a number is faster than with an\n  // array or string. However, the maximum safe number for a double precision\n  // floating point is 2 ^ 52 - 1 (0x1fffffffffffff), thus we can safely use\n  // non-floating point numbers less than this amount (52 bits). And in the case\n  // that the number is larger, we can instatiate an instance of BN by passing\n  // an array from the buffer (slower) and specifying the endianness.\n\n  var bn;\n\n  if (combined <= 0x1fffffffffffff) {\n    bn = new BN(combined);\n  } else {\n    var data = Array.prototype.slice.call(this.buf, this.pos, this.pos + 8);\n    bn = new BN(data, 10, 'le');\n  }\n\n  this.pos = this.pos + 8;\n  return bn;\n};\n\nBufferReader.prototype.readVarintNum = function () {\n  var first = this.readUInt8();\n\n  switch (first) {\n    case 0xFD:\n      return this.readUInt16LE();\n\n    case 0xFE:\n      return this.readUInt32LE();\n\n    case 0xFF:\n      var bn = this.readUInt64LEBN();\n      var n = bn.toNumber();\n\n      if (n <= Math.pow(2, 53)) {\n        return n;\n      } else {\n        throw new Error('number too large to retain precision - use readVarintBN');\n      }\n\n      break;\n\n    default:\n      return first;\n  }\n};\n/**\n * reads a length prepended buffer\n */\n\n\nBufferReader.prototype.readVarLengthBuffer = function () {\n  var len = this.readVarintNum();\n  var buf = this.read(len);\n  $.checkState(buf.length === len, 'Invalid length while reading varlength buffer. ' + 'Expected to read: ' + len + ' and read ' + buf.length);\n  return buf;\n};\n\nBufferReader.prototype.readVarintBuf = function () {\n  var first = this.buf.readUInt8(this.pos);\n\n  switch (first) {\n    case 0xFD:\n      return this.read(1 + 2);\n\n    case 0xFE:\n      return this.read(1 + 4);\n\n    case 0xFF:\n      return this.read(1 + 8);\n\n    default:\n      return this.read(1);\n  }\n};\n\nBufferReader.prototype.readVarintBN = function () {\n  var first = this.readUInt8();\n\n  switch (first) {\n    case 0xFD:\n      return new BN(this.readUInt16LE());\n\n    case 0xFE:\n      return new BN(this.readUInt32LE());\n\n    case 0xFF:\n      return this.readUInt64LEBN();\n\n    default:\n      return new BN(first);\n  }\n};\n\nBufferReader.prototype.reverse = function () {\n  var buf = new Buffer(this.buf.length);\n\n  for (var i = 0; i < buf.length; i++) {\n    buf[i] = this.buf[this.buf.length - 1 - i];\n  }\n\n  this.buf = buf;\n  return this;\n};\n\nBufferReader.prototype.readReverse = function (len) {\n  if (_.isUndefined(len)) {\n    len = this.buf.length;\n  }\n\n  var buf = this.buf.slice(this.pos, this.pos + len);\n  this.pos = this.pos + len;\n  return BufferUtil.reverse(buf);\n};\n\nmodule.exports = BufferReader;","map":null,"metadata":{},"sourceType":"script"}