{"ast":null,"code":"import _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport BigNumber from \"bignumber.js\";\nimport { AbiCoder } from \"web3-eth-abi\";\nimport { assertType } from \"./assert\";\n/**\n * Represents 1 second for functions that accept a parameter in milliseconds.\n */\n\nexport var SECONDS = 1000;\n/**\n * Pauses the thread for the specified number of milliseconds.\n *\n * @param ms The number of milliseconds to pause for.\n */\n\nexport var sleep =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(ms) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve) {\n              return setTimeout(resolve, ms);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function sleep(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Remove 0x prefix from a hex string. If the input doesn't have a 0x prefix,\n * it's returned unchanged.\n *\n * @param hex The hex value to be prefixed.\n */\n\nexport var strip0x = function strip0x(hex) {\n  // Type validation\n  assertType(\"string\", {\n    hex: hex\n  });\n  return hex.substring(0, 2) === \"0x\" ? hex.slice(2) : hex;\n};\n/**\n * Add a 0x prefix to a hex value, converting to a string first. If the input\n * is already prefixed, it's returned unchanged.\n *\n * @param hex The hex value to be prefixed.\n */\n\nexport var Ox = function Ox(hex) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    prefix: \"0x\"\n  },\n      prefix = _ref2.prefix;\n\n  var hexString = typeof hex === \"string\" ? hex : hex.toString(\"hex\");\n  return hexString.substring(0, 2) === prefix ? hexString : \"\".concat(prefix).concat(hexString);\n};\nexport var fromHex = function fromHex(hex) {\n  assertType(\"Buffer | string\", {\n    hex: hex\n  });\n  return Buffer.isBuffer(hex) ? hex : Buffer.from(strip0x(hex), \"hex\");\n};\nexport var fromBase64 = function fromBase64(base64) {\n  assertType(\"Buffer | string\", {\n    base64: base64\n  });\n  return Buffer.isBuffer(base64) ? base64 : Buffer.from(base64, \"base64\");\n};\nexport var toBase64 = function toBase64(input) {\n  assertType(\"Buffer\", {\n    input: input\n  });\n  return input.toString(\"base64\");\n};\nexport var fromBigNumber = function fromBigNumber(bn) {\n  var bnStr = bn.toString(16); // Pad if necessary\n\n  return Buffer.from(bnStr.length % 2 ? \"0\" + bnStr : bnStr, \"hex\");\n}; // Unpadded alternate base64 encoding defined in RFC 4648, commonly used in\n// URLs.\n\nexport var toURLBase64 = function toURLBase64(input) {\n  assertType(\"Buffer | string\", {\n    input: input\n  });\n  return (Buffer.isBuffer(input) ? input : fromHex(input)).toString(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/\\=+$/, \"\");\n};\nexport var toReadable = function toReadable(value, decimals) {\n  return new BigNumber(value).dividedBy(new BigNumber(10).exponentiatedBy(decimals));\n};\nexport var fromReadable = function fromReadable(value, decimals) {\n  return new BigNumber(value).times(new BigNumber(10).exponentiatedBy(decimals)).decimalPlaces(0);\n};\n\nvar hasOwnProperty = function hasOwnProperty( // eslint-disable-next-line @typescript-eslint/no-explicit-any\nobject, property) {\n  return object.hasOwnProperty(property);\n};\n\nvar invalidError = function invalidError(errorMessage) {\n  return errorMessage === \"\" || errorMessage === \"null\" || errorMessage === \"undefined\";\n}; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nexport var extractError = function extractError(error) {\n  if (error && typeof error === \"object\") {\n    if (hasOwnProperty(error, \"response\") && error.response) {\n      var extractedError = extractError(error.response);\n\n      if (!invalidError(extractedError)) {\n        return extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"data\") && error.data) {\n      var _extractedError = extractError(error.data);\n\n      if (!invalidError(_extractedError)) {\n        return _extractedError;\n      }\n    }\n\n    if (hasOwnProperty(error, \"error\") && error.error) {\n      var _extractedError2 = extractError(error.error);\n\n      if (!invalidError(_extractedError2)) {\n        return _extractedError2;\n      }\n    }\n\n    if (hasOwnProperty(error, \"context\") && error.context) {\n      var _extractedError3 = extractError(error.context);\n\n      if (!invalidError(_extractedError3)) {\n        return _extractedError3;\n      }\n    }\n\n    if (hasOwnProperty(error, \"message\") && error.message) {\n      var _extractedError4 = extractError(error.message);\n\n      if (!invalidError(_extractedError4)) {\n        return _extractedError4;\n      }\n    }\n\n    if (hasOwnProperty(error, \"statusText\") && error.statusText) {\n      var _extractedError5 = extractError(error.statusText);\n\n      if (!invalidError(_extractedError5)) {\n        return _extractedError5;\n      }\n    }\n  }\n\n  try {\n    if (typeof error === \"string\") {\n      if (error.slice(0, 7) === \"Error: \") {\n        error = error.slice(7);\n      }\n\n      return error;\n    }\n\n    return JSON.stringify(error);\n  } catch (innerError) {// Ignore JSON error\n  }\n\n  return String(error);\n};\nexport var retryNTimes =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(fnCall, retries) {\n    var timeout,\n        logger,\n        returnError,\n        errorMessages,\n        i,\n        errorMessage,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            timeout = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : 1 * SECONDS;\n            // in ms\n            logger = _args2.length > 3 ? _args2[3] : undefined;\n            errorMessages = new Set();\n            i = 0;\n\n          case 4:\n            if (!(retries === -1 || i < retries)) {\n              _context2.next = 23;\n              break;\n            }\n\n            _context2.prev = 5;\n            _context2.next = 8;\n            return fnCall();\n\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](5);\n            // Fix error message.\n            errorMessage = extractError(_context2.t0);\n            errorMessages.add(errorMessage);\n            returnError = _context2.t0;\n\n            if (!(i < retries || retries === -1)) {\n              _context2.next = 20;\n              break;\n            }\n\n            _context2.next = 19;\n            return sleep(timeout);\n\n          case 19:\n            if (logger) {\n              logger.warn(_context2.t0);\n            }\n\n          case 20:\n            i++;\n            _context2.next = 4;\n            break;\n\n          case 23:\n            returnError.message = Array.from(errorMessages).join(\", \");\n            throw returnError;\n\n          case 25:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[5, 11]]);\n  }));\n\n  return function retryNTimes(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Generates a random hex string (prefixed with '0x').\n *\n * @param bytes The number of bytes to generate.\n */\n\nexport var randomBytes = function randomBytes(bytes) {\n  try {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (window) {\n      var uints = new Uint32Array(bytes / 4); // 4 bytes (32 bits)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n\n      window.crypto.getRandomValues(uints);\n      var str = \"\";\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = uints[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var uint = _step.value;\n          str += \"0\".repeat(8 - uint.toString(16).length) + String(uint.toString(16));\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return fromHex(str);\n    }\n  } catch (error) {} // Ignore error\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\n  var crypto = require(\"crypto\");\n\n  return crypto.randomBytes(bytes);\n};\n/**\n * Returns a random 32 byte Buffer.\n */\n\nexport var randomNonce = function randomNonce() {\n  return randomBytes(32);\n};\nexport var emptyNonce = function emptyNonce() {\n  return fromHex(\"00\".repeat(32));\n};\nexport var rawEncode = function rawEncode(types, parameters) {\n  return fromHex(new AbiCoder().encodeParameters(types, parameters));\n};\n/**\n * isDefined returns true if the parameter is defined and not null.\n */\n\nexport var isDefined = function isDefined(x) {\n  return x !== null && x !== undefined;\n};","map":null,"metadata":{},"sourceType":"module"}