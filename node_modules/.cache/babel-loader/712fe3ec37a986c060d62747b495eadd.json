{"ast":null,"code":"import _defineProperty from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar _Network$Mainnet, _Network$Testnet, _Format$Legacy, _Network$Mainnet2, _Network$Testnet2, _Format$Bitpay, _VERSION_BYTE;\n\n// MIT License\n// Copyright (c) 2018-2020 Emilio Almansi\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nimport { InvalidAddressError } from \"bchaddrjs\";\nimport cashaddr, { ValidationError } from \"cashaddrjs\";\nimport bs58check from \"bs58check\";\nvar Format;\n\n(function (Format) {\n  Format[\"Legacy\"] = \"legacy\";\n  Format[\"Bitpay\"] = \"bitpay\";\n  Format[\"Cashaddr\"] = \"cashaddr\";\n})(Format || (Format = {}));\n\nvar Network;\n\n(function (Network) {\n  Network[\"Mainnet\"] = \"mainnet\";\n  Network[\"Testnet\"] = \"testnet\";\n})(Network || (Network = {}));\n\nvar Type;\n\n(function (Type) {\n  Type[\"P2PKH\"] = \"p2pkh\";\n  Type[\"P2SH\"] = \"p2sh\";\n})(Type || (Type = {}));\n\nvar VERSION_BYTE = (_VERSION_BYTE = {}, _defineProperty(_VERSION_BYTE, Format.Legacy, (_Format$Legacy = {}, _defineProperty(_Format$Legacy, Network.Mainnet, (_Network$Mainnet = {}, _defineProperty(_Network$Mainnet, Type.P2PKH, 0), _defineProperty(_Network$Mainnet, Type.P2SH, 5), _Network$Mainnet)), _defineProperty(_Format$Legacy, Network.Testnet, (_Network$Testnet = {}, _defineProperty(_Network$Testnet, Type.P2PKH, 111), _defineProperty(_Network$Testnet, Type.P2SH, 196), _Network$Testnet)), _Format$Legacy)), _defineProperty(_VERSION_BYTE, Format.Bitpay, (_Format$Bitpay = {}, _defineProperty(_Format$Bitpay, Network.Mainnet, (_Network$Mainnet2 = {}, _defineProperty(_Network$Mainnet2, Type.P2PKH, 28), _defineProperty(_Network$Mainnet2, Type.P2SH, 40), _Network$Mainnet2)), _defineProperty(_Format$Bitpay, Network.Testnet, (_Network$Testnet2 = {}, _defineProperty(_Network$Testnet2, Type.P2PKH, 111), _defineProperty(_Network$Testnet2, Type.P2SH, 196), _Network$Testnet2)), _Format$Bitpay)), _VERSION_BYTE);\nvar BASE_58_CHECK_PAYLOAD_LENGTH = 21;\n\nvar decodeBase58Address = function decodeBase58Address(address) {\n  try {\n    var payload = bs58check.decode(address);\n\n    if (payload.length !== BASE_58_CHECK_PAYLOAD_LENGTH) {\n      throw new InvalidAddressError();\n    }\n\n    var versionByte = payload[0];\n    var hash = Array.prototype.slice.call(payload, 1);\n\n    switch (versionByte) {\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Legacy][Network.Testnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Legacy,\n          network: Network.Testnet,\n          type: Type.P2SH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2PKH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2PKH\n        };\n\n      case VERSION_BYTE[Format.Bitpay][Network.Mainnet][Type.P2SH]:\n        return {\n          hash: hash,\n          format: Format.Bitpay,\n          network: Network.Mainnet,\n          type: Type.P2SH\n        };\n    }\n  } catch (error) {// Ignore error.\n  }\n\n  throw new InvalidAddressError();\n};\n\nvar decodeCashAddressWithPrefix = function decodeCashAddressWithPrefix(address) {\n  try {\n    var decoded = cashaddr.decode(address);\n    var hash = Array.prototype.slice.call(decoded.hash, 0);\n    var type = decoded.type === \"P2PKH\" ? Type.P2PKH : Type.P2SH;\n\n    switch (decoded.prefix) {\n      case \"bitcoincash\":\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Mainnet,\n          type: type\n        };\n\n      case \"bchtest\":\n      case \"bchreg\":\n        return {\n          hash: hash,\n          format: Format.Cashaddr,\n          network: Network.Testnet,\n          type: type\n        };\n    }\n  } catch (error) {// Ignore error.\n  }\n\n  throw new InvalidAddressError();\n};\n\nvar decodeCashAddress = function decodeCashAddress(address) {\n  if (address.indexOf(\":\") !== -1) {\n    try {\n      return decodeCashAddressWithPrefix(address);\n    } catch (error) {// Ignore error.\n    }\n  } else {\n    var prefixes = [\"bitcoincash\", \"bchtest\", \"bchreg\"];\n\n    for (var i = 0; i < prefixes.length; ++i) {\n      try {\n        var prefix = prefixes[i];\n        return decodeCashAddressWithPrefix(prefix + \":\" + address);\n      } catch (error) {// Ignore error.\n      }\n    }\n  }\n\n  throw new InvalidAddressError();\n};\n\nvar getTypeBits = function getTypeBits(type) {\n  switch (type.toLowerCase()) {\n    case Type.P2PKH:\n      return 0;\n\n    case Type.P2SH:\n      return 8;\n\n    default:\n      throw new ValidationError(\"Invalid type: \" + type + \".\");\n  }\n};\n\nexport var decodeBitcoinCashAddress = function decodeBitcoinCashAddress(address) {\n  try {\n    return Buffer.from(decodeBase58Address(address).hash);\n  } catch (error) {// Ignore error.\n  }\n\n  try {\n    var _decodeCashAddress = decodeCashAddress(address),\n        hash = _decodeCashAddress.hash,\n        type = _decodeCashAddress.type;\n\n    return Buffer.concat([Buffer.from([getTypeBits(type)]), Buffer.from(hash)]);\n  } catch (error) {// Ignore error.\n  }\n\n  throw new InvalidAddressError();\n};","map":null,"metadata":{},"sourceType":"module"}