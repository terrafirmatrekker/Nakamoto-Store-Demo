{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bcrypto = require('./crypto');\n\nvar bscript = require('./script');\n\nvar _require = require('./bufferutils'),\n    BufferReader = _require.BufferReader,\n    BufferWriter = _require.BufferWriter;\n\nvar _require2 = require('./forks/zcash/bufferutils'),\n    ZcashBufferReader = _require2.ZcashBufferReader,\n    ZcashBufferWriter = _require2.ZcashBufferWriter;\n\nvar coins = require('./coins');\n\nvar opcodes = require('bitcoin-ops');\n\nvar networks = require('./networks');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar varuint = require('varuint-bitcoin');\n\nvar blake2b = require('blake2b');\n\nvar zcashVersion = require('./forks/zcash/version');\n\nfunction varSliceSize(someScript) {\n  var length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\n\nfunction vectorSize(someVector) {\n  var length = someVector.length;\n  return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {\n    return sum + varSliceSize(witness);\n  }, 0);\n} // By default, assume is a bitcoin transaction\n\n\nfunction Transaction() {\n  var network = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : networks.bitcoin;\n  this.version = 1;\n  this.locktime = 0;\n  this.ins = [];\n  this.outs = [];\n  this.network = network;\n\n  if (coins.isZcash(network)) {\n    // ZCash version >= 2\n    this.joinsplits = [];\n    this.joinsplitPubkey = [];\n    this.joinsplitSig = []; // ZCash version >= 3\n\n    this.overwintered = 0; // 1 if the transaction is post overwinter upgrade, 0 otherwise\n\n    this.versionGroupId = 0; // 0x03C48270 (63210096) for overwinter and 0x892F2085 (2301567109) for sapling\n\n    this.expiryHeight = 0; // Block height after which this transactions will expire, or 0 to disable expiry\n    // ZCash version >= 4\n\n    this.valueBalance = 0;\n    this.vShieldedSpend = [];\n    this.vShieldedOutput = [];\n    this.bindingSig = 0;\n  }\n\n  if (coins.isDash(network)) {\n    // Dash version = 3\n    this.type = 0;\n    this.extraPayload = Buffer.alloc(0);\n  }\n}\n\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_BITCOINCASHBIP143 = 0x40;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\nvar EMPTY_SCRIPT = Buffer.allocUnsafe(0);\nvar EMPTY_WITNESS = [];\nvar ZERO = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');\nvar ONE = Buffer.from('0000000000000000000000000000000000000000000000000000000000000001', 'hex'); // Used to represent the absence of a value\n\nvar VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nvar BLANK_OUTPUT = {\n  script: EMPTY_SCRIPT,\n  valueBuffer: VALUE_UINT64_MAX\n};\nTransaction.DASH_NORMAL = 0;\nTransaction.DASH_PROVIDER_REGISTER = 1;\nTransaction.DASH_PROVIDER_UPDATE_SERVICE = 2;\nTransaction.DASH_PROVIDER_UPDATE_REGISTRAR = 3;\nTransaction.DASH_PROVIDER_UPDATE_REVOKE = 4;\nTransaction.DASH_COINBASE = 5;\nTransaction.DASH_QUORUM_COMMITMENT = 6;\n\nTransaction.fromBuffer = function (buffer) {\n  var network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : networks.bitcoin;\n\n  var __noStrict = arguments.length > 2 ? arguments[2] : undefined;\n\n  var bufferReader = new BufferReader(buffer);\n  var tx = new Transaction(network);\n  tx.version = bufferReader.readInt32();\n\n  if (coins.isZcash(network)) {\n    // Split the header into fOverwintered and nVersion\n    tx.overwintered = tx.version >>> 31; // Must be 1 for version 3 and up\n\n    tx.version = tx.version & 0x07FFFFFFF; // 3 for overwinter\n\n    if (!network.consensusBranchId.hasOwnProperty(tx.version)) {\n      throw new Error('Unsupported Zcash transaction');\n    }\n\n    bufferReader = new ZcashBufferReader(bufferReader.buffer, bufferReader.offset, tx.version);\n  }\n\n  if (coins.isDash(network)) {\n    tx.type = tx.version >> 16;\n    tx.version = tx.version & 0xffff;\n\n    if (tx.version === 3 && (tx.type < Transaction.DASH_NORMAL || tx.type > Transaction.DASH_QUORUM_COMMITMENT)) {\n      throw new Error('Unsupported Dash transaction type');\n    }\n  }\n\n  var marker = bufferReader.readUInt8();\n  var flag = bufferReader.readUInt8();\n  var hasWitnesses = false;\n\n  if (marker === Transaction.ADVANCED_TRANSACTION_MARKER && flag === Transaction.ADVANCED_TRANSACTION_FLAG && !coins.isZcash(network)) {\n    hasWitnesses = true;\n  } else {\n    bufferReader.offset -= 2;\n  }\n\n  if (tx.isOverwinterCompatible()) {\n    tx.versionGroupId = bufferReader.readUInt32();\n  }\n\n  var vinLen = bufferReader.readVarInt();\n\n  for (var i = 0; i < vinLen; ++i) {\n    tx.ins.push({\n      hash: bufferReader.readSlice(32),\n      index: bufferReader.readUInt32(),\n      script: bufferReader.readVarSlice(),\n      sequence: bufferReader.readUInt32(),\n      witness: EMPTY_WITNESS\n    });\n  }\n\n  var voutLen = bufferReader.readVarInt();\n\n  for (i = 0; i < voutLen; ++i) {\n    tx.outs.push({\n      value: bufferReader.readUInt64(),\n      script: bufferReader.readVarSlice()\n    });\n  }\n\n  if (hasWitnesses) {\n    for (i = 0; i < vinLen; ++i) {\n      tx.ins[i].witness = bufferReader.readVector();\n    } // was this pointless?\n\n\n    if (!tx.hasWitnesses()) throw new Error('Transaction has superfluous witness data');\n  }\n\n  tx.locktime = bufferReader.readUInt32();\n\n  if (coins.isZcash(network)) {\n    if (tx.isOverwinterCompatible()) {\n      tx.expiryHeight = bufferReader.readUInt32();\n    }\n\n    if (tx.isSaplingCompatible()) {\n      tx.valueBalance = bufferReader.readInt64();\n      var nShieldedSpend = bufferReader.readVarInt();\n\n      for (i = 0; i < nShieldedSpend; ++i) {\n        tx.vShieldedSpend.push(bufferReader.readShieldedSpend());\n      }\n\n      var nShieldedOutput = bufferReader.readVarInt();\n\n      for (i = 0; i < nShieldedOutput; ++i) {\n        tx.vShieldedOutput.push(bufferReader.readShieldedOutput());\n      }\n    }\n\n    if (tx.supportsJoinSplits()) {\n      var joinSplitsLen = bufferReader.readVarInt();\n\n      for (i = 0; i < joinSplitsLen; ++i) {\n        tx.joinsplits.push(bufferReader.readJoinSplit());\n      }\n\n      if (joinSplitsLen > 0) {\n        tx.joinsplitPubkey = bufferReader.readSlice(32);\n        tx.joinsplitSig = bufferReader.readSlice(64);\n      }\n    }\n\n    if (tx.isSaplingCompatible() && tx.vShieldedSpend.length + tx.vShieldedOutput.length > 0) {\n      tx.bindingSig = bufferReader.readSlice(64);\n    }\n  }\n\n  if (tx.isDashSpecialTransaction()) {\n    tx.extraPayload = bufferReader.readVarSlice();\n  }\n\n  tx.network = network;\n  if (__noStrict) return tx;\n  if (bufferReader.offset !== buffer.length) throw new Error('Transaction has unexpected data');\n  return tx;\n};\n\nTransaction.fromHex = function (hex, network) {\n  return Transaction.fromBuffer(Buffer.from(hex, 'hex'), network);\n};\n\nTransaction.isCoinbaseHash = function (buffer) {\n  typeforce(types.Hash256bit, buffer);\n\n  for (var i = 0; i < 32; ++i) {\n    if (buffer[i] !== 0) return false;\n  }\n\n  return true;\n};\n\nTransaction.prototype.isSaplingCompatible = function () {\n  return coins.isZcash(this.network) && this.version >= zcashVersion.SAPLING;\n};\n\nTransaction.prototype.isOverwinterCompatible = function () {\n  return coins.isZcash(this.network) && this.version >= zcashVersion.OVERWINTER;\n};\n\nTransaction.prototype.supportsJoinSplits = function () {\n  return coins.isZcash(this.network) && this.version >= zcashVersion.JOINSPLITS_SUPPORT;\n};\n\nTransaction.prototype.versionSupportsDashSpecialTransactions = function () {\n  return coins.isDash(this.network) && this.version >= 3;\n};\n\nTransaction.prototype.isDashSpecialTransaction = function () {\n  return this.versionSupportsDashSpecialTransactions() && this.type !== Transaction.DASH_NORMAL;\n};\n\nTransaction.prototype.isCoinbase = function () {\n  return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);\n};\n\nTransaction.prototype.addInput = function (hash, index, sequence, scriptSig) {\n  typeforce(types.tuple(types.Hash256bit, types.UInt32, types.maybe(types.UInt32), types.maybe(types.Buffer)), arguments);\n\n  if (types.Null(sequence)) {\n    sequence = Transaction.DEFAULT_SEQUENCE;\n  } // Add the input and return the input's index\n\n\n  return this.ins.push({\n    hash: hash,\n    index: index,\n    script: scriptSig || EMPTY_SCRIPT,\n    sequence: sequence,\n    witness: EMPTY_WITNESS\n  }) - 1;\n};\n\nTransaction.prototype.addOutput = function (scriptPubKey, value) {\n  typeforce(types.tuple(types.Buffer, types.Satoshi), arguments); // Add the output and return the output's index\n\n  return this.outs.push({\n    script: scriptPubKey,\n    value: value\n  }) - 1;\n};\n\nTransaction.prototype.hasWitnesses = function () {\n  return this.ins.some(function (x) {\n    return x.witness.length !== 0;\n  });\n};\n\nTransaction.prototype.weight = function () {\n  var base = this.__byteLength(false);\n\n  var total = this.__byteLength(true);\n\n  return base * 3 + total;\n};\n\nTransaction.prototype.virtualSize = function () {\n  return Math.ceil(this.weight() / 4);\n};\n\nTransaction.prototype.byteLength = function () {\n  return this.__byteLength(true);\n};\n\nTransaction.prototype.getShieldedSpendByteLength = function () {\n  if (!this.isSaplingCompatible()) {\n    return 0;\n  }\n\n  var byteLength = 0;\n  byteLength += varuint.encodingLength(this.vShieldedSpend.length); // nShieldedSpend\n\n  byteLength += 384 * this.vShieldedSpend.length; // vShieldedSpend\n\n  return byteLength;\n};\n\nTransaction.prototype.getShieldedOutputByteLength = function () {\n  if (!this.isSaplingCompatible()) {\n    return 0;\n  }\n\n  var byteLength = 0;\n  byteLength += varuint.encodingLength(this.vShieldedOutput.length); // nShieldedOutput\n\n  byteLength += 948 * this.vShieldedOutput.length; // vShieldedOutput\n\n  return byteLength;\n};\n\nTransaction.prototype.getJoinSplitByteLength = function () {\n  if (!this.supportsJoinSplits()) {\n    return 0;\n  }\n\n  var joinSplitsLen = this.joinsplits.length;\n  var byteLength = 0;\n  byteLength += varuint.encodingLength(joinSplitsLen); // vJoinSplit\n\n  if (joinSplitsLen > 0) {\n    // Both pre and post Sapling JoinSplits are encoded with the following data:\n    // 8 vpub_old, 8 vpub_new, 32 anchor, joinSplitsLen * 32 nullifiers, joinSplitsLen * 32 commitments, 32 ephemeralKey\n    // 32 ephemeralKey, 32 randomSeed, joinsplit.macs.length * 32 vmacs\n    if (this.isSaplingCompatible()) {\n      byteLength += 1698 * joinSplitsLen; // vJoinSplit using JSDescriptionGroth16\n    } else {\n      byteLength += 1802 * joinSplitsLen; // vJoinSplit using JSDescriptionPHGR13\n    }\n\n    byteLength += 32; // joinSplitPubKey\n\n    byteLength += 64; // joinSplitSig\n  }\n\n  return byteLength;\n};\n\nTransaction.prototype.zcashTransactionByteLength = function () {\n  if (!coins.isZcash(this.network)) {\n    throw new Error('zcashTransactionByteLength can only be called when using Zcash network');\n  }\n\n  var byteLength = 0;\n  byteLength += 4; // Header\n\n  if (this.isOverwinterCompatible()) {\n    byteLength += 4; // nVersionGroupId\n  }\n\n  byteLength += varuint.encodingLength(this.ins.length); // tx_in_count\n\n  byteLength += this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0); // tx_in\n\n  byteLength += varuint.encodingLength(this.outs.length); // tx_out_count\n\n  byteLength += this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0); // tx_out\n\n  byteLength += 4; // lock_time\n\n  if (this.isOverwinterCompatible()) {\n    byteLength += 4; // nExpiryHeight\n  }\n\n  if (this.isSaplingCompatible()) {\n    byteLength += 8; // valueBalance\n\n    byteLength += this.getShieldedSpendByteLength();\n    byteLength += this.getShieldedOutputByteLength();\n  }\n\n  if (this.supportsJoinSplits()) {\n    byteLength += this.getJoinSplitByteLength();\n  }\n\n  if (this.isSaplingCompatible() && this.vShieldedSpend.length + this.vShieldedOutput.length > 0) {\n    byteLength += 64; // bindingSig\n  }\n\n  return byteLength;\n};\n\nTransaction.prototype.__byteLength = function (__allowWitness) {\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (coins.isZcash(this.network)) {\n    return this.zcashTransactionByteLength();\n  }\n\n  return (hasWitnesses ? 10 : 8) + varuint.encodingLength(this.ins.length) + varuint.encodingLength(this.outs.length) + this.ins.reduce(function (sum, input) {\n    return sum + 40 + varSliceSize(input.script);\n  }, 0) + this.outs.reduce(function (sum, output) {\n    return sum + 8 + varSliceSize(output.script);\n  }, 0) + (this.isDashSpecialTransaction() ? varSliceSize(this.extraPayload) : 0) + (hasWitnesses ? this.ins.reduce(function (sum, input) {\n    return sum + vectorSize(input.witness);\n  }, 0) : 0);\n};\n\nTransaction.prototype.clone = function () {\n  var newTx = new Transaction(this.network);\n  newTx.version = this.version;\n  newTx.locktime = this.locktime;\n  newTx.network = this.network;\n\n  if (coins.isDash(this.network)) {\n    newTx.type = this.type;\n    newTx.extraPayload = this.extraPayload;\n  }\n\n  if (this.isOverwinterCompatible()) {\n    newTx.overwintered = this.overwintered;\n    newTx.versionGroupId = this.versionGroupId;\n    newTx.expiryHeight = this.expiryHeight;\n  }\n\n  if (this.isSaplingCompatible()) {\n    newTx.valueBalance = this.valueBalance;\n  }\n\n  newTx.ins = this.ins.map(function (txIn) {\n    return {\n      hash: txIn.hash,\n      index: txIn.index,\n      script: txIn.script,\n      sequence: txIn.sequence,\n      witness: txIn.witness\n    };\n  });\n  newTx.outs = this.outs.map(function (txOut) {\n    return {\n      script: txOut.script,\n      value: txOut.value\n    };\n  });\n\n  if (this.isSaplingCompatible()) {\n    newTx.vShieldedSpend = this.vShieldedSpend.map(function (shieldedSpend) {\n      return {\n        cv: shieldedSpend.cv,\n        anchor: shieldedSpend.anchor,\n        nullifier: shieldedSpend.nullifier,\n        rk: shieldedSpend.rk,\n        zkproof: shieldedSpend.zkproof,\n        spendAuthSig: shieldedSpend.spendAuthSig\n      };\n    });\n    newTx.vShieldedOutput = this.vShieldedOutput.map(function (shieldedOutput) {\n      return {\n        cv: shieldedOutput.cv,\n        cmu: shieldedOutput.cmu,\n        ephemeralKey: shieldedOutput.ephemeralKey,\n        encCiphertext: shieldedOutput.encCiphertext,\n        outCiphertext: shieldedOutput.outCiphertext,\n        zkproof: shieldedOutput.zkproof\n      };\n    });\n  }\n\n  if (this.supportsJoinSplits()) {\n    newTx.joinsplits = this.joinsplits.map(function (txJoinsplit) {\n      return {\n        vpubOld: txJoinsplit.vpubOld,\n        vpubNew: txJoinsplit.vpubNew,\n        anchor: txJoinsplit.anchor,\n        nullifiers: txJoinsplit.nullifiers,\n        commitments: txJoinsplit.commitments,\n        ephemeralKey: txJoinsplit.ephemeralKey,\n        randomSeed: txJoinsplit.randomSeed,\n        macs: txJoinsplit.macs,\n        zkproof: txJoinsplit.zkproof,\n        ciphertexts: txJoinsplit.ciphertexts\n      };\n    });\n    newTx.joinsplitPubkey = this.joinsplitPubkey;\n    newTx.joinsplitSig = this.joinsplitSig;\n  }\n\n  if (this.isSaplingCompatible() && this.vShieldedSpend.length + this.vShieldedOutput.length > 0) {\n    newTx.bindingSig = this.bindingSig;\n  }\n\n  return newTx;\n};\n/**\n * Get Zcash header or version\n * @returns {number}\n */\n\n\nTransaction.prototype.getHeader = function () {\n  var mask = this.overwintered ? 1 : 0;\n  var header = this.version | mask << 31;\n  return header;\n};\n/**\n * Hash transaction for signing a specific input.\n *\n * Bitcoin uses a different hash for each signed transaction input.\n * This method copies the transaction, makes the necessary changes based on the\n * hashType, and then hashes the result.\n * This hash can then be used to sign the provided transaction input.\n */\n\n\nTransaction.prototype.hashForSignature = function (inIndex, prevOutScript, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number), arguments); // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n\n  if (inIndex >= this.ins.length) return ONE; // ignore OP_CODESEPARATOR\n\n  var ourScript = bscript.compile(bscript.decompile(prevOutScript).filter(function (x) {\n    return x !== opcodes.OP_CODESEPARATOR;\n  }));\n  var txTmp = this.clone(); // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n\n  if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n    txTmp.outs = []; // ignore sequence numbers (except at inIndex)\n\n    txTmp.ins.forEach(function (input, i) {\n      if (i === inIndex) return;\n      input.sequence = 0;\n    }); // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n    if (inIndex >= this.outs.length) return ONE; // truncate outputs after\n\n    txTmp.outs.length = inIndex + 1; // \"blank\" outputs before\n\n    for (var i = 0; i < inIndex; i++) {\n      txTmp.outs[i] = BLANK_OUTPUT;\n    } // ignore sequence numbers (except at inIndex)\n\n\n    txTmp.ins.forEach(function (input, y) {\n      if (y === inIndex) return;\n      input.sequence = 0;\n    });\n  } // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n\n\n  if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n    txTmp.ins = [txTmp.ins[inIndex]];\n    txTmp.ins[0].script = ourScript; // SIGHASH_ALL: only ignore input scripts\n  } else {\n    // \"blank\" others input scripts\n    txTmp.ins.forEach(function (input) {\n      input.script = EMPTY_SCRIPT;\n    });\n    txTmp.ins[inIndex].script = ourScript;\n  } // serialize and hash\n\n\n  var buffer = Buffer.allocUnsafe(txTmp.__byteLength(false) + 4);\n  buffer.writeInt32LE(hashType, buffer.length - 4);\n\n  txTmp.__toBuffer(buffer, 0, false);\n\n  return bcrypto.hash256(buffer);\n};\n/**\n * Blake2b hashing algorithm for Zcash\n * @param bufferToHash\n * @param personalization\n * @returns 256-bit BLAKE2b hash\n */\n\n\nTransaction.prototype.getBlake2bHash = function (bufferToHash, personalization) {\n  var out = Buffer.allocUnsafe(32);\n  return blake2b(out.length, null, null, Buffer.from(personalization)).update(bufferToHash).digest(out);\n};\n/**\n * Build a hash for all or none of the transaction inputs depending on the hashtype\n * @param hashType\n * @returns double SHA-256, 256-bit BLAKE2b hash or 256-bit zero if doesn't apply\n */\n\n\nTransaction.prototype.getPrevoutHash = function (hashType) {\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n    var bufferWriter = new BufferWriter(Buffer.allocUnsafe(36 * this.ins.length));\n    this.ins.forEach(function (txIn) {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n    });\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.buffer, 'ZcashPrevoutHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.buffer);\n  }\n\n  return ZERO;\n};\n/**\n * Build a hash for all or none of the transactions inputs sequence numbers depending on the hashtype\n * @param hashType\n * @returns double SHA-256, 256-bit BLAKE2b hash or 256-bit zero if doesn't apply\n */\n\n\nTransaction.prototype.getSequenceHash = function (hashType) {\n  if (!(hashType & Transaction.SIGHASH_ANYONECANPAY) && (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    var bufferWriter = new BufferWriter(Buffer.allocUnsafe(4 * this.ins.length));\n    this.ins.forEach(function (txIn) {\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.buffer, 'ZcashSequencHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.buffer);\n  }\n\n  return ZERO;\n};\n/**\n * Build a hash for one, all or none of the transaction outputs depending on the hashtype\n * @param hashType\n * @param inIndex\n * @returns double SHA-256, 256-bit BLAKE2b hash or 256-bit zero if doesn't apply\n */\n\n\nTransaction.prototype.getOutputsHash = function (hashType, inIndex) {\n  var bufferWriter;\n\n  if ((hashType & 0x1f) !== Transaction.SIGHASH_SINGLE && (hashType & 0x1f) !== Transaction.SIGHASH_NONE) {\n    // Find out the size of the outputs and write them\n    var txOutsSize = this.outs.reduce(function (sum, output) {\n      return sum + 8 + varSliceSize(output.script);\n    }, 0);\n    bufferWriter = new BufferWriter(Buffer.allocUnsafe(txOutsSize));\n    this.outs.forEach(function (out) {\n      bufferWriter.writeUInt64(out.value);\n      bufferWriter.writeVarSlice(out.script);\n    });\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.buffer, 'ZcashOutputsHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.buffer);\n  } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {\n    // Write only the output specified in inIndex\n    var output = this.outs[inIndex];\n    bufferWriter = new BufferWriter(Buffer.allocUnsafe(8 + varSliceSize(output.script)));\n    bufferWriter.writeUInt64(output.value);\n    bufferWriter.writeVarSlice(output.script);\n\n    if (coins.isZcash(this.network)) {\n      return this.getBlake2bHash(bufferWriter.buffer, 'ZcashOutputsHash');\n    }\n\n    return bcrypto.hash256(bufferWriter.buffer);\n  }\n\n  return ZERO;\n};\n/**\n * Hash transaction for signing a transparent transaction in Zcash. Protected transactions are not supported.\n * @param inIndex\n * @param prevOutScript\n * @param value\n * @param hashType\n * @returns double SHA-256 or 256-bit BLAKE2b hash\n */\n\n\nTransaction.prototype.hashForZcashSignature = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n\n  if (!coins.isZcash(this.network)) {\n    throw new Error('hashForZcashSignature can only be called when using Zcash network');\n  }\n\n  if (this.joinsplits.length > 0) {\n    throw new Error('Hash signature for Zcash protected transactions is not supported');\n  }\n\n  if (inIndex >= this.ins.length && inIndex !== VALUE_UINT64_MAX) {\n    throw new Error('Input index is out of range');\n  }\n\n  if (this.isOverwinterCompatible()) {\n    var hashPrevouts = this.getPrevoutHash(hashType);\n    var hashSequence = this.getSequenceHash(hashType);\n    var hashOutputs = this.getOutputsHash(hashType, inIndex);\n    var hashJoinSplits = ZERO;\n    var hashShieldedSpends = ZERO;\n    var hashShieldedOutputs = ZERO;\n    var bufferWriter;\n    var baseBufferSize = 0;\n    baseBufferSize += 4 * 5; // header, nVersionGroupId, lock_time, nExpiryHeight, hashType\n\n    baseBufferSize += 32 * 4; // 256 hashes: hashPrevouts, hashSequence, hashOutputs, hashJoinSplits\n\n    if (inIndex !== VALUE_UINT64_MAX) {\n      // If this hash is for a transparent input signature (i.e. not for txTo.joinSplitSig), we need extra space\n      baseBufferSize += 4 * 2; // input.index, input.sequence\n\n      baseBufferSize += 8; // value\n\n      baseBufferSize += 32; // input.hash\n\n      baseBufferSize += varSliceSize(prevOutScript); // prevOutScript\n    }\n\n    if (this.isSaplingCompatible()) {\n      baseBufferSize += 32 * 2; // hashShieldedSpends and hashShieldedOutputs\n\n      baseBufferSize += 8; // valueBalance\n    }\n\n    bufferWriter = new BufferWriter(Buffer.alloc(baseBufferSize));\n    bufferWriter.writeInt32(this.getHeader());\n    bufferWriter.writeUInt32(this.versionGroupId);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeSlice(hashJoinSplits);\n\n    if (this.isSaplingCompatible()) {\n      bufferWriter.writeSlice(hashShieldedSpends);\n      bufferWriter.writeSlice(hashShieldedOutputs);\n    }\n\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(this.expiryHeight);\n\n    if (this.isSaplingCompatible()) {\n      bufferWriter.writeUInt64(this.valueBalance);\n    }\n\n    bufferWriter.writeUInt32(hashType); // If this hash is for a transparent input signature (i.e. not for txTo.joinSplitSig):\n\n    if (inIndex !== VALUE_UINT64_MAX) {\n      // The input being signed (replacing the scriptSig with scriptCode + amount)\n      // The prevout may already be contained in hashPrevout, and the nSequence\n      // may already be contained in hashSequence.\n      var input = this.ins[inIndex];\n      bufferWriter.writeSlice(input.hash);\n      bufferWriter.writeUInt32(input.index);\n      bufferWriter.writeVarSlice(prevOutScript);\n      bufferWriter.writeUInt64(value);\n      bufferWriter.writeUInt32(input.sequence);\n    }\n\n    var personalization = Buffer.alloc(16);\n    var prefix = 'ZcashSigHash';\n    personalization.write(prefix);\n    personalization.writeUInt32LE(this.network.consensusBranchId[this.version], prefix.length);\n    return this.getBlake2bHash(bufferWriter.buffer, personalization);\n  } // TODO: support non overwinter transactions\n\n};\n\nTransaction.prototype.hashForWitnessV0 = function (inIndex, prevOutScript, value, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32), arguments);\n  var hashPrevouts = this.getPrevoutHash(hashType);\n  var hashSequence = this.getSequenceHash(hashType);\n  var hashOutputs = this.getOutputsHash(hashType, inIndex);\n  var bufferWriter = new BufferWriter(Buffer.allocUnsafe(156 + varSliceSize(prevOutScript)));\n  var input = this.ins[inIndex];\n  bufferWriter.writeUInt32(this.version);\n  bufferWriter.writeSlice(hashPrevouts);\n  bufferWriter.writeSlice(hashSequence);\n  bufferWriter.writeSlice(input.hash);\n  bufferWriter.writeUInt32(input.index);\n  bufferWriter.writeVarSlice(prevOutScript);\n  bufferWriter.writeUInt64(value);\n  bufferWriter.writeUInt32(input.sequence);\n  bufferWriter.writeSlice(hashOutputs);\n  bufferWriter.writeUInt32(this.locktime);\n  bufferWriter.writeUInt32(hashType);\n  return bcrypto.hash256(bufferWriter.buffer);\n};\n/**\n * Hash transaction for signing a specific input for Bitcoin Cash.\n */\n\n\nTransaction.prototype.hashForCashSignature = function (inIndex, prevOutScript, inAmount, hashType) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number, types.maybe(types.UInt53)), arguments); // This function works the way it does because Bitcoin Cash\n  // uses BIP143 as their replay protection, AND their algo\n  // includes `forkId | hashType`, AND since their forkId=0,\n  // this is a NOP, and has no difference to segwit. To support\n  // other forks, another parameter is required, and a new parameter\n  // would be required in the hashForWitnessV0 function, or\n  // it could be broken into two..\n  // BIP143 sighash activated in BitcoinCash via 0x40 bit\n\n  if (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n    }\n\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, hashType);\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, hashType);\n  }\n};\n/**\n * Hash transaction for signing a specific input for Bitcoin Gold.\n */\n\n\nTransaction.prototype.hashForGoldSignature = function (inIndex, prevOutScript, inAmount, hashType, sigVersion) {\n  typeforce(types.tuple(types.UInt32, types.Buffer,\n  /* types.UInt8 */\n  types.Number, types.maybe(types.UInt53)), arguments); // Bitcoin Gold also implements segregated witness\n  // therefore we can pull out the setting of nForkHashType\n  // and pass it into the functions.\n\n  var nForkHashType = hashType;\n  var fUseForkId = (hashType & Transaction.SIGHASH_BITCOINCASHBIP143) > 0;\n\n  if (fUseForkId) {\n    nForkHashType |= this.network.forkId << 8;\n  } // BIP143 sighash activated in BitcoinCash via 0x40 bit\n\n\n  if (sigVersion || fUseForkId) {\n    if (types.Null(inAmount)) {\n      throw new Error('Bitcoin Cash sighash requires value of input to be signed.');\n    }\n\n    return this.hashForWitnessV0(inIndex, prevOutScript, inAmount, nForkHashType);\n  } else {\n    return this.hashForSignature(inIndex, prevOutScript, nForkHashType);\n  }\n};\n\nTransaction.prototype.getHash = function () {\n  return bcrypto.hash256(this.__toBuffer(undefined, undefined, false));\n};\n\nTransaction.prototype.getId = function () {\n  // transaction hash's are displayed in reverse order\n  return this.getHash().reverse().toString('hex');\n};\n\nTransaction.prototype.toBuffer = function (buffer, initialOffset) {\n  return this.__toBuffer(buffer, initialOffset, true);\n};\n\nTransaction.prototype.__toBuffer = function (buffer, initialOffset, __allowWitness) {\n  if (!buffer) buffer = Buffer.allocUnsafe(this.__byteLength(__allowWitness));\n  var bufferWriter = coins.isZcash(this.network) ? new ZcashBufferWriter(buffer, initialOffset || 0) : new BufferWriter(buffer, initialOffset || 0);\n\n  function writeUInt16(i) {\n    bufferWriter.offset = bufferWriter.buffer.writeUInt16LE(i, bufferWriter.offset);\n  }\n\n  if (this.isOverwinterCompatible()) {\n    var mask = this.overwintered ? 1 : 0;\n    bufferWriter.writeInt32(this.version | mask << 31); // Set overwinter bit\n\n    bufferWriter.writeUInt32(this.versionGroupId);\n  } else if (this.isDashSpecialTransaction()) {\n    writeUInt16(this.version);\n    writeUInt16(this.type);\n  } else {\n    bufferWriter.writeInt32(this.version);\n  }\n\n  var hasWitnesses = __allowWitness && this.hasWitnesses();\n\n  if (hasWitnesses) {\n    bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n    bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n  }\n\n  bufferWriter.writeVarInt(this.ins.length);\n  this.ins.forEach(function (txIn) {\n    bufferWriter.writeSlice(txIn.hash);\n    bufferWriter.writeUInt32(txIn.index);\n    bufferWriter.writeVarSlice(txIn.script);\n    bufferWriter.writeUInt32(txIn.sequence);\n  });\n  bufferWriter.writeVarInt(this.outs.length);\n  this.outs.forEach(function (txOut) {\n    if (!txOut.valueBuffer) {\n      bufferWriter.writeUInt64(txOut.value);\n    } else {\n      bufferWriter.writeSlice(txOut.valueBuffer);\n    }\n\n    bufferWriter.writeVarSlice(txOut.script);\n  });\n\n  if (hasWitnesses) {\n    this.ins.forEach(function (input) {\n      bufferWriter.writeVector(input.witness);\n    });\n  }\n\n  bufferWriter.writeUInt32(this.locktime);\n\n  if (this.isOverwinterCompatible()) {\n    bufferWriter.writeUInt32(this.expiryHeight);\n  }\n\n  if (this.isSaplingCompatible()) {\n    bufferWriter.writeUInt64(this.valueBalance);\n    bufferWriter.writeVarInt(this.vShieldedSpend.length);\n    this.vShieldedSpend.forEach(function (shieldedSpend) {\n      bufferWriter.writeSlice(shieldedSpend.cv);\n      bufferWriter.writeSlice(shieldedSpend.anchor);\n      bufferWriter.writeSlice(shieldedSpend.nullifier);\n      bufferWriter.writeSlice(shieldedSpend.rk);\n      bufferWriter.writeSlice(shieldedSpend.zkproof.sA);\n      bufferWriter.writeSlice(shieldedSpend.zkproof.sB);\n      bufferWriter.writeSlice(shieldedSpend.zkproof.sC);\n      bufferWriter.writeSlice(shieldedSpend.spendAuthSig);\n    });\n    bufferWriter.writeVarInt(this.vShieldedOutput.length);\n    this.vShieldedOutput.forEach(function (shieldedOutput) {\n      bufferWriter.writeSlice(shieldedOutput.cv);\n      bufferWriter.writeSlice(shieldedOutput.cmu);\n      bufferWriter.writeSlice(shieldedOutput.ephemeralKey);\n      bufferWriter.writeSlice(shieldedOutput.encCiphertext);\n      bufferWriter.writeSlice(shieldedOutput.outCiphertext);\n      bufferWriter.writeSlice(shieldedOutput.zkproof.sA);\n      bufferWriter.writeSlice(shieldedOutput.zkproof.sB);\n      bufferWriter.writeSlice(shieldedOutput.zkproof.sC);\n    });\n  }\n\n  if (this.supportsJoinSplits()) {\n    bufferWriter.writeVarInt(this.joinsplits.length);\n    this.joinsplits.forEach(function (joinsplit) {\n      bufferWriter.writeUInt64(joinsplit.vpubOld);\n      bufferWriter.writeUInt64(joinsplit.vpubNew);\n      bufferWriter.writeSlice(joinsplit.anchor);\n      joinsplit.nullifiers.forEach(function (nullifier) {\n        bufferWriter.writeSlice(nullifier);\n      });\n      joinsplit.commitments.forEach(function (nullifier) {\n        bufferWriter.writeSlice(nullifier);\n      });\n      bufferWriter.writeSlice(joinsplit.ephemeralKey);\n      bufferWriter.writeSlice(joinsplit.randomSeed);\n      joinsplit.macs.forEach(function (nullifier) {\n        bufferWriter.writeSlice(nullifier);\n      });\n\n      if (this.isSaplingCompatible()) {\n        bufferWriter.writeSlice(joinsplit.zkproof.sA);\n        bufferWriter.writeSlice(joinsplit.zkproof.sB);\n        bufferWriter.writeSlice(joinsplit.zkproof.sC);\n      } else {\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gA);\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gAPrime);\n        bufferWriter.writeCompressedG2(joinsplit.zkproof.gB);\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gBPrime);\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gC);\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gCPrime);\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gK);\n        bufferWriter.writeCompressedG1(joinsplit.zkproof.gH);\n      }\n\n      joinsplit.ciphertexts.forEach(function (ciphertext) {\n        bufferWriter.writeSlice(ciphertext);\n      });\n    }, this);\n\n    if (this.joinsplits.length > 0) {\n      bufferWriter.writeSlice(this.joinsplitPubkey);\n      bufferWriter.writeSlice(this.joinsplitSig);\n    }\n  }\n\n  if (this.isSaplingCompatible() && this.vShieldedSpend.length + this.vShieldedOutput.length > 0) {\n    bufferWriter.writeSlice(this.bindingSig);\n  }\n\n  if (this.isDashSpecialTransaction()) {\n    bufferWriter.writeVarSlice(this.extraPayload);\n  }\n\n  if (initialOffset !== undefined) return buffer.slice(initialOffset, bufferWriter.offset); // avoid slicing unless necessary\n  // TODO (https://github.com/BitGo/bitgo-utxo-lib/issues/11): we shouldn't have to slice the final buffer\n\n  return buffer.slice(0, bufferWriter.offset);\n};\n\nTransaction.prototype.toHex = function () {\n  return this.toBuffer().toString('hex');\n};\n\nTransaction.prototype.setInputScript = function (index, scriptSig) {\n  typeforce(types.tuple(types.Number, types.Buffer), arguments);\n  this.ins[index].script = scriptSig;\n};\n\nTransaction.prototype.setWitness = function (index, witness) {\n  typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n  this.ins[index].witness = witness;\n};\n\nmodule.exports = Transaction;","map":null,"metadata":{},"sourceType":"script"}