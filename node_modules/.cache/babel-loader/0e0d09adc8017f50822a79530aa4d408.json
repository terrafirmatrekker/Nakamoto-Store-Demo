{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/tejas/Desktop/marketplace/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitgoUTXOLib = void 0;\n\nvar bitcoin = __importStar(require(\"bitgo-utxo-lib\"));\n\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nvar buildUTXO =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(network, privateKey, changeAddress, toAddress, valueIn, utxos, options) {\n    var fees, value, tx, _utxos$reduce, _utxos$reduce2, usedUTXOs, sum, change;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            fees = new bignumber_js_1.default(options && options.fee !== undefined ? options.fee : 10000);\n            value = options && options.subtractFee ? valueIn.minus(fees) : valueIn;\n\n            if (!value.lt(0)) {\n              _context.next = 4;\n              break;\n            }\n\n            throw new Error(\"Unable to include fee in value, fee exceeds value (\".concat(fees.toFixed(), \" > \").concat(valueIn.toFixed(), \")\"));\n\n          case 4:\n            tx = new bitcoin.TransactionBuilder(network);\n\n            if (options && options.version) {\n              tx.setVersion(options.version);\n            }\n\n            if (options && options.versionGroupID) {\n              tx.setVersionGroupId(0xf5b9230b);\n            }\n\n            if (options && options.expiryHeight) {\n              tx.setExpiryHeight(options.expiryHeight);\n            }\n\n            if (options && options.lockTime) {\n              tx.setLockTime(options.lockTime);\n            } // Only use the required utxos\n\n\n            _utxos$reduce = utxos.reduce(function (_ref2, utxo) {\n              var _ref3 = _slicedToArray(_ref2, 2),\n                  utxoAcc = _ref3[0],\n                  total = _ref3[1];\n\n              return total.lt(value.plus(fees)) ? [[].concat(_toConsumableArray(utxoAcc), [utxo]), total.plus(utxo.amount)] : [utxoAcc, total];\n            }, [[], new bignumber_js_1.default(0)]), _utxos$reduce2 = _slicedToArray(_utxos$reduce, 2), usedUTXOs = _utxos$reduce2[0], sum = _utxos$reduce2[1];\n\n            if (!sum.lt(value.plus(fees))) {\n              _context.next = 12;\n              break;\n            }\n\n            throw new Error(\"Insufficient balance to broadcast transaction\");\n\n          case 12:\n            // Add all inputs\n            usedUTXOs.map(function (utxo) {\n              tx.addInput(utxo.txHash, utxo.vOut);\n            });\n            change = sum.minus(value).minus(fees); // Add outputs\n\n            tx.addOutput(toAddress, value.toNumber());\n\n            if (change.gt(0)) {\n              tx.addOutput(changeAddress, change.toNumber());\n            } // Sign inputs\n\n\n            usedUTXOs.map(function (utxo, i) {\n              tx.sign(i, privateKey, \"\", options && options.signFlag !== undefined ? options.signFlag : null, utxo.amount);\n            });\n            return _context.abrupt(\"return\", tx.build());\n\n          case 18:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function buildUTXO(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar loadPrivateKey = function loadPrivateKey(network, privateKey) {\n  return bitcoin.ECPair.fromPrivateKeyBuffer(Buffer.from(privateKey, \"hex\"), network);\n};\n\nexports.BitgoUTXOLib = {\n  buildUTXO: buildUTXO,\n  loadPrivateKey: loadPrivateKey\n};","map":null,"metadata":{},"sourceType":"script"}