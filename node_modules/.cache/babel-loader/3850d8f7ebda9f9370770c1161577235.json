{"ast":null,"code":"var bip66 = require('bip66');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nvar BigInteger = require('bigi');\n\nfunction ECSignature(r, s) {\n  typeforce(types.tuple(types.BigInt, types.BigInt), arguments);\n  this.r = r;\n  this.s = s;\n}\n\nECSignature.parseCompact = function (buffer) {\n  typeforce(types.BufferN(65), buffer);\n  var flagByte = buffer.readUInt8(0) - 27;\n  if (flagByte !== (flagByte & 7)) throw new Error('Invalid signature parameter');\n  var compressed = !!(flagByte & 4);\n  var recoveryParam = flagByte & 3;\n  var signature = ECSignature.fromRSBuffer(buffer.slice(1));\n  return {\n    compressed: compressed,\n    i: recoveryParam,\n    signature: signature\n  };\n};\n\nECSignature.fromRSBuffer = function (buffer) {\n  typeforce(types.BufferN(64), buffer);\n  var r = BigInteger.fromBuffer(buffer.slice(0, 32));\n  var s = BigInteger.fromBuffer(buffer.slice(32, 64));\n  return new ECSignature(r, s);\n};\n\nECSignature.fromDER = function (buffer) {\n  var decode = bip66.decode(buffer);\n  var r = BigInteger.fromDERInteger(decode.r);\n  var s = BigInteger.fromDERInteger(decode.s);\n  return new ECSignature(r, s);\n}; // BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n\n\nECSignature.parseScriptSignature = function (buffer) {\n  var hashType = buffer.readUInt8(buffer.length - 1);\n  var hashTypeMod = hashType & ~0xc0;\n  if (hashTypeMod <= 0x00 || hashTypeMod >= 0x04) throw new Error('Invalid hashType ' + hashType);\n  return {\n    signature: ECSignature.fromDER(buffer.slice(0, -1)),\n    hashType: hashType\n  };\n};\n\nECSignature.prototype.toCompact = function (i, compressed) {\n  if (compressed) {\n    i += 4;\n  }\n\n  i += 27;\n  var buffer = Buffer.alloc(65);\n  buffer.writeUInt8(i, 0);\n  this.toRSBuffer(buffer, 1);\n  return buffer;\n};\n\nECSignature.prototype.toDER = function () {\n  var r = Buffer.from(this.r.toDERInteger());\n  var s = Buffer.from(this.s.toDERInteger());\n  return bip66.encode(r, s);\n};\n\nECSignature.prototype.toRSBuffer = function (buffer, offset) {\n  buffer = buffer || Buffer.alloc(64);\n  this.r.toBuffer(32).copy(buffer, offset);\n  this.s.toBuffer(32).copy(buffer, offset + 32);\n  return buffer;\n};\n\nECSignature.prototype.toScriptSignature = function (hashType) {\n  var hashTypeMod = hashType & ~0xc0;\n  if (hashTypeMod <= 0 || hashTypeMod >= 4) throw new Error('Invalid hashType ' + hashType);\n  var hashTypeBuffer = Buffer.alloc(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  return Buffer.concat([this.toDER(), hashTypeBuffer]);\n};\n\nmodule.exports = ECSignature;","map":null,"metadata":{},"sourceType":"script"}