{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Input = require('./input');\n\nvar Output = require('../output');\n\nvar $ = require('../../util/preconditions');\n\nvar Script = require('../../script');\n\nvar Signature = require('../../crypto/signature');\n\nvar Sighash = require('../sighash');\n\nvar PublicKey = require('../../publickey');\n\nvar BufferUtil = require('../../util/buffer');\n\nvar TransactionSignature = require('../signature');\n/**\n * @constructor\n */\n\n\nfunction MultiSigScriptHashInput(input, pubkeys, threshold, signatures) {\n  Input.apply(this, arguments);\n  var self = this;\n  pubkeys = pubkeys || input.publicKeys;\n  threshold = threshold || input.threshold;\n  signatures = signatures || input.signatures;\n  this.publicKeys = _.sortBy(pubkeys, function (publicKey) {\n    return publicKey.toString('hex');\n  });\n  this.redeemScript = Script.buildMultisigOut(this.publicKeys, threshold);\n  $.checkState(Script.buildScriptHashOut(this.redeemScript).equals(this.output.script), 'Provided public keys don\\'t hash to the provided output');\n  this.publicKeyIndex = {};\n\n  _.each(this.publicKeys, function (publicKey, index) {\n    self.publicKeyIndex[publicKey.toString()] = index;\n  });\n\n  this.threshold = threshold; // Empty array of signatures\n\n  this.signatures = signatures ? this._deserializeSignatures(signatures) : new Array(this.publicKeys.length);\n}\n\ninherits(MultiSigScriptHashInput, Input);\n\nMultiSigScriptHashInput.prototype.toObject = function () {\n  var obj = Input.prototype.toObject.apply(this, arguments);\n  obj.threshold = this.threshold;\n  obj.publicKeys = _.map(this.publicKeys, function (publicKey) {\n    return publicKey.toString();\n  });\n  obj.signatures = this._serializeSignatures();\n  return obj;\n};\n\nMultiSigScriptHashInput.prototype._deserializeSignatures = function (signatures) {\n  return _.map(signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return new TransactionSignature(signature);\n  });\n};\n\nMultiSigScriptHashInput.prototype._serializeSignatures = function () {\n  return _.map(this.signatures, function (signature) {\n    if (!signature) {\n      return undefined;\n    }\n\n    return signature.toObject();\n  });\n};\n\nMultiSigScriptHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype) {\n  $.checkState(this.output instanceof Output);\n  sigtype = sigtype || Signature.SIGHASH_ALL;\n  var self = this;\n  var results = [];\n\n  _.each(this.publicKeys, function (publicKey) {\n    if (publicKey.toString() === privateKey.publicKey.toString()) {\n      results.push(new TransactionSignature({\n        publicKey: privateKey.publicKey,\n        prevTxId: self.prevTxId,\n        outputIndex: self.outputIndex,\n        inputIndex: index,\n        signature: Sighash.sign(transaction, privateKey, sigtype, index, self.redeemScript),\n        sigtype: sigtype\n      }));\n    }\n  });\n\n  return results;\n};\n\nMultiSigScriptHashInput.prototype.addSignature = function (transaction, signature) {\n  $.checkState(!this.isFullySigned(), 'All needed signatures have already been added');\n  $.checkArgument(!_.isUndefined(this.publicKeyIndex[signature.publicKey.toString()]), 'Signature has no matching public key');\n  $.checkState(this.isValidSignature(transaction, signature));\n  this.signatures[this.publicKeyIndex[signature.publicKey.toString()]] = signature;\n\n  this._updateScript();\n\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._updateScript = function () {\n  this.setScript(Script.buildP2SHMultisigIn(this.publicKeys, this.threshold, this._createSignatures(), {\n    cachedMultisig: this.redeemScript\n  }));\n  return this;\n};\n\nMultiSigScriptHashInput.prototype._createSignatures = function () {\n  return _.map(_.filter(this.signatures, function (signature) {\n    return !_.isUndefined(signature);\n  }), function (signature) {\n    return BufferUtil.concat([signature.signature.toDER(), BufferUtil.integerAsSingleByteBuffer(signature.sigtype)]);\n  });\n};\n\nMultiSigScriptHashInput.prototype.clearSignatures = function () {\n  this.signatures = new Array(this.publicKeys.length);\n\n  this._updateScript();\n};\n\nMultiSigScriptHashInput.prototype.isFullySigned = function () {\n  return this.countSignatures() === this.threshold;\n};\n\nMultiSigScriptHashInput.prototype.countMissingSignatures = function () {\n  return this.threshold - this.countSignatures();\n};\n\nMultiSigScriptHashInput.prototype.countSignatures = function () {\n  return _.reduce(this.signatures, function (sum, signature) {\n    return sum + !!signature;\n  }, 0);\n};\n\nMultiSigScriptHashInput.prototype.publicKeysWithoutSignature = function () {\n  var self = this;\n  return _.filter(this.publicKeys, function (publicKey) {\n    return !self.signatures[self.publicKeyIndex[publicKey.toString()]];\n  });\n};\n\nMultiSigScriptHashInput.prototype.isValidSignature = function (transaction, signature) {\n  // FIXME: Refactor signature so this is not necessary\n  signature.signature.nhashtype = signature.sigtype;\n  return Sighash.verify(transaction, signature.signature, signature.publicKey, signature.inputIndex, this.redeemScript);\n};\n\nMultiSigScriptHashInput.OPCODES_SIZE = 7; // serialized size (<=3) + 0 .. N .. M OP_CHECKMULTISIG\n\nMultiSigScriptHashInput.SIGNATURE_SIZE = 74; // size (1) + DER (<=72) + sighash (1)\n\nMultiSigScriptHashInput.PUBKEY_SIZE = 34; // size (1) + DER (<=33)\n\nMultiSigScriptHashInput.prototype._estimateSize = function () {\n  return MultiSigScriptHashInput.OPCODES_SIZE + this.threshold * MultiSigScriptHashInput.SIGNATURE_SIZE + this.publicKeys.length * MultiSigScriptHashInput.PUBKEY_SIZE;\n};\n\nmodule.exports = MultiSigScriptHashInput;","map":null,"metadata":{},"sourceType":"script"}