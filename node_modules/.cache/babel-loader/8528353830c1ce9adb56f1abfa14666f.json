{"ast":null,"code":"var Buffer = require('safe-buffer').Buffer;\n\nvar bech32 = require('bech32');\n\nvar bs58check = require('bs58check');\n\nvar bscript = require('./script');\n\nvar btemplates = require('./templates');\n\nvar networks = require('./networks');\n\nvar typeforce = require('typeforce');\n\nvar types = require('./types');\n\nfunction fromBase58Check(address) {\n  var payload = bs58check.decode(address); // TODO: 4.0.0, move to \"toOutputScript\"\n\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 22) throw new TypeError(address + ' is too long');\n  var multibyte = payload.length === 22;\n  var offset = multibyte ? 2 : 1;\n  var version = multibyte ? payload.readUInt16BE(0) : payload[0];\n  var hash = payload.slice(offset);\n  return {\n    version: version,\n    hash: hash\n  };\n}\n\nfunction fromBech32(address) {\n  var result = bech32.decode(address);\n  var data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n}\n\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt16), arguments); // Zcash adds an extra prefix resulting in a bigger (22 bytes) payload. We identify them Zcash by checking if the\n  // version is multibyte (2 bytes instead of 1)\n\n  var multibyte = version > 0xff;\n  var size = multibyte ? 22 : 21;\n  var offset = multibyte ? 2 : 1;\n  var payload = Buffer.allocUnsafe(size);\n  multibyte ? payload.writeUInt16BE(version, 0) : payload.writeUInt8(version, 0);\n  hash.copy(payload, offset);\n  return bs58check.encode(payload);\n}\n\nfunction toBech32(data, version, prefix) {\n  var words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\n\nfunction fromOutputScript(outputScript, network) {\n  network = network || networks.bitcoin;\n  if (btemplates.pubKeyHash.output.check(outputScript)) return toBase58Check(bscript.compile(outputScript).slice(3, 23), network.pubKeyHash);\n  if (btemplates.scriptHash.output.check(outputScript)) return toBase58Check(bscript.compile(outputScript).slice(2, 22), network.scriptHash);\n  if (btemplates.witnessPubKeyHash.output.check(outputScript)) return toBech32(bscript.compile(outputScript).slice(2, 22), 0, network.bech32);\n  if (btemplates.witnessScriptHash.output.check(outputScript)) return toBech32(bscript.compile(outputScript).slice(2, 34), 0, network.bech32);\n  throw new Error(bscript.toASM(outputScript) + ' has no matching Address');\n}\n\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  var decode;\n\n  try {\n    decode = fromBase58Check(address);\n  } catch (e) {}\n\n  if (decode) {\n    if (decode.version === network.pubKeyHash) return btemplates.pubKeyHash.output.encode(decode.hash);\n    if (decode.version === network.scriptHash) return btemplates.scriptHash.output.encode(decode.hash);\n  } else {\n    try {\n      decode = fromBech32(address);\n    } catch (e) {}\n\n    if (decode) {\n      if (decode.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');\n\n      if (decode.version === 0) {\n        if (decode.data.length === 20) return btemplates.witnessPubKeyHash.output.encode(decode.data);\n        if (decode.data.length === 32) return btemplates.witnessScriptHash.output.encode(decode.data);\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script');\n}\n\nmodule.exports = {\n  fromBase58Check: fromBase58Check,\n  fromBech32: fromBech32,\n  fromOutputScript: fromOutputScript,\n  toBase58Check: toBase58Check,\n  toBech32: toBech32,\n  toOutputScript: toOutputScript\n};","map":null,"metadata":{},"sourceType":"script"}