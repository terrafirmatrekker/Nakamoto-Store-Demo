{"ast":null,"code":"import { LogLevel, NullLogger } from \"@renproject/interfaces\";\nimport BigNumber from \"bignumber.js\";\nimport { assertType } from \"./assert\";\nimport { fromHex, Ox } from \"./common\";\nimport { generateSighash } from \"./renVMHashes\";\nexport var signatureToBuffer = function signatureToBuffer(sig) {\n  return Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]);\n};\n\nvar switchV = function switchV(v) {\n  return v === 27 ? 28 : 27;\n}; // 28 - (v - 27);\n\n\nvar to32Bytes = function to32Bytes(bn) {\n  return fromHex((\"0\".repeat(64) + bn.toString(16)).slice(-64));\n};\n\nexport var secp256k1n = new BigNumber(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", 16);\nexport var fixSignatureSimple = function fixSignatureSimple(r, s, v) {\n  assertType(\"Buffer\", {\n    r: r,\n    s: s\n  });\n  var sBN = new BigNumber(Ox(s), 16);\n  var vFixed = (v || 0) % 27 + 27; // For a given key, there are two valid signatures for each signed message.\n  // We always take the one with the lower `s`.\n  // secp256k1n/2 = 57896044618658097711785492504343953926418782139537452191302581570759080747168.5\n\n  if (sBN.gt(secp256k1n.div(2))) {\n    // Take s = -s % secp256k1n\n    sBN = secp256k1n.minus(sBN); // Switch v\n\n    vFixed = switchV(vFixed);\n  }\n\n  return {\n    r: r,\n    s: to32Bytes(sBN),\n    v: vFixed\n  };\n};\nexport var fixSignature = function fixSignature(r, s, v, sigHash, pHash, amount, to, tokenIdentifier, nHash, v2) {\n  var logger = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : NullLogger;\n  // Type validation\n  assertType(\"string\", {\n    amount: amount,\n    to: to,\n    tokenIdentifier: tokenIdentifier\n  });\n  assertType(\"Buffer\", {\n    r: r,\n    s: s,\n    sigHash: sigHash,\n    pHash: pHash,\n    nHash: nHash\n  });\n\n  if (typeof logger.level !== \"number\" || logger.level >= LogLevel.Warn) {\n    var expectedSighash = generateSighash(pHash, amount, to, tokenIdentifier, nHash, v2, logger);\n\n    if (Ox(sigHash) !== Ox(expectedSighash)) {\n      logger.warn(\"Warning: unexpected signature hash returned from RenVM. Expected \".concat(Ox(expectedSighash), \", got \").concat(Ox(sigHash), \".\"));\n    }\n  } // TODO: Fix code below to check against proper mintAuthority\n  // // Currently, the wrong `v` value may be returned from RenVM. We recover the\n  // // address to see if we need to switch `v`. This can be removed once RenVM\n  // // has been updated.\n  // const recovered = {\n  //     [v]: pubToAddress(ecrecover(\n  //         fromHex(response.autogen.sighash)),\n  //         v,\n  //         fromHex(r),\n  //         s.toArrayLike(Buffer, \"be\", 32),\n  //     )),\n  //     [switchV(v)]: pubToAddress(ecrecover(\n  //         fromHex(response.autogen.sighash),\n  //         switchV(v),\n  //         fromHex(r),\n  //         s.toArrayLike(Buffer, \"be\", 32),\n  //     )),\n  // };\n  // const expected = fromHex(.network.renVM.mintAuthority);\n  // if (recovered[v].equals(expected)) {\n  //     // Do nothing\n  // } else if (recovered[switchV(v)].equals(expected)) {\n  //     console.info(\"[info][ren-js] switching v value\");\n  //     v = switchV(v);\n  // } else {\n  //     throw new Error(`Invalid signature - unable to recover mint authority from signature (Expected ${Ox(expected)}, got ${Ox(recovered[v])})`);\n  // }\n\n\n  return fixSignatureSimple(r, s, v);\n};","map":null,"metadata":{},"sourceType":"module"}