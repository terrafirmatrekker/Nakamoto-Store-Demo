{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\n\nvar Opcode = require('../opcode');\n\nvar BN = require('../crypto/bn');\n\nvar Hash = require('../crypto/hash');\n\nvar Signature = require('../crypto/signature');\n\nvar PublicKey = require('../publickey');\n\nvar ECDSA = require('../crypto/ecdsa');\n\nvar Schnorr = require('../crypto/schnorr');\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\n\n\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n * @param {number} satoshisBN - amount in satoshis of the input to be verified (when FORKID signhash is used)\n *\n * Translated from bitcoind's VerifyScript\n */\n\n\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags, satoshisBN) {\n  var Transaction = require('../transaction');\n\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  } // If FORKID is enabled, we also ensure strict encoding.\n\n\n  if (flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) {\n    flags |= Interpreter.SCRIPT_VERIFY_STRICTENC; // If FORKID is enabled, we need the input amount.\n\n    if (!satoshisBN) {\n      throw new Error('internal error - need satoshisBN to verify FORKID transactions');\n    }\n  }\n\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags,\n    satoshisBN: satoshisBN\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  } // evaluate scriptSig\n\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags,\n    satoshisBN: satoshisBN\n  }); // evaluate scriptPubkey\n\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  } // Additional validation for spend-to-script-hash transactions:\n\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    } // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n\n\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags,\n      satoshisBN: satoshisBN\n    }); // evaluate redeemScript\n\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    }\n  } // The CLEANSTACK check is only performed after potential P2SH evaluation,\n  // as the non-P2SH evaluation of a P2SH script will obviously not result in\n  // a clean stack (the P2SH inputs remain). The same holds for witness\n  // evaluation.\n\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_CLEANSTACK) != 0) {\n    // Disallow CLEANSTACK without P2SH, as otherwise a switch\n    // CLEANSTACK->P2SH+CLEANSTACK would be possible, which is not a\n    // softfork (and P2SH should be one).\n    if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) == 0) {\n      throw new Error('internal error - CLEANSTACK without P2SH');\n    }\n\n    if (stackCopy.length != 1) {\n      this.errstr = 'SCRIPT_ERR_CLEANSTACK';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function (obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.satoshisBN = obj.satoshisBN || this.satoshisBN;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = Buffer.from([1]);\nInterpreter.false = Buffer.from([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.MAXIMUM_ELEMENT_SIZE = 4;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD); // flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n\nInterpreter.SCRIPT_VERIFY_NONE = 0; // Evaluate P2SH subscripts (softfork safe, BIP16).\n\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0; // Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\n\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1; // Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\n\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2; // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\n\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3; // verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\n\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4; // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\n\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5; // Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\n\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6; // Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\n\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7; // Require that only a single stack element remains after evaluation. This\n// changes the success criterion from \"At least one stack element must\n// remain, and when interpreted as a boolean, it must be true\" to \"Exactly\n// one stack element must remain, and when interpreted as a boolean, it must // be true\".\n// (softfork safe, BIP62 rule 6)\n// Note: CLEANSTACK should never be used without P2SH or WITNESS.\n\nInterpreter.SCRIPT_VERIFY_CLEANSTACK = 1 << 8, // CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9; // support CHECKSEQUENCEVERIFY opcode\n//\n// See BIP112 for details\n\nInterpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY = 1 << 10; // Segwit script only: Require the argument of OP_IF/NOTIF to be exactly\n// 0x01 or empty vector\n//\n\nInterpreter.SCRIPT_VERIFY_MINIMALIF = 1 << 13; // Signature(s) must be empty vector if an CHECK(MULTI)SIG operation failed\n//\n\nInterpreter.SCRIPT_VERIFY_NULLFAIL = 1 << 14; // Public keys in scripts must be compressed\n\nInterpreter.SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE = 1 << 15; // Do we accept signature using SIGHASH_FORKID\n//\n\nInterpreter.SCRIPT_ENABLE_SIGHASH_FORKID = 1 << 16; // Do we accept activate replay protection using a different fork id.\n//\n\nInterpreter.SCRIPT_ENABLE_REPLAY_PROTECTION = 1 << 17; // Enable new opcodes.\n//\n\nInterpreter.SCRIPT_ENABLE_CHECKDATASIG = 1 << 18, // The exception to CLEANSTACK and P2SH for the recovery of coins sent\n// to p2sh segwit addresses is not allowed.\nInterpreter.SCRIPT_DISALLOW_SEGWIT_RECOVERY = 1 << 20; // Whether to allow new OP_CHECKMULTISIG logic to trigger. (new multisig\n// logic verifies faster, and only allows Schnorr signatures)\n\nInterpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG = 1 << 21,\n/* Below flags apply in the context of BIP 68*/\n\n/**\n * If this flag set, CTxIn::nSequence is NOT interpreted as a relative\n * lock-time.\n */\nInterpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG = 1 << 31;\n/**\n * If CTxIn::nSequence encodes a relative lock-time and this flag is set,\n * the relative lock-time has units of 512 seconds, otherwise it specifies\n * blocks with a granularity of 1.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_TYPE_FLAG = 1 << 22;\n/**\n * If CTxIn::nSequence encodes a relative lock-time, this mask is applied to\n * extract that lock-time from the sequence field.\n */\n\nInterpreter.SEQUENCE_LOCKTIME_MASK = 0x0000ffff;\n\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nInterpreter.isSchnorrSig = function (buf) {\n  return (buf.length === 64 || buf.length === 65) && buf[0] !== 0x30;\n};\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\n\n\nInterpreter.prototype.checkRawSignatureEncoding = function (buf) {\n  var sig; //TODO update interpreter.js and necessary functions to match bitcoin-abc interpreter.cpp\n\n  if (Interpreter.isSchnorrSig(buf)) {\n    return true;\n  }\n\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  }\n\n  return true;\n}; // Back compat\n\n\nInterpreter.prototype.checkSignatureEncoding = Interpreter.prototype.checkTxSignatureEncoding = function (buf) {\n  // Empty signature. Not strictly DER encoded, but allowed to provide a\n  // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n  if (buf.length == 0) {\n    return true;\n  }\n\n  if (!this.checkRawSignatureEncoding(buf.slice(0, buf.length - 1))) {\n    return false;\n  }\n\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    var sig = Signature.fromTxFormat(buf);\n\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n\n    if (!(this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID) && sig.nhashtype & Signature.SIGHASH_FORKID) {\n      this.errstr = 'SCRIPT_ERR_ILLEGAL_FORKID';\n      return false;\n    }\n\n    if (this.flags & Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID && !(sig.nhashtype & Signature.SIGHASH_FORKID)) {\n      this.errstr = 'SCRIPT_ERR_MUST_USE_FORKID';\n      return false;\n    }\n  }\n\n  return true;\n};\n\nInterpreter.prototype.checkDataSignatureEncoding = function (buf) {\n  // Empty signature. Not strictly DER encoded, but allowed to provide a\n  // compact way to provide an invalid signature for use with CHECK(MULTI)SIG\n  if (buf.length == 0) {\n    return true;\n  }\n\n  return this.checkRawSignatureEncoding(buf);\n};\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\n\n\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !(PublicKey.isValid(buf) || IsCompressedOrUncompressedPubkey(buf))) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n\n  return true;\n};\n\nfunction IsCompressedOrUncompressedPubkey(bufPubkey) {\n  switch (bufPubkey.length) {\n    case 33:\n      return bufPubkey[0] === 0x02 || bufPubkey[0] === 0x03;\n\n    case 64:\n      return bufPubkey[0] === 0x04;\n\n    default:\n      return false;\n  }\n}\n/**\n  *\n  * Check the buffer is minimally encoded (see https://github.com/bitcoincashorg/spec/blob/master/may-2018-reenabled-opcodes.md#op_bin2num)\n  *\n  *\n  */\n\n\nInterpreter._isMinimallyEncoded = function (buf, nMaxNumSize) {\n  nMaxNumSize = nMaxNumSize || Interpreter.MAXIMUM_ELEMENT_SIZE;\n\n  if (buf.length > nMaxNumSize) {\n    return false;\n  }\n\n  if (buf.length > 0) {\n    // Check that the number is encoded with the minimum possible number\n    // of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) == 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set it\n      // would conflict with the sign bit. An example of this case is\n      // +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) == 0) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n};\n/**\n  *\n  * minimally encode the buffer content\n  *\n  * @param {number} nMaxNumSize (max allowed size)\n  */\n\n\nInterpreter._minimallyEncode = function (buf) {\n  if (buf.length == 0) {\n    return buf;\n  } // If the last byte is not 0x00 or 0x80, we are minimally encoded.\n\n\n  var last = buf[buf.length - 1];\n\n  if (last & 0x7f) {\n    return buf;\n  } // If the script is one byte long, then we have a zero, which encodes as an\n  // empty array.\n\n\n  if (buf.length == 1) {\n    return Buffer.from('');\n  } // If the next byte has it sign bit set, then we are minimaly encoded.\n\n\n  if (buf[buf.length - 2] & 0x80) {\n    return buf;\n  } // We are not minimally encoded, we need to figure out how much to trim.\n\n\n  for (var i = buf.length - 1; i > 0; i--) {\n    // We found a non zero byte, time to encode.\n    if (buf[i - 1] != 0) {\n      if (buf[i - 1] & 0x80) {\n        // We found a byte with it sign bit set so we need one more\n        // byte.\n        buf[i++] = last;\n      } else {\n        // the sign bit is clear, we can use it.\n        buf[i - 1] |= last;\n      }\n\n      return buf.slice(0, i);\n    }\n  } // If we the whole thing is zeros, then we have a zero.\n\n\n  return Buffer.from('');\n};\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n\n      if (!fSuccess) {\n        return false;\n      }\n    } // Size limits\n\n\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\n\n\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n\n\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  } // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n\n\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Checks a sequence parameter with the transaction's sequence.\n * @param {BN} nSequence the sequence read from the script\n * @return {boolean} true if the transaction's sequence is less than or equal to\n *                   the transaction's sequence\n */\n\n\nInterpreter.prototype.checkSequence = function (nSequence) {\n  // Relative lock times are supported by comparing the passed in operand to\n  // the sequence number of the input.\n  var txToSequence = this.tx.inputs[this.nin].sequenceNumber; // Fail if the transaction's version number is not set high enough to\n  // trigger BIP 68 rules.\n\n  if (this.tx.version < 2) {\n    return false;\n  } // Sequence numbers with their most significant bit set are not consensus\n  // constrained. Testing that the transaction's sequence number do not have\n  // this bit set prevents using this property to get around a\n  // CHECKSEQUENCEVERIFY check.\n\n\n  if (txToSequence & SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n    return false;\n  } // Mask off any bits that do not have consensus-enforced meaning before\n  // doing the integer comparisons\n\n\n  var nLockTimeMask = Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG | Interpreter.SEQUENCE_LOCKTIME_MASK;\n  var txToSequenceMasked = new BN(txToSequence & nLockTimeMask);\n  var nSequenceMasked = nSequence.and(nLockTimeMask); // There are two kinds of nSequence: lock-by-blockheight and\n  // lock-by-blocktime, distinguished by whether nSequenceMasked <\n  // CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG.\n  //\n  // We want to compare apples to apples, so fail the script unless the type\n  // of nSequenceMasked being tested is the same as the nSequenceMasked in the\n  // transaction.\n\n  var SEQUENCE_LOCKTIME_TYPE_FLAG_BN = new BN(Interpreter.SEQUENCE_LOCKTIME_TYPE_FLAG);\n\n  if (!(txToSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.lt(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) || txToSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN) && nSequenceMasked.gte(SEQUENCE_LOCKTIME_TYPE_FLAG_BN))) {\n    return false;\n  } // Now that we know we're comparing apples-to-apples, the comparison is a\n  // simple numeric one.\n\n\n  if (nSequenceMasked.gt(txToSequenceMasked)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Implemented from bitcoin-abc\n * https://github.com/Bitcoin-ABC/bitcoin-abc/blob/f8cbc0e2b439aa4030430a7b1ecbdafede0dd072/src/script/bitfield.cpp\n * @param {*} dummy\n * @param {*} size\n */\n\n\nfunction DecodeBitfield(dummy, size) {\n  if (size > 32) {\n    this.errstr = \"INVALID_BITFIELD_SIZE\";\n    return {\n      result: false\n    };\n  }\n\n  var bitfieldSize = Math.floor((size + 7) / 8);\n  var dummyBitlength = dummy.length;\n\n  if (dummyBitlength !== bitfieldSize) {\n    this.errstr = \"INVALID_BITFIELD_SIZE\";\n    return {\n      result: false\n    };\n  }\n\n  var bitfield = 0;\n  var dummyAs32Bit = Uint32Array.from(dummy); // let one = new Uint8Array([1]);\n  // let oneAs64Bit = BigUint64Array.from(one);\n\n  for (var i = 0; i < bitfieldSize; i++) {\n    bitfield = bitfield | dummyAs32Bit[i] << 8 * i;\n  }\n\n  var mask = (0x01 << size) - 1;\n\n  if ((bitfield & mask) != bitfield) {\n    this.errstr = \"INVALID_BIT_RANGE\";\n    return {\n      result: false\n    };\n  }\n\n  return {\n    result: true,\n    bitfield: bitfield\n  };\n}\n/**\n * countBits\n * Implemented from https://github.com/Bitcoin-ABC/bitcoin-abc/blob/f8cbc0e2b439aa4030430a7b1ecbdafede0dd072/src/util/bitmanip.h\n * @param {*} v\n */\n\n\nfunction countBits(v) {\n  /**\n    * Computes the number of bits set in each group of 8bits then uses a\n    * multiplication to sum all of them in the 8 most significant bits and\n    * return these.\n    * More detailed explanation can be found at\n    * https://www.playingwithpointers.com/blog/swar.html\n  */\n  v = v - (v >> 1 & 0x55555555);\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333);\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\n/**\n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\n\n\nInterpreter.prototype.step = function () {\n  var self = this;\n\n  function stacktop(i) {\n    return self.stack[self.stack.length + i];\n  }\n\n  function isOpcodeDisabled(opcode) {\n    switch (opcode) {\n      case Opcode.OP_INVERT:\n      case Opcode.OP_2MUL:\n      case Opcode.OP_2DIV:\n      case Opcode.OP_MUL:\n      case Opcode.OP_LSHIFT:\n      case Opcode.OP_RSHIFT:\n        // Disabled opcodes.\n        return true;\n\n      case Opcode.OP_DIV:\n      case Opcode.OP_MOD:\n      case Opcode.OP_SPLIT:\n      case Opcode.OP_CAT:\n      case Opcode.OP_AND:\n      case Opcode.OP_OR:\n      case Opcode.OP_XOR:\n      case Opcode.OP_BIN2NUM:\n      case Opcode.OP_NUM2BIN:\n        // Opcodes that have been reenabled and do not need any flag as for Nov 14,2018\n        return false;\n\n      default:\n        break;\n    }\n\n    return false;\n  }\n\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0; //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, bufMessage, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess; // Read instruction\n\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  } // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n\n\n  if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n  if (isOpcodeDisabled(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf); // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n      //\n      // Control\n      //\n\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n\n\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5); // In the rare event that the argument may be < 0 due tod\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP3:\n      case Opcode.OP_CHECKSEQUENCEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)) {\n          // not enabled; treat as a NOP3\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        } // nSequence, like nLockTime, is a 32-bit unsigned\n        // integer field. See the comment in CHECKLOCKTIMEVERIFY\n        // regarding 5-byte numeric operands.\n\n\n        var nSequence = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal, 5); // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKSEQUENCEVERIFY.\n\n        if (nSequence.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        } // To provide for future soft-fork extensibility, if the\n        // operand has the disabled lock-time flag set,\n        // CHECKSEQUENCEVERIFY behaves as a NOP.\n\n\n        if ((nSequence & Interpreter.SEQUENCE_LOCKTIME_DISABLE_FLAG) != 0) {\n          break;\n        } // Actually compare the specified lock time with the transaction.\n\n\n        if (!this.checkSequence(nSequence)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n\n        break;\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n\n            buf = stacktop(-1);\n\n            if (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALIF) {\n              if (buf.length > 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n\n              if (buf.length == 1 && buf[0] != 1) {\n                this.errstr = 'SCRIPT_ERR_MINIMALIF';\n                return false;\n              }\n            }\n\n            fValue = Interpreter.castToBool(buf);\n\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n\n            this.stack.pop();\n          }\n\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n      //\n      // Stack ops\n      //\n\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-3);\n          buf2 = stacktop(-2);\n          var buf3 = stacktop(-1);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-4);\n          buf2 = stacktop(-3);\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          fValue = Interpreter.castToBool(buf);\n\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(stacktop(-1));\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.push(stacktop(-2));\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-n - 1);\n\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = stacktop(-3);\n          x2 = stacktop(-2);\n          var x3 = stacktop(-1);\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          x1 = stacktop(-2);\n          x2 = stacktop(-1);\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          this.stack.splice(this.stack.length - 2, 0, stacktop(-1));\n        }\n        break;\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn = new BN(stacktop(-1).length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n      //\n      // Bitwise logic\n      //\n\n      case Opcode.OP_AND:\n      case Opcode.OP_OR:\n      case Opcode.OP_XOR:\n        {\n          // (x1 x2 - out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1); // Inputs must be the same size\n\n          if (buf1.length !== buf2.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_OPERAND_SIZE';\n            return false;\n          } // To avoid allocating, we modify vch1 in place.\n\n\n          switch (opcodenum) {\n            case Opcode.OP_AND:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] &= buf2[i];\n              }\n\n              break;\n\n            case Opcode.OP_OR:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] |= buf2[i];\n              }\n\n              break;\n\n            case Opcode.OP_XOR:\n              for (var i = 0; i < buf1.length; i++) {\n                buf1[i] ^= buf2[i];\n              }\n\n              break;\n\n            default:\n              break;\n          } // And pop vch2.\n\n\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Numeric\n      //\n\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1);\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n\n              break;\n\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n            //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_MOD:\n      case Opcode.OP_DIV:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n            case Opcode.OP_DIV:\n              // denominator must not be 0\n              if (bn2 == 0) {\n                this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';\n                return false;\n              }\n\n              bn = bn1.div(bn2);\n              break;\n\n            case Opcode.OP_MOD:\n              // divisor must not be 0\n              if (bn2 == 0) {\n                this.errstr = 'SCRIPT_ERR_DIV_BY_ZERO';\n                return false;\n              }\n\n              bn = bn1.mod(bn2);\n              break;\n\n            case Opcode.OP_BOOLAND:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n\n            case Opcode.OP_BOOLOR:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n\n            case Opcode.OP_MIN:\n              bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n              break;\n\n            case Opcode.OP_MAX:\n              bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n              break;\n            // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(stacktop(-1))) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bn1 = BN.fromScriptNumBuffer(stacktop(-3), fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(stacktop(-2), fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal); //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n      //\n      // Crypto\n      //\n\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf = stacktop(-1); //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n\n          var bufHash;\n\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = stacktop(-2);\n          bufPubkey = stacktop(-1);\n\n          if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          }); // Drop the signature, since there's no way for a signature to sign itself\n\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n\n            if (!sig.isSchnorr) {\n              fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);\n            } else {\n              fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags, \"schnorr\");\n            }\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop(); // stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKDATASIG:\n      case Opcode.OP_CHECKDATASIGVERIFY:\n        {\n          // (sig message pubkey -- bool)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = stacktop(-3);\n          bufMessage = stacktop(-2);\n          bufPubkey = stacktop(-1);\n\n          if (!this.checkDataSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          fSuccess = false;\n\n          try {\n            sig = Signature.fromDataFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            bufHash = Hash.sha256(bufMessage);\n\n            if (!sig.isSchnorr) {\n              fSuccess = ECDSA.verify(bufHash, sig, pubkey, 'big');\n            } else {\n              fSuccess = Schnorr.verify(bufHash, sig, pubkey, 'big');\n            }\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && bufSig.length) {\n            this.errstr = 'SCRIPT_ERR_NULLFAIL';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKDATASIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKDATASIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_REVERSEBYTES:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-1);\n          var reversedBuf = Buffer.from(buf1).reverse();\n          this.stack.pop();\n          this.stack.push(reversedBuf);\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([dummy] [sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n          var i = 1;\n          var idxTopKey = i + 1;\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(stacktop(-i), fRequireMinimal).toNumber();\n          var idxSigCount = idxTopKey + nKeysCount;\n\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n\n          this.nOpCount += nKeysCount;\n\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          } // todo map interpreter.cpp variables with interpreter.js variables for future readability, maintainability\n          // ikey maps to idxTopKey in interpreter.cpp (MULTISIG case)\n\n\n          var ikey = ++i; // top pubkey\n\n          var idxTopSig = idxSigCount + 1; // i maps to idxSigCount in interpreter.cpp (MULTISIG case) (stack depth of nSigsCount)\n\n          i += nKeysCount; // ikey2 is the position of last non-signature item in\n          // the stack. Top stack item = 1. With\n          // SCRIPT_VERIFY_NULLFAIL, this is used for cleanup if\n          // operation fails.\n\n          var ikey2 = nKeysCount + 2; // ?dummy variable\n\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(stacktop(-idxSigCount), fRequireMinimal).toNumber();\n          var idxDummy = idxTopSig + nSigsCount;\n\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          } // int isig = ++i;\n\n\n          var isig = ++i;\n          i += nSigsCount;\n\n          if (this.stack.length < idxDummy) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          } // Subset of script starting at the most recent codeseparator\n\n\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n          fSuccess = true;\n\n          if (this.flags & Interpreter.SCRIPT_ENABLE_SCHNORR_MULTISIG && stacktop(-idxDummy).length !== 0) {\n            // SCHNORR MULTISIG\n            var dummy = stacktop(-idxDummy);\n            var bitfieldObj = DecodeBitfield(dummy, nKeysCount);\n\n            if (!bitfieldObj[\"result\"]) {\n              fSuccess = false;\n            }\n\n            var nSigs8bit = new Uint8Array([nSigsCount]);\n            var nSigs32 = Uint32Array.from(nSigs8bit);\n\n            if (countBits(bitfieldObj[\"bitfield\"]) !== nSigs32[0]) {\n              this.errstr = \"INVALID_BIT_COUNT\";\n              fSuccess = false;\n            }\n\n            var bottomKey = idxTopKey + nKeysCount - 1;\n            var bottomSig = idxTopSig + nSigsCount - 1;\n            var iKey = 0;\n\n            for (var iSig = 0; iSig < nSigsCount; iSig++, iKey++) {\n              if (bitfieldObj[\"bitfield\"] >> iKey === 0) {\n                this.errstr = \"INVALID_BIT_RANGE\";\n                fSuccess = false;\n              }\n\n              while ((bitfieldObj[\"bitfield\"] >> iKey & 0x01) == 0) {\n                if (iKey >= nKeysCount) {\n                  this.errstr = \"wrong\";\n                  fSuccess = false;\n                  break;\n                }\n\n                iKey++;\n              } // this is a sanity check and should be\n              // unreachable\n\n\n              if (iKey >= nKeysCount) {\n                this.errstr = \"PUBKEY_COUNT\";\n                fSuccess = false;\n              } // Check the signature\n\n\n              var bufsig = stacktop(-bottomSig + iSig);\n\n              var _bufPubkey = stacktop(-bottomKey + iKey); // Note that only pubkeys associated with a\n              // signature are check for validity\n\n\n              if (!this.checkRawSignatureEncoding(bufsig) || !this.checkPubkeyEncoding(_bufPubkey)) {\n                fSuccess = false;\n              }\n\n              var _sig = Signature.fromTxFormat(bufsig);\n\n              var _pubkey = PublicKey.fromBuffer(_bufPubkey, false);\n\n              var _fOk = this.tx.verifySignature(_sig, _pubkey, this.nin, subscript, this.satoshisBN, this.flags, \"schnorr\");\n\n              if (!_fOk) {\n                this.errstr = \"SIG_NULLFAIL\";\n                fSuccess = false;\n              }\n            }\n\n            if (bitfieldObj[\"bitfield\"] >> iKey != 0) {\n              // This is a sanity check and should be\n              // unreachable.\n              this.errstr = \"INVALID_BIT_COUNT\";\n              fSuccess = false;\n            }\n          } else {\n            // Drop the signatures, since there's no way for a signature to sign itself\n            for (var k = 0; k < nSigsCount; k++) {\n              bufSig = stacktop(-isig - k);\n              subscript.findAndDelete(new Script().add(bufSig));\n            }\n\n            while (fSuccess && nSigsCount > 0) {\n              // valtype& vchSig  = stacktop(-isig);\n              bufSig = stacktop(-isig); // valtype& vchPubKey = stacktop(-ikey);\n\n              bufPubkey = stacktop(-ikey);\n\n              if (!this.checkTxSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n                return false;\n              }\n\n              var fOk;\n\n              try {\n                sig = Signature.fromTxFormat(bufSig);\n                pubkey = PublicKey.fromBuffer(bufPubkey, false);\n                fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript, this.satoshisBN, this.flags);\n              } catch (e) {\n                //invalid sig or pubkey\n                fOk = false;\n              }\n\n              if (fOk) {\n                isig++;\n                nSigsCount--;\n              }\n\n              ikey++;\n              nKeysCount--; // If there are more signatures left than keys left,\n              // then too many signatures have failed\n\n              if (nSigsCount > nKeysCount) {\n                fSuccess = false;\n              }\n            }\n          } // Clean up stack of actual arguments\n\n\n          while (i-- > 1) {\n            if (!fSuccess && this.flags & Interpreter.SCRIPT_VERIFY_NULLFAIL && !ikey2 && stacktop(-1).length) {\n              this.errstr = 'SCRIPT_ERR_NULLFAIL';\n              return false;\n            }\n\n            if (ikey2 > 0) {\n              ikey2--;\n            }\n\n            this.stack.pop();\n          } // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n\n\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && stacktop(-1).length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      //\n      // Byte string operations\n      //\n\n      case Opcode.OP_CAT:\n        {\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2);\n          buf2 = stacktop(-1);\n\n          if (buf1.length + buf2.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n            this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n            return false;\n          }\n\n          this.stack[this.stack.length - 2] = Buffer.concat([buf1, buf2]);\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_SPLIT:\n        {\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-2); // Make sure the split point is apropriate.\n\n          var position = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();\n\n          if (position < 0 || position > buf1.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_SPLIT_RANGE';\n            return false;\n          } // Prepare the results in their own buffer as `data`\n          // will be invalidated.\n          // Copy buffer data, to slice it before\n\n\n          var n1 = Buffer.from(buf1); // Replace existing stack values by the new values.\n\n          this.stack[this.stack.length - 2] = n1.slice(0, position);\n          this.stack[this.stack.length - 1] = n1.slice(position);\n        }\n        break;\n      //\n      // Conversion operations\n      //\n\n      case Opcode.OP_NUM2BIN:\n        {\n          // (in -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var size = BN.fromScriptNumBuffer(stacktop(-1), fRequireMinimal).toNumber();\n\n          if (size > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n            this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n            return false;\n          }\n\n          this.stack.pop();\n          var rawnum = stacktop(-1); // Try to see if we can fit that number in the number of\n          // byte requested.\n\n          rawnum = Interpreter._minimallyEncode(rawnum);\n\n          if (rawnum.length > size) {\n            // We definitively cannot.\n            this.errstr = 'SCRIPT_ERR_IMPOSSIBLE_ENCODING';\n            return false;\n          } // We already have an element of the right size, we\n          // don't need to do anything.\n\n\n          if (rawnum.length == size) {\n            this.stack[this.stack.length - 1] = rawnum;\n            break;\n          }\n\n          var signbit = 0x00;\n\n          if (rawnum.length > 0) {\n            signbit = rawnum[rawnum.length - 1] & 0x80;\n            rawnum[rawnum.length - 1] &= 0x7f;\n          }\n\n          var num = Buffer.alloc(size);\n          rawnum.copy(num, 0);\n          var l = rawnum.length - 1;\n\n          while (l++ < size - 2) {\n            num[l] = 0x00;\n          }\n\n          num[l] = signbit;\n          this.stack[this.stack.length - 1] = num;\n        }\n        break;\n\n      case Opcode.OP_BIN2NUM:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          buf1 = stacktop(-1);\n          buf2 = Interpreter._minimallyEncode(buf1);\n          this.stack[this.stack.length - 1] = buf2; // The resulting number must be a valid number.\n\n          if (!Interpreter._isMinimallyEncoded(buf2)) {\n            this.errstr = 'SCRIPT_ERR_INVALID_NUMBER_RANGE';\n            return false;\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};","map":null,"metadata":{},"sourceType":"script"}