{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar BufferUtil = require('../util/buffer');\n\nvar JSUtil = require('../util/js');\n\nvar Signature = function Signature(r, s, isSchnorr) {\n  if (!(this instanceof Signature)) {\n    return new Signature(r, s, isSchnorr);\n  }\n\n  if (r instanceof BN) {\n    this.set({\n      r: r,\n      s: s,\n      isSchnorr: isSchnorr\n    });\n  } else if (r) {\n    var obj = r;\n    this.set(obj);\n  }\n};\n/* jshint maxcomplexity: 7 */\n\n\nSignature.prototype.set = function (obj) {\n  this.r = obj.r || this.r || undefined;\n  this.s = obj.s || this.s || undefined;\n  this.i = typeof obj.i !== 'undefined' ? obj.i : this.i; //public key recovery parameter in range [0, 3]\n\n  this.compressed = typeof obj.compressed !== 'undefined' ? obj.compressed : this.compressed; // whether the recovered pubkey is compressed\n\n  this.isSchnorr = obj.isSchnorr;\n  this.nhashtype = obj.nhashtype || this.nhashtype || undefined;\n  return this;\n};\n\nSignature.fromCompact = function (buf) {\n  $.checkArgument(BufferUtil.isBuffer(buf), 'Argument is expected to be a Buffer');\n  var sig = new Signature();\n  var compressed = true;\n  var i = buf.slice(0, 1)[0] - 27 - 4;\n\n  if (i < 0) {\n    compressed = false;\n    i = i + 4;\n  }\n\n  var b2 = buf.slice(1, 33);\n  var b3 = buf.slice(33, 65);\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be 0, 1, 2, or 3'));\n  $.checkArgument(b2.length === 32, new Error('r must be 32 bytes'));\n  $.checkArgument(b3.length === 32, new Error('s must be 32 bytes'));\n  sig.compressed = compressed;\n  sig.i = i;\n  sig.r = BN.fromBuffer(b2);\n  sig.s = BN.fromBuffer(b3);\n  return sig;\n};\n\nSignature.fromDER = Signature.fromBuffer = function (buf, strict) {\n  // Schnorr Signatures use 65 byte for in tx r [len] 32 , s [len] 32, nhashtype \n  if ((buf.length === 64 || buf.length === 65) && buf[0] != 0x30) {\n    var _obj = Signature.parseSchnorrEncodedSig(buf);\n\n    var _sig = new Signature();\n\n    _sig.r = _obj.r;\n    _sig.s = _obj.s;\n    _sig.isSchnorr = true;\n    return _sig;\n  }\n\n  if (buf.length === 64 && buf[0] === 0x30) {\n    return \"64 DER (ecdsa) signatures not allowed\";\n  }\n\n  var obj = Signature.parseDER(buf, strict);\n  var sig = new Signature();\n  sig.r = obj.r;\n  sig.s = obj.s;\n  return sig;\n}; // The format used in a tx\n\n\nSignature.fromTxFormat = function (buf) {\n  var nhashtype = buf.readUInt8(buf.length - 1);\n  var derbuf = buf.slice(0, buf.length - 1);\n  var sig = new Signature.fromDER(derbuf, false);\n  sig.nhashtype = nhashtype;\n  return sig;\n}; // The format used in a tx\n\n\nSignature.fromDataFormat = function (buf) {\n  var derbuf = buf.slice(0, buf.length);\n  var sig = new Signature.fromDER(derbuf, false);\n  return sig;\n};\n\nSignature.fromString = function (str) {\n  var buf = Buffer.from(str, 'hex');\n  return Signature.fromDER(buf);\n};\n\nSignature.parseSchnorrEncodedSig = function (buf) {\n  var r = buf.slice(0, 32);\n  var s = buf.slice(32, 64);\n  var hashtype;\n\n  if (buf.length === 65) {\n    hashtype = buf.slice(64, 65);\n    this.nhashtype = hashtype;\n  }\n\n  var obj = {\n    r: BN.fromBuffer(r),\n    s: BN.fromBuffer(s),\n    nhashtype: hashtype\n  };\n  return obj;\n};\n/**\n * In order to mimic the non-strict DER encoding of OpenSSL, set strict = false.\n */\n\n\nSignature.parseDER = function (buf, strict) {\n  $.checkArgument(BufferUtil.isBuffer(buf), new Error('DER formatted signature should be a buffer'));\n\n  if (_.isUndefined(strict)) {\n    strict = true;\n  }\n\n  var header = buf[0];\n  $.checkArgument(header === 0x30, new Error('Header byte should be 0x30'));\n  var length = buf[1];\n  var buflength = buf.slice(2).length;\n  $.checkArgument(!strict || length === buflength, new Error('Length byte should length of what follows'));\n  length = length < buflength ? length : buflength;\n  var rheader = buf[2 + 0];\n  $.checkArgument(rheader === 0x02, new Error('Integer byte for r should be 0x02'));\n  var rlength = buf[2 + 1];\n  var rbuf = buf.slice(2 + 2, 2 + 2 + rlength);\n  var r = BN.fromBuffer(rbuf);\n  var rneg = buf[2 + 1 + 1] === 0x00 ? true : false;\n  $.checkArgument(rlength === rbuf.length, new Error('Length of r incorrect'));\n  var sheader = buf[2 + 2 + rlength + 0];\n  $.checkArgument(sheader === 0x02, new Error('Integer byte for s should be 0x02'));\n  var slength = buf[2 + 2 + rlength + 1];\n  var sbuf = buf.slice(2 + 2 + rlength + 2, 2 + 2 + rlength + 2 + slength);\n  var s = BN.fromBuffer(sbuf);\n  var sneg = buf[2 + 2 + rlength + 2 + 2] === 0x00 ? true : false;\n  $.checkArgument(slength === sbuf.length, new Error('Length of s incorrect'));\n  var sumlength = 2 + 2 + rlength + 2 + slength;\n  $.checkArgument(length === sumlength - 2, new Error('Length of signature incorrect'));\n  var obj = {\n    header: header,\n    length: length,\n    rheader: rheader,\n    rlength: rlength,\n    rneg: rneg,\n    rbuf: rbuf,\n    r: r,\n    sheader: sheader,\n    slength: slength,\n    sneg: sneg,\n    sbuf: sbuf,\n    s: s\n  };\n  return obj;\n};\n\nSignature.prototype.toCompact = function (i, compressed) {\n  i = typeof i === 'number' ? i : this.i;\n  compressed = typeof compressed === 'boolean' ? compressed : this.compressed;\n\n  if (!(i === 0 || i === 1 || i === 2 || i === 3)) {\n    throw new Error('i must be equal to 0, 1, 2, or 3');\n  }\n\n  var val = i + 27 + 4;\n\n  if (compressed === false) {\n    val = val - 4;\n  }\n\n  var b1 = Buffer.from([val]);\n  var b2 = this.r.toBuffer({\n    size: 32\n  });\n  var b3 = this.s.toBuffer({\n    size: 32\n  });\n  return Buffer.concat([b1, b2, b3]);\n};\n\nSignature.prototype.toBuffer = Signature.prototype.toDER = function (signingMethod) {\n  // Schnorr signatures use a 64 byte r,s format, where as ECDSA takes the form decribed\n  // below, above the isDER function signature.\n  signingMethod = signingMethod || \"ecdsa\";\n\n  if (signingMethod === \"schnorr\") {\n    return Buffer.concat([this.r.toBuffer({\n      size: 32\n    }), this.s.toBuffer({\n      size: 32\n    })]);\n  }\n\n  var rnbuf = this.r.toBuffer();\n  var snbuf = this.s.toBuffer();\n  var rneg = rnbuf[0] & 0x80 ? true : false;\n  var sneg = snbuf[0] & 0x80 ? true : false;\n  var rbuf = rneg ? Buffer.concat([Buffer.from([0x00]), rnbuf]) : rnbuf;\n  var sbuf = sneg ? Buffer.concat([Buffer.from([0x00]), snbuf]) : snbuf;\n  var rlength = rbuf.length;\n  var slength = sbuf.length;\n  var length = 2 + rlength + 2 + slength;\n  var rheader = 0x02;\n  var sheader = 0x02;\n  var header = 0x30;\n  var der = Buffer.concat([Buffer.from([header, length, rheader, rlength]), rbuf, Buffer.from([sheader, slength]), sbuf]);\n  return der;\n};\n\nSignature.prototype.toString = function () {\n  var buf = this.toDER();\n  return buf.toString('hex');\n};\n\nSignature.isTxDER = function (buf) {\n  return Signature.isDER(buf.slice(0, buf.length - 1));\n};\n/**\n * This function is translated from bitcoind's IsDERSignature and is used in\n * the script interpreter.  This \"DER\" format actually includes an extra byte,\n * the nhashtype, at the end. It is really the tx format, not DER format.\n *\n * A canonical signature exists of: [30] [total len] [02] [len R] [R] [02] [len S] [S]\n * Where R and S are not negative (their first byte has its highest bit not set), and not\n * excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n * in which case a single 0 byte is necessary and even required).\n *\n * See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n */\n\n\nSignature.isDER = function (buf) {\n  // Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  // * total-length: 1-byte length descriptor of everything that follows,\n  // excluding the sighash byte.\n  // * R-length: 1-byte length descriptor of the R value that follows.\n  // * R: arbitrary-length big-endian encoded R value. It must use the\n  // shortest possible encoding for a positive integers (which means no null\n  // bytes at the start, except a single one when the next byte has its\n  // highest bit set).\n  // * S-length: 1-byte length descriptor of the S value that follows.\n  // * S: arbitrary-length big-endian encoded S value. The same rules apply.\n  // Minimum and maximum size constraints.\n  if (buf.length < 8 || buf.length > 72) {\n    return false;\n  } //\n  // Check that the signature is a compound structure of proper size.\n  //\n  // A signature is of type 0x30 (compound).\n\n\n  if (buf[0] != 0x30) {\n    return false;\n  } // Make sure the length covers the entire signature.\n  // Remove:\n  // * 1 byte for the coupound type.\n  // * 1 byte for the length of the signature.\n\n\n  if (buf[1] != buf.length - 2) {\n    return false;\n  } //\n  // Check that R is an positive integer of sensible size.\n  //\n  // Check whether the R element is an integer.\n\n\n  if (buf[2] != 0x02) {\n    return false;\n  } // Extract the length of the R element.\n\n\n  var lenR = buf[3]; // Zero-length integers are not allowed for R.\n\n  if (lenR == 0) {\n    return false;\n  } // Negative numbers are not allowed for R.\n\n\n  if (buf[4] & 0x80) {\n    return false;\n  } // Make sure the length of the R element is consistent with the signature\n  // size.\n  // Remove:\n  // * 1 byte for the coumpound type.\n  // * 1 byte for the length of the signature.\n  // * 2 bytes for the integer type of R and S.\n  // * 2 bytes for the size of R and S.\n  // * 1 byte for S itself.\n\n\n  if (lenR > buf.length - 7) {\n    return false;\n  } // Null bytes at the start of R are not allowed, unless R would otherwise be\n  // interpreted as a negative number.\n  //\n  // /!\\ This check can only be performed after we checked that lenR is\n  //     consistent with the size of the signature or we risk to access out of\n  //     bound elements.\n\n\n  if (lenR > 1 && buf[4] == 0x00 && !(buf[5] & 0x80)) {\n    return false;\n  } //\n  // Check that S is an positive integer of sensible size.\n  //\n  // S's definition starts after R's definition:\n  // * 1 byte for the coumpound type.\n  // * 1 byte for the length of the signature.\n  // * 1 byte for the size of R.\n  // * lenR bytes for R itself.\n  // * 1 byte to get to S.\n\n\n  var startS = lenR + 4; // Check whether the S element is an integer.\n\n  if (buf[startS] != 0x02) {\n    return false;\n  } // Extract the length of the S element.\n\n\n  var lenS = buf[startS + 1]; // Zero-length integers are not allowed for S.\n\n  if (lenS == 0) {\n    return false;\n  } // Negative numbers are not allowed for S.\n\n\n  if (buf[startS + 2] & 0x80) {\n    return false;\n  } // Verify that the length of S is consistent with the size of the signature\n  // including metadatas:\n  // * 1 byte for the integer type of S.\n  // * 1 byte for the size of S.\n\n\n  if (startS + lenS + 2 != buf.length) {\n    return false;\n  } // Null bytes at the start of S are not allowed, unless S would otherwise be\n  // interpreted as a negative number.\n  //\n  // /!\\ This check can only be performed after we checked that lenR and lenS\n  //     are consistent with the size of the signature or we risk to access\n  //     out of bound elements.\n\n\n  if (lenS > 1 && buf[startS + 2] == 0x00 && !(buf[startS + 3] & 0x80)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * Compares to bitcoind's IsLowDERSignature\n * See also ECDSA signature algorithm which enforces this.\n * See also BIP 62, \"low S values in signatures\"\n */\n\n\nSignature.prototype.hasLowS = function () {\n  if (this.s.lt(new BN(1)) || this.s.gt(new BN('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @returns true if the nhashtype is exactly equal to one of the standard options or combinations thereof.\n * Translated from bitcoind's IsDefinedHashtypeSignature\n */\n\n\nSignature.prototype.hasDefinedHashtype = function () {\n  if (!JSUtil.isNaturalNumber(this.nhashtype)) {\n    return false;\n  } // accept with or without Signature.SIGHASH_ANYONECANPAY by ignoring the bit\n  // base mask was 1F\n\n\n  var mask = ~(Signature.SIGHASH_FORKID | Signature.SIGHASH_ANYONECANPAY) >>> 0;\n  var temp = this.nhashtype & mask;\n\n  if (temp < Signature.SIGHASH_ALL || temp > Signature.SIGHASH_SINGLE) {\n    return false;\n  }\n\n  return true;\n};\n\nSignature.prototype.toTxFormat = function (signingMethod) {\n  var derbuf = this.toDER(signingMethod);\n  var buf = Buffer.alloc(1);\n  buf.writeUInt8(this.nhashtype, 0);\n  return Buffer.concat([derbuf, buf]);\n};\n\nSignature.SIGHASH_ALL = 0x01;\nSignature.SIGHASH_NONE = 0x02;\nSignature.SIGHASH_SINGLE = 0x03;\nSignature.SIGHASH_FORKID = 0x40;\nSignature.SIGHASH_ANYONECANPAY = 0x80;\nmodule.exports = Signature;","map":null,"metadata":{},"sourceType":"script"}