{"ast":null,"code":"import { NullLogger } from \"@renproject/interfaces\";\nimport { assertType } from \"./assert\";\nimport { fromBase64, fromHex, Ox, rawEncode, toBase64, toURLBase64 } from \"./common\";\nimport { keccak256 } from \"./hash\"; // export const generateNHash = (tx: Tx): Buffer => {\n//     const encoded = rawEncode(\n//         [\"bytes32\", \"bytes32\"],\n//         [Ox(tx.hash), Ox(tx.args.n)],\n//     );\n//     return keccak256(encoded);\n// };\n\n/**\n * Hash the payloads associated with a RenVM cross-chain transaction.\n *\n * @param zip An array (or spread) of parameters with with types defined.\n */\n\nexport var generatePHash = function generatePHash(zip) {\n  var logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NullLogger;\n  // Check if they called as hashPayload([...]) instead of hashPayload(...)\n  var args = (Array.isArray(zip[0]) ? zip[0] : zip).filter(function (arg) {\n    return !arg.notInPayload;\n  });\n  var types = args.map(function (param) {\n    return param.type;\n  });\n  var values = args.map(function (param) {\n    return param.value;\n  });\n  var message = rawEncode(types, values);\n  var digest = keccak256(message);\n  logger.debug(\"pHash\", toBase64(digest), Ox(message), args);\n  return digest; // sha3 can accept a Buffer\n};\nexport var generateSHash = function generateSHash(selector) {\n  var toSelector = selector.replace(/\\/.*To/, \"/to\");\n  return keccak256(Buffer.from(toSelector));\n};\nexport var generateGHash = function generateGHash(payload, to, tokenIdentifier, nonce, v2) {\n  var logger = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : NullLogger;\n  // Type validation\n  assertType(\"Buffer\", {\n    nonce: nonce\n  });\n  assertType(\"string\", {\n    to: to,\n    token: tokenIdentifier\n  });\n  var pHash = generatePHash(payload, logger);\n  var encoded = v2 ? Buffer.concat([pHash, fromHex(tokenIdentifier), fromHex(to), nonce]) : rawEncode([\"bytes32\", \"address\", \"address\", \"bytes32\"], [pHash, tokenIdentifier, to, nonce]);\n  var digest = keccak256(encoded);\n  logger.debug(\"gHash\", toBase64(digest), Ox(encoded));\n  return digest;\n};\nexport var generateNHash = function generateNHash(nonce, txid, txindex, v2) {\n  var logger = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : NullLogger;\n  var encoded = v2 ? Buffer.concat([nonce, txid, rawEncode([\"uint32\"], [txindex]).slice(-4)]) : rawEncode([\"bytes32\", \"bytes32\", \"uint32\"], [nonce, txid, txindex]);\n  var digest = keccak256(encoded);\n  logger.debug(\"nHash\", toBase64(digest), Ox(encoded));\n  return digest;\n};\nexport var generateSighash = function generateSighash(pHash, amount, to, tokenIdentifier, nonceHash, v2) {\n  var logger = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : NullLogger;\n  // Type validation\n  assertType(\"string\", {\n    to: to,\n    tokenIdentifier: tokenIdentifier\n  });\n  assertType(\"Buffer\", {\n    pHash: pHash,\n    nonceHash: nonceHash\n  });\n  var encoded = rawEncode([\"bytes32\", \"uint256\", v2 ? \"bytes32\" : \"address\", \"address\", \"bytes32\"], [pHash, amount, Ox(tokenIdentifier), Ox(to), nonceHash]);\n  var digest = keccak256(encoded);\n  logger.debug(\"sigHash\", toBase64(digest), Ox(encoded));\n  return digest;\n};\nexport var renVMHashToBase64 = function renVMHashToBase64(txHash, v2) {\n  // Type validation\n  assertType(\"string\", {\n    txHash: txHash\n  }); // Hex\n\n  if (/^(0x)?[0-9a-fA-Z]{64}$/.exec(txHash)) {\n    return (v2 ? toURLBase64 : toBase64)(fromHex(txHash));\n  } // Already base64. For v2, ensure it's in URL-base64 format.\n\n\n  return v2 ? toURLBase64(fromBase64(txHash)) : txHash;\n};\nexport var generateBurnTxHash = function generateBurnTxHash(selector, encodedID) {\n  var logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : NullLogger;\n  // Type validation\n  assertType(\"string\", {\n    encodedID: encodedID\n  });\n  var message = \"txHash_\".concat(selector, \"_\").concat(encodedID);\n  var digest = keccak256(Buffer.from(message));\n  logger.debug(\"Burn txHash\", toBase64(digest), message);\n  return digest;\n};","map":null,"metadata":{},"sourceType":"module"}