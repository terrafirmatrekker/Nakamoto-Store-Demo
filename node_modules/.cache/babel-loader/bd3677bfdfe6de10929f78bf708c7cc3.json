{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveActions = exports.choose = exports.escalate = exports.forwardTo = exports.pure = exports.error = exports.doneInvoke = exports.done = exports.after = exports.isActionObject = exports.assign = exports.resolveStop = exports.stop = exports.start = exports.cancel = exports.resolveLog = exports.log = exports.respond = exports.sendUpdate = exports.sendParent = exports.resolveSend = exports.send = exports.resolveRaise = exports.raise = exports.toActivityDefinition = exports.toActionObjects = exports.toActionObject = exports.getActionFunction = exports.initEvent = exports.actionTypes = void 0;\n\nvar types_1 = require(\"./types\");\n\nvar actionTypes = require(\"./actionTypes\");\n\nexports.actionTypes = actionTypes;\n\nvar utils_1 = require(\"./utils\");\n\nvar environment_1 = require(\"./environment\");\n\nexports.initEvent = utils_1.toSCXMLEvent({\n  type: actionTypes.init\n});\n\nfunction getActionFunction(actionType, actionFunctionMap) {\n  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;\n}\n\nexports.getActionFunction = getActionFunction;\n\nfunction toActionObject(action, actionFunctionMap) {\n  var actionObject;\n\n  if (utils_1.isString(action) || typeof action === 'number') {\n    var exec = getActionFunction(action, actionFunctionMap);\n\n    if (utils_1.isFunction(exec)) {\n      actionObject = {\n        type: action,\n        exec: exec\n      };\n    } else if (exec) {\n      actionObject = exec;\n    } else {\n      actionObject = {\n        type: action,\n        exec: undefined\n      };\n    }\n  } else if (utils_1.isFunction(action)) {\n    actionObject = {\n      // Convert action to string if unnamed\n      type: action.name || action.toString(),\n      exec: action\n    };\n  } else {\n    var exec = getActionFunction(action.type, actionFunctionMap);\n\n    if (utils_1.isFunction(exec)) {\n      actionObject = __assign(__assign({}, action), {\n        exec: exec\n      });\n    } else if (exec) {\n      var actionType = exec.type || action.type;\n      actionObject = __assign(__assign(__assign({}, exec), action), {\n        type: actionType\n      });\n    } else {\n      actionObject = action;\n    }\n  }\n\n  Object.defineProperty(actionObject, 'toString', {\n    value: function value() {\n      return actionObject.type;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return actionObject;\n}\n\nexports.toActionObject = toActionObject;\n\nvar toActionObjects = function toActionObjects(action, actionFunctionMap) {\n  if (!action) {\n    return [];\n  }\n\n  var actions = utils_1.isArray(action) ? action : [action];\n  return actions.map(function (subAction) {\n    return toActionObject(subAction, actionFunctionMap);\n  });\n};\n\nexports.toActionObjects = toActionObjects;\n\nfunction toActivityDefinition(action) {\n  var actionObject = toActionObject(action);\n  return __assign(__assign({\n    id: utils_1.isString(action) ? action : actionObject.id\n  }, actionObject), {\n    type: actionObject.type\n  });\n}\n\nexports.toActivityDefinition = toActivityDefinition;\n/**\n * Raises an event. This places the event in the internal event queue, so that\n * the event is immediately consumed by the machine in the current step.\n *\n * @param eventType The event to raise.\n */\n\nfunction raise(event) {\n  if (!utils_1.isString(event)) {\n    return send(event, {\n      to: types_1.SpecialTargets.Internal\n    });\n  }\n\n  return {\n    type: actionTypes.raise,\n    event: event\n  };\n}\n\nexports.raise = raise;\n\nfunction resolveRaise(action) {\n  return {\n    type: actionTypes.raise,\n    _event: utils_1.toSCXMLEvent(action.event)\n  };\n}\n\nexports.resolveRaise = resolveRaise;\n/**\n * Sends an event. This returns an action that will be read by an interpreter to\n * send the event in the next step, after the current step is finished executing.\n *\n * @param event The event to send.\n * @param options Options to pass into the send event:\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n *  - `to` - The target of this event (by default, the machine the event was sent from).\n */\n\nfunction send(event, options) {\n  return {\n    to: options ? options.to : undefined,\n    type: actionTypes.send,\n    event: utils_1.isFunction(event) ? event : utils_1.toEventObject(event),\n    delay: options ? options.delay : undefined,\n    id: options && options.id !== undefined ? options.id : utils_1.isFunction(event) ? event.name : utils_1.getEventType(event)\n  };\n}\n\nexports.send = send;\n\nfunction resolveSend(action, ctx, _event, delaysMap) {\n  var meta = {\n    _event: _event\n  }; // TODO: helper function for resolving Expr\n\n  var resolvedEvent = utils_1.toSCXMLEvent(utils_1.isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);\n  var resolvedDelay;\n\n  if (utils_1.isString(action.delay)) {\n    var configDelay = delaysMap && delaysMap[action.delay];\n    resolvedDelay = utils_1.isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;\n  } else {\n    resolvedDelay = utils_1.isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;\n  }\n\n  var resolvedTarget = utils_1.isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;\n  return __assign(__assign({}, action), {\n    to: resolvedTarget,\n    _event: resolvedEvent,\n    event: resolvedEvent.data,\n    delay: resolvedDelay\n  });\n}\n\nexports.resolveSend = resolveSend;\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\n\nfunction sendParent(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: types_1.SpecialTargets.Parent\n  }));\n}\n\nexports.sendParent = sendParent;\n/**\n * Sends an update event to this machine's parent.\n */\n\nfunction sendUpdate() {\n  return sendParent(actionTypes.update);\n}\n\nexports.sendUpdate = sendUpdate;\n/**\n * Sends an event back to the sender of the original event.\n *\n * @param event The event to send back to the sender\n * @param options Options to pass into the send event\n */\n\nfunction respond(event, options) {\n  return send(event, __assign(__assign({}, options), {\n    to: function to(_, __, _a) {\n      var _event = _a._event;\n      return _event.origin; // TODO: handle when _event.origin is undefined\n    }\n  }));\n}\n\nexports.respond = respond;\n\nvar defaultLogExpr = function defaultLogExpr(context, event) {\n  return {\n    context: context,\n    event: event\n  };\n};\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\n\n\nfunction log(expr, label) {\n  if (expr === void 0) {\n    expr = defaultLogExpr;\n  }\n\n  return {\n    type: actionTypes.log,\n    label: label,\n    expr: expr\n  };\n}\n\nexports.log = log;\n\nvar resolveLog = function resolveLog(action, ctx, _event) {\n  return __assign(__assign({}, action), {\n    value: utils_1.isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {\n      _event: _event\n    })\n  });\n};\n\nexports.resolveLog = resolveLog;\n/**\n * Cancels an in-flight `send(...)` action. A canceled sent action will not\n * be executed, nor will its event be sent, unless it has already been sent\n * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).\n *\n * @param sendId The `id` of the `send(...)` action to cancel.\n */\n\nvar cancel = function cancel(sendId) {\n  return {\n    type: actionTypes.cancel,\n    sendId: sendId\n  };\n};\n\nexports.cancel = cancel;\n/**\n * Starts an activity.\n *\n * @param activity The activity to start.\n */\n\nfunction start(activity) {\n  var activityDef = toActivityDefinition(activity);\n  return {\n    type: types_1.ActionTypes.Start,\n    activity: activityDef,\n    exec: undefined\n  };\n}\n\nexports.start = start;\n/**\n * Stops an activity.\n *\n * @param actorRef The activity to stop.\n */\n\nfunction stop(actorRef) {\n  var activity = utils_1.isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);\n  return {\n    type: types_1.ActionTypes.Stop,\n    activity: activity,\n    exec: undefined\n  };\n}\n\nexports.stop = stop;\n\nfunction resolveStop(action, context, _event) {\n  var actorRefOrString = utils_1.isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;\n  var resolvedActorRef = typeof actorRefOrString === 'string' ? {\n    id: actorRefOrString\n  } : actorRefOrString;\n  var actionObject = {\n    type: types_1.ActionTypes.Stop,\n    activity: resolvedActorRef\n  };\n  return actionObject;\n}\n\nexports.resolveStop = resolveStop;\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update.\n */\n\nvar assign = function assign(assignment) {\n  return {\n    type: actionTypes.assign,\n    assignment: assignment\n  };\n};\n\nexports.assign = assign;\n\nfunction isActionObject(action) {\n  return typeof action === 'object' && 'type' in action;\n}\n\nexports.isActionObject = isActionObject;\n/**\n * Returns an event type that represents an implicit event that\n * is sent after the specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\n\nfunction after(delayRef, id) {\n  var idSuffix = id ? \"#\" + id : '';\n  return types_1.ActionTypes.After + \"(\" + delayRef + \")\" + idSuffix;\n}\n\nexports.after = after;\n/**\n * Returns an event that represents that a final state node\n * has been reached in the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param data The data to pass into the event\n */\n\nfunction done(id, data) {\n  var type = types_1.ActionTypes.DoneState + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nexports.done = done;\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state node,\n * but not when it is canceled.\n *\n * @param id The final state node ID\n * @param data The data to pass into the event\n */\n\nfunction doneInvoke(id, data) {\n  var type = types_1.ActionTypes.DoneInvoke + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nexports.doneInvoke = doneInvoke;\n\nfunction error(id, data) {\n  var type = types_1.ActionTypes.ErrorPlatform + \".\" + id;\n  var eventObject = {\n    type: type,\n    data: data\n  };\n\n  eventObject.toString = function () {\n    return type;\n  };\n\n  return eventObject;\n}\n\nexports.error = error;\n\nfunction pure(getActions) {\n  return {\n    type: types_1.ActionTypes.Pure,\n    get: getActions\n  };\n}\n\nexports.pure = pure;\n/**\n * Forwards (sends) an event to a specified service.\n *\n * @param target The target service to forward the event to.\n * @param options Options to pass into the send action creator.\n */\n\nfunction forwardTo(target, options) {\n  return send(function (_, event) {\n    return event;\n  }, __assign(__assign({}, options), {\n    to: target\n  }));\n}\n\nexports.forwardTo = forwardTo;\n/**\n * Escalates an error by sending it as an event to this machine's parent.\n *\n * @param errorData The error data to send, or the expression function that\n * takes in the `context`, `event`, and `meta`, and returns the error data to send.\n * @param options Options to pass into the send action creator.\n */\n\nfunction escalate(errorData, options) {\n  return sendParent(function (context, event, meta) {\n    return {\n      type: actionTypes.error,\n      data: utils_1.isFunction(errorData) ? errorData(context, event, meta) : errorData\n    };\n  }, __assign(__assign({}, options), {\n    to: types_1.SpecialTargets.Parent\n  }));\n}\n\nexports.escalate = escalate;\n\nfunction choose(conds) {\n  return {\n    type: types_1.ActionTypes.Choose,\n    conds: conds\n  };\n}\n\nexports.choose = choose;\n\nfunction resolveActions(machine, currentState, currentContext, _event, actions) {\n  var _a = __read(utils_1.partition(actions, function (action) {\n    return action.type === actionTypes.assign;\n  }), 2),\n      assignActions = _a[0],\n      otherActions = _a[1];\n\n  var updatedContext = assignActions.length ? utils_1.updateContext(currentContext, _event, assignActions, currentState) : currentContext;\n  var resolvedActions = utils_1.flatten(otherActions.map(function (actionObject) {\n    var _a;\n\n    switch (actionObject.type) {\n      case actionTypes.raise:\n        return resolveRaise(actionObject);\n\n      case actionTypes.send:\n        var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init\n\n        if (!environment_1.IS_PRODUCTION) {\n          // warn after resolving as we can create better contextual message here\n          utils_1.warn(!utils_1.isString(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length\n          \"No delay reference for delay expression '\" + actionObject.delay + \"' was found on machine '\" + machine.id + \"'\");\n        }\n\n        return sendAction;\n\n      case actionTypes.log:\n        return exports.resolveLog(actionObject, updatedContext, _event);\n\n      case actionTypes.choose:\n        {\n          var chooseAction = actionObject;\n          var matchedActions = (_a = chooseAction.conds.find(function (condition) {\n            var guard = utils_1.toGuard(condition.cond, machine.options.guards);\n            return !guard || utils_1.evaluateGuard(machine, guard, updatedContext, _event, currentState);\n          })) === null || _a === void 0 ? void 0 : _a.actions;\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, exports.toActionObjects(utils_1.toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case actionTypes.pure:\n        {\n          var matchedActions = actionObject.get(updatedContext, _event.data);\n\n          if (!matchedActions) {\n            return [];\n          }\n\n          var resolved = resolveActions(machine, currentState, updatedContext, _event, exports.toActionObjects(utils_1.toArray(matchedActions), machine.options.actions));\n          updatedContext = resolved[1];\n          return resolved[0];\n        }\n\n      case actionTypes.stop:\n        {\n          return resolveStop(actionObject, updatedContext, _event);\n        }\n\n      default:\n        return toActionObject(actionObject, machine.options.actions);\n    }\n  }));\n  return [resolvedActions, updatedContext];\n}\n\nexports.resolveActions = resolveActions;","map":null,"metadata":{},"sourceType":"script"}