{"ast":null,"code":"var typeforce = require('typeforce');\n\nvar UINT31_MAX = Math.pow(2, 31) - 1;\n\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\n\nfunction BIP32Path(value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/);\n}\n\nBIP32Path.toJSON = function () {\n  return 'BIP32 derivation path';\n};\n\nvar SATOSHI_MAX = 21 * 1e14;\n\nfunction Satoshi(value) {\n  return typeforce.UInt53(value) && value <= SATOSHI_MAX;\n} // external dependent types\n\n\nvar BigInt = typeforce.quacksLike('BigInteger');\nvar ECPoint = typeforce.quacksLike('Point'); // exposed, external API\n\nvar ECSignature = typeforce.compile({\n  r: BigInt,\n  s: BigInt\n});\nvar networkVersion = typeforce.oneOf(typeforce.UInt8, typeforce.UInt16);\nvar Network = typeforce.compile({\n  messagePrefix: typeforce.oneOf(typeforce.Buffer, typeforce.String),\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  },\n  pubKeyHash: networkVersion,\n  scriptHash: networkVersion,\n  wif: typeforce.UInt8\n}); // extend typeforce types with ours\n\nvar types = {\n  BigInt: BigInt,\n  BIP32Path: BIP32Path,\n  Buffer256bit: typeforce.BufferN(32),\n  ECPoint: ECPoint,\n  ECSignature: ECSignature,\n  Hash160bit: typeforce.BufferN(20),\n  Hash256bit: typeforce.BufferN(32),\n  Network: Network,\n  Satoshi: Satoshi,\n  UInt31: UInt31,\n  NetworkVersion: networkVersion\n};\n\nfor (var typeName in typeforce) {\n  types[typeName] = typeforce[typeName];\n}\n\nmodule.exports = types;","map":null,"metadata":{},"sourceType":"script"}