{"ast":null,"code":"import _toArray from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _regeneratorRuntime from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/tejas/Desktop/marketplace2/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport bech32 from \"bech32\";\nimport { getRenNetworkDetails } from \"@renproject/interfaces\";\nimport { assertType, fromHex, hash160, retryNTimes, strip0x, toBase64, utilsWithChainNetwork } from \"@renproject/utils\";\nimport BigNumber from \"bignumber.js\";\nimport { Networks, Opcode, Script } from \"bitcore-lib\";\nimport base58 from \"bs58\";\nimport { CombinedAPI } from \"./APIs/API\";\nimport { Blockchair, BlockchairNetwork } from \"./APIs/blockchair\";\nimport { Blockstream } from \"./APIs/blockstream\";\nimport { SoChain, SoChainNetwork } from \"./APIs/sochain\";\nimport { createAddress, pubKeyScript as calculatePubKeyScript } from \"./script\";\n\nvar transactionToDeposit = function transactionToDeposit(transaction) {\n  return {\n    transaction: transaction,\n    amount: transaction.amount.toString()\n  };\n};\n/**\n * A base Bitcoin chain class that is extended by each Bitcoin chain/fork.\n */\n\n\nexport var BitcoinBaseChain = function BitcoinBaseChain(network) {\n  var _this = this;\n\n  _classCallCheck(this, BitcoinBaseChain);\n\n  this.chain = BitcoinBaseChain.chain;\n  this.name = BitcoinBaseChain.chain;\n  this.legacyName = \"Btc\";\n  this.asset = \"BTC\"; // APIs\n\n  this.withDefaultAPIs = function (network) {\n    switch (network) {\n      case \"mainnet\":\n        // prettier-ignore\n        return _this.withAPI(Blockstream()).withAPI(Blockchair()).withAPI(SoChain(), {\n          priority: 15\n        });\n\n      case \"testnet\":\n        // prettier-ignore\n        return _this.withAPI(Blockstream({\n          testnet: true\n        })).withAPI(Blockchair(BlockchairNetwork.BITCOIN_TESTNET)).withAPI(SoChain(SoChainNetwork.BTCTEST), {\n          priority: 15\n        });\n\n      case \"regtest\":\n        // Will be supported when Electrum is added as an API.\n        throw new Error(\"Regtest is currently not supported.\");\n    }\n  };\n\n  this.api = CombinedAPI();\n\n  this.withAPI = function (api) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$priority = _ref.priority,\n        priority = _ref$priority === void 0 ? 0 : _ref$priority;\n\n    _this.api.withAPI(api, {\n      priority: priority\n    });\n\n    return _this;\n  };\n\n  this.utils = utilsWithChainNetwork(BitcoinBaseChain.utils, function () {\n    return _this.chainNetwork;\n  });\n  /**\n   * See [[LockChain.initialize]].\n   */\n\n  this.initialize = function (renNetwork) {\n    _this.renNetwork = getRenNetworkDetails(renNetwork); // Prioritize the network passed in to the constructor.\n\n    _this.chainNetwork = _this.chainNetwork || (_this.renNetwork.isTestnet ? \"testnet\" : \"mainnet\");\n    return _this.withDefaultAPIs(_this.chainNetwork);\n  };\n  /**\n   * See [[LockChain.assetIsNative]].\n   */\n\n\n  this.assetIsNative = function (asset) {\n    return asset === _this.asset;\n  };\n\n  this.assetIsSupported = this.assetIsNative;\n\n  this.assertAssetIsSupported = function (asset) {\n    if (!_this.assetIsNative(asset)) {\n      throw new Error(\"Unsupported asset \".concat(asset, \".\"));\n    }\n  };\n  /**\n   * See [[LockChain.assetDecimals]].\n   */\n\n\n  this.assetDecimals = function (asset) {\n    if (asset === _this.asset) {\n      return 8;\n    }\n\n    throw new Error(\"Unsupported asset \".concat(asset));\n  };\n  /**\n   * See [[LockChain.getDeposits]].\n   */\n\n\n  this.getDeposits =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(asset, address, progress, onDeposit) {\n      var txs;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (_this.chainNetwork) {\n                _context2.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized\"));\n\n            case 2:\n              if (!(_this.chainNetwork === \"regtest\")) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw new Error(\"Unable to fetch deposits on \".concat(_this.chainNetwork));\n\n            case 4:\n              _this.assertAssetIsSupported(asset);\n\n              if (progress) {\n                _context2.next = 14;\n                break;\n              }\n\n              _context2.prev = 6;\n              _context2.next = 9;\n              return retryNTimes(function () {\n                return _this.api.fetchTXs(address);\n              }, 2);\n\n            case 9:\n              txs = _context2.sent;\n              _context2.next = 14;\n              break;\n\n            case 12:\n              _context2.prev = 12;\n              _context2.t0 = _context2[\"catch\"](6);\n\n            case 14:\n              if (txs) {\n                _context2.next = 18;\n                break;\n              }\n\n              _context2.next = 17;\n              return _this.api.fetchUTXOs(address);\n\n            case 17:\n              txs = _context2.sent;\n\n            case 18:\n              _context2.next = 20;\n              return Promise.all(txs.map(\n              /*#__PURE__*/\n              function () {\n                var _ref3 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee(tx) {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          return _context.abrupt(\"return\", onDeposit(transactionToDeposit(tx)));\n\n                        case 1:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x5) {\n                  return _ref3.apply(this, arguments);\n                };\n              }()));\n\n            case 20:\n              return _context2.abrupt(\"return\", true);\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[6, 12]]);\n    }));\n\n    return function (_x, _x2, _x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * See [[LockChain.transactionConfidence]].\n   */\n\n\n  this.transactionConfidence =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(transaction) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (_this.chainNetwork) {\n                _context3.next = 2;\n                break;\n              }\n\n              throw new Error(\"\".concat(_this.name, \" object not initialized\"));\n\n            case 2:\n              _context3.next = 4;\n              return _this.api.fetchUTXO(transaction.txHash, transaction.vOut);\n\n            case 4:\n              transaction = _context3.sent;\n              return _context3.abrupt(\"return\", {\n                current: transaction.confirmations,\n                target: _this.chainNetwork === \"mainnet\" ? 6 : 2\n              });\n\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  /**\n   * See [[LockChain.getGatewayAddress]].\n   */\n\n\n  this.getGatewayAddress = function (asset, publicKey, gHash) {\n    if (!_this.chainNetwork) {\n      throw new Error(\"\".concat(_this.name, \" object not initialized\"));\n    }\n\n    _this.assertAssetIsSupported(asset);\n\n    var isTestnet = _this.chainNetwork === \"testnet\";\n    return _this.utils.createAddress(isTestnet, hash160(publicKey), gHash, _this.utils.p2shPrefix[isTestnet ? \"testnet\" : \"mainnet\"]);\n  };\n  /**\n   * See [[LockChain.addressStringToBytes]].\n   */\n\n\n  this.addressStringToBytes = function (address) {\n    try {\n      return base58.decode(address);\n    } catch (error) {\n      try {\n        var _bech32$decode$words = _toArray(bech32.decode(address).words),\n            type = _bech32$decode$words[0],\n            words = _bech32$decode$words.slice(1);\n\n        return Buffer.concat([Buffer.from([type]), Buffer.from(bech32.fromWords(words))]);\n      } catch (internalError) {\n        throw new Error(\"Unrecognized address format \\\"\".concat(address, \"\\\".\"));\n      }\n    }\n  };\n  /**\n   * See [[LockChain.transactionID]].\n   */\n\n\n  this.transactionID = function (transaction) {\n    return transaction.txHash;\n  };\n\n  this.transactionFromID = function (txid, txindex, reversed) {\n    var txidString; // RenVM returns TXIDs in the correct byte direction, so they should be\n    // reversed when converting to a string.\n    // See https://learnmeabitcoin.com/technical/txid#why\n\n    if (reversed) {\n      // Reverse bytes.\n      var bufferTxid = typeof txid === \"string\" ? Buffer.from(strip0x(txid), \"hex\") : txid;\n      txidString = bufferTxid.reverse().toString(\"hex\");\n    } else {\n      txidString = typeof txid === \"string\" ? txid : txid.toString(\"hex\");\n    }\n\n    return _this.api.fetchUTXO(txidString, parseInt(txindex, 10));\n  };\n\n  this.depositV1HashString = function (_ref5) {\n    var transaction = _ref5.transaction;\n    return \"\".concat(toBase64(fromHex(transaction.txHash)), \"_\").concat(transaction.vOut);\n  };\n\n  this.transactionRPCFormat = function (transaction, v2) {\n    var txHash = transaction.txHash,\n        vOut = transaction.vOut;\n    assertType(\"string\", {\n      txHash: txHash\n    });\n    assertType(\"number\", {\n      vOut: vOut\n    });\n    return {\n      txid: v2 ? fromHex(transaction.txHash).reverse() : fromHex(transaction.txHash),\n      txindex: transaction.vOut.toFixed()\n    };\n  };\n  /**\n   * When burning, you can call `Bitcoin.Address(\"...\")` to make the address\n   * available to the burn params.\n   *\n   * @category Main\n   */\n\n\n  this.Address = function (address) {\n    // Type validation\n    assertType(\"string\", {\n      address: address\n    });\n\n    _this.getBurnPayload = function () {\n      return address;\n    };\n\n    return _this;\n  };\n\n  this.burnPayload = function () {\n    return _this.getBurnPayload ? _this.getBurnPayload() : undefined;\n  };\n\n  this.toSats = function (value) {\n    return new BigNumber(value).times(new BigNumber(10).exponentiatedBy(8)).decimalPlaces(0).toFixed();\n  };\n\n  this.fromSats = function (value) {\n    return new BigNumber(value).dividedBy(new BigNumber(10).exponentiatedBy(8)).toFixed();\n  };\n\n  this.chainNetwork = network;\n};\nBitcoinBaseChain.chain = \"Bitcoin\"; // Asset\n\nBitcoinBaseChain.asset = \"BTC\"; // Utils\n\nBitcoinBaseChain.utils = {\n  p2shPrefix: {},\n  createAddress: createAddress(base58.encode, Networks, Opcode, Script),\n  calculatePubKeyScript: calculatePubKeyScript(Networks, Opcode, Script),\n  addressIsValid: function addressIsValid(_address) {\n    var _network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"mainnet\";\n\n    return true;\n  },\n  addressExplorerLink: function addressExplorerLink(_address) {\n    var _network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"mainnet\";\n\n    return undefined;\n  },\n  transactionExplorerLink: function transactionExplorerLink(_tx) {\n    var _network = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"mainnet\";\n\n    return undefined;\n  },\n  resolveChainNetwork: function resolveChainNetwork(network) {\n    if (network === \"mainnet\" || network === \"testnet\" || network === \"regtest\") {\n      return network;\n    }\n\n    var renNetwork = getRenNetworkDetails(network);\n    return renNetwork.isTestnet ? \"testnet\" : \"mainnet\";\n  }\n};\nvar _ = BitcoinBaseChain;","map":null,"metadata":{},"sourceType":"module"}