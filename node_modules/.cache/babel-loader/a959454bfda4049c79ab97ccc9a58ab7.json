{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\n\nvar $ = require('../util/preconditions');\n\nvar BN = require('../crypto/bn');\n\nvar buffer = require('buffer');\n\nvar BufferWriter = require('../encoding/bufferwriter');\n\nvar BufferUtil = require('../util/buffer');\n\nvar JSUtil = require('../util/js'); // TODO: Update ZCProof for Groth\n//var ZCProof = require('../zcash/proof');\n\n\nvar ZC_NUM_JS_INPUTS = 2;\nvar ZC_NUM_JS_OUTPUTS = 2; // leading + v + rho + r + memo + auth\n\nvar ZC_NOTECIPHERTEXT_SIZE = 1 + 8 + 32 + 32 + 512 + 16;\n\nfunction JSDescription(params) {\n  if (!(this instanceof JSDescription)) {\n    return new JSDescription(params);\n  }\n\n  this.nullifiers = [];\n  this.commitments = [];\n  this.ciphertexts = [];\n  this.macs = [];\n\n  if (params) {\n    return this._fromObject(params);\n  }\n}\n\nObject.defineProperty(JSDescription.prototype, 'vpub_old', {\n  configurable: false,\n  enumerable: true,\n  get: function get() {\n    return this._vpub_old;\n  },\n  set: function set(num) {\n    if (num instanceof BN) {\n      this._vpub_oldBN = num;\n      this._vpub_old = num.toNumber();\n    } else if (_.isString(num)) {\n      this._vpub_old = parseInt(num);\n      this._vpub_oldBN = BN.fromNumber(this._vpub_old);\n    } else {\n      $.checkArgument(JSUtil.isNaturalNumber(num), 'vpub_old is not a natural number');\n      this._vpub_oldBN = BN.fromNumber(num);\n      this._vpub_old = num;\n    }\n\n    $.checkState(JSUtil.isNaturalNumber(this._vpub_old), 'vpub_old is not a natural number');\n  }\n});\nObject.defineProperty(JSDescription.prototype, 'vpub_new', {\n  configurable: false,\n  enumerable: true,\n  get: function get() {\n    return this._vpub_new;\n  },\n  set: function set(num) {\n    if (num instanceof BN) {\n      this._vpub_newBN = num;\n      this._vpub_new = num.toNumber();\n    } else if (_.isString(num)) {\n      this._vpub_new = parseInt(num);\n      this._vpub_newBN = BN.fromNumber(this._vpub_new);\n    } else {\n      $.checkArgument(JSUtil.isNaturalNumber(num), 'vpub_new is not a natural number');\n      this._vpub_newBN = BN.fromNumber(num);\n      this._vpub_new = num;\n    }\n\n    $.checkState(JSUtil.isNaturalNumber(this._vpub_new), 'vpub_new is not a natural number');\n  }\n});\n\nJSDescription.fromObject = function (obj) {\n  $.checkArgument(_.isObject(obj));\n  var jsdesc = new JSDescription();\n  return jsdesc._fromObject(obj);\n};\n\nJSDescription.prototype._fromObject = function (params) {\n  var nullifiers = [];\n\n  _.each(params.nullifiers, function (nullifier) {\n    nullifiers.push(BufferUtil.reverse(new buffer.Buffer(nullifier, 'hex')));\n  });\n\n  var commitments = [];\n\n  _.each(params.commitments, function (commitment) {\n    commitments.push(BufferUtil.reverse(new buffer.Buffer(commitment, 'hex')));\n  });\n\n  var ciphertexts = [];\n\n  _.each(params.ciphertexts, function (ciphertext) {\n    ciphertexts.push(new buffer.Buffer(ciphertext, 'hex'));\n  });\n\n  var macs = [];\n\n  _.each(params.macs, function (mac) {\n    macs.push(BufferUtil.reverse(new buffer.Buffer(mac, 'hex')));\n  });\n\n  this.vpub_old = params.vpub_old;\n  this.vpub_new = params.vpub_new;\n  this.anchor = BufferUtil.reverse(new buffer.Buffer(params.anchor, 'hex'));\n  this.nullifiers = nullifiers;\n  this.commitments = commitments;\n  this.ephemeralKey = BufferUtil.reverse(new buffer.Buffer(params.ephemeralKey, 'hex'));\n  this.ciphertexts = ciphertexts;\n  this.randomSeed = BufferUtil.reverse(new buffer.Buffer(params.randomSeed, 'hex'));\n  this.macs = macs;\n  this.proof = params.proof; // TODO: Update ZCProof for Groth: ZCProof.fromObject(params.proof);\n\n  return this;\n};\n\nJSDescription.prototype.toObject = JSDescription.prototype.toJSON = function toObject() {\n  var nullifiers = [];\n\n  _.each(this.nullifiers, function (nullifier) {\n    nullifiers.push(BufferUtil.reverse(nullifier).toString('hex'));\n  });\n\n  var commitments = [];\n\n  _.each(this.commitments, function (commitment) {\n    commitments.push(BufferUtil.reverse(commitment).toString('hex'));\n  });\n\n  var ciphertexts = [];\n\n  _.each(this.ciphertexts, function (ciphertext) {\n    ciphertexts.push(ciphertext.toString('hex'));\n  });\n\n  var macs = [];\n\n  _.each(this.macs, function (mac) {\n    macs.push(BufferUtil.reverse(mac).toString('hex'));\n  });\n\n  var obj = {\n    vpub_old: this.vpub_old,\n    vpub_new: this.vpub_new,\n    anchor: BufferUtil.reverse(this.anchor).toString('hex'),\n    nullifiers: nullifiers,\n    commitments: commitments,\n    ephemeralKey: BufferUtil.reverse(this.ephemeralKey).toString('hex'),\n    ciphertexts: ciphertexts,\n    randomSeed: BufferUtil.reverse(this.randomSeed).toString('hex'),\n    macs: macs,\n    proof: this.proof // TODO: Update ZCProof for Groth: this.proof.toObject(),\n\n  };\n  return obj;\n};\n\nJSDescription.fromBufferReader = function (br, useGrothFlagParam) {\n  var i;\n  var jsdesc = new JSDescription();\n  jsdesc.vpub_old = br.readUInt64LEBN();\n  jsdesc.vpub_new = br.readUInt64LEBN();\n  jsdesc.anchor = br.read(32);\n\n  for (i = 0; i < ZC_NUM_JS_INPUTS; i++) {\n    jsdesc.nullifiers.push(br.read(32));\n  }\n\n  for (i = 0; i < ZC_NUM_JS_OUTPUTS; i++) {\n    jsdesc.commitments.push(br.read(32));\n  }\n\n  jsdesc.ephemeralKey = br.read(32);\n  jsdesc.randomSeed = br.read(32);\n\n  for (i = 0; i < ZC_NUM_JS_INPUTS; i++) {\n    jsdesc.macs.push(br.read(32));\n  } // Default parameter requires ECMASCript 6 which might not be available, so use workaround.\n\n\n  var useGrothFlag = useGrothFlagParam || false;\n\n  if (!useGrothFlag) {\n    jsdesc.proof = br.read(296); // TODO: Update ZCProof for Groth: ZCProof.fromBufferReader(br);\n  } else {\n    jsdesc.proof = br.read(48 + 96 + 48);\n  }\n\n  for (i = 0; i < ZC_NUM_JS_OUTPUTS; i++) {\n    jsdesc.ciphertexts.push(br.read(ZC_NOTECIPHERTEXT_SIZE));\n  }\n\n  return jsdesc;\n};\n\nJSDescription.prototype.toBufferWriter = function (writer) {\n  var i;\n\n  if (!writer) {\n    writer = new BufferWriter();\n  }\n\n  writer.writeUInt64LEBN(this._vpub_oldBN);\n  writer.writeUInt64LEBN(this._vpub_newBN);\n  writer.write(this.anchor);\n\n  for (i = 0; i < ZC_NUM_JS_INPUTS; i++) {\n    writer.write(this.nullifiers[i]);\n  }\n\n  for (i = 0; i < ZC_NUM_JS_OUTPUTS; i++) {\n    writer.write(this.commitments[i]);\n  }\n\n  writer.write(this.ephemeralKey);\n  writer.write(this.randomSeed);\n\n  for (i = 0; i < ZC_NUM_JS_INPUTS; i++) {\n    writer.write(this.macs[i]);\n  } // TODO: Update ZCProof for Groth: this.proof.toBufferWriter(writer);\n\n\n  writer.write(this.proof);\n\n  for (i = 0; i < ZC_NUM_JS_OUTPUTS; i++) {\n    writer.write(this.ciphertexts[i]);\n  }\n\n  return writer;\n};\n\nmodule.exports = JSDescription;","map":null,"metadata":{},"sourceType":"script"}